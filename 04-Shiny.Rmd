# Shiny

Shiny is by far most popular, if not the only, web framework for the R programming language. In this chapter, after brushing up on the necessary to include JavaScript in our applications, we explore how to blend the JavaScript language with our R back-end.

Then again, the aim is not to write a lot of convoluted JavaScript, on the contrary, it is to write as little as possible and demonstrate to the reader that it is often enough to greatly improve the user experience of shiny applications. Making shiny work with JavaScript can essentially be broken down into two operations: 1) passing data from the R server to the JavaScript client and 2) the other way around, from the client to the R server.

## Static Files {-}

In order to introduce JavaScript to shiny applications one must understand static files and how they work with the framework. Static files are files that are downloaded by the clients (web browsers) as-is and generally include images, CSS (`.css`), and JavaScript (`.js`).

There are numerous ways to run a shiny application locally; the two most used ones are probably `shinyApp` and `runApp`. The RStudio IDE comes with a convenient "Run" button when writing a shiny application, which when clicked know actually uses the function `shiny::runApp` in the background, this function looks for said static files in the `www` directory and makes them available at the same path (`/www`). If you are building your applications outside of RStudio, you should either also use `shiny::runApp` or specify the directory which then allows simply using `shiny::shinyApp`. Note that this only applies locally, shiny server (community and pro) as well as [shinyapps.io](https://www.shinyapps.io/) use the same defaults as the RStudio IDE.

In order to ensure the code in this book can run regardless of the reader's machine or editor, the asset directory is always specified. This is probably advised to steer clear of the potential headaches as, unlike the default, it'll work regardless of the environment. If you are using [golem](https://thinkr-open.github.io/golem/) [@R-golem] to develop your application then you should not worry about this as it specifies the directory internally.

Below we build a basic shiny application, however, before we define the ui and server we use the `shiny::addResourcePath` function to specify the location of the directory of static files that will be served by the server and thus accessible by the client. This function takes two arguments, first the `prefix`, which is the path (URL) at which the assets will be available, second the path to the directory of static assets.

We thus create the "assets" directory and a JavaScript file called `script.js` within it.

```r
# run from root of app (where app.R is located)
dir.create("assets")
writeLines("console.log('Hello JS!');", con = "assets/script.js")
```

We can now use the `shiny::addResourcePath` to point to this directory. Generally developers use the same name for the directory of static assets and prefix so as to avoid confusion, below we name them differently in order for the reader to clearly distinguish which is which.

```r
# app.R
library(shiny)

# serve the files
addResourcePath(prefix = "files", directoryPath = "assets")

ui <- fluidPage(
  h1("R and JavaScript")
)

server <- function(input, output){}

shinyApp(ui, server)
```

If you then run the application and open it at the `/files/script.js` path (e.g.:127.0.0.1:3000/files/script.js) you should see the content of our JavaScript file (`console.log('Hello JS!')`), commenting the `addResourcePath` line will have a "Not Found" error displayed on the page instead.

```{block, class='important'}
All files in your asset directory will be served online and accessible to anyone: do not place sensitive files in it.
```

Though one may create multiple such directory and correspondingly use `addResourcePath` to specify multiple paths and prefixes, one will generally specify a single one, named "assets" or "static," which contains multiple subdirectories, one for each type of static asset file to obtain a directory that looks something like the tree below.

```
assets/
├── js/
│    └── script.js
├── css/
│    └── style.css
└── img/
     └── pic.png
```

At this stage we have made the JavaScript file we created accessible by the clients but we still have to source this file in our `ui`. Were one creating a static HTML page one would use the `script` to `src` the file in the `head` of the page.

```html
<html>
  <head>
    <!–– source the JavaScript file ––>
    <script src="path/to/script.js"></script>
  </head>
  <body>
    <p id="content">Trying JavaScript!</p>
  </body>
</html>
```

In shiny we generally write the ui in R and not in HTML. Given the resemblance between the names of HTML tags and shiny UI functions it's pretty straightforward, the html page above would look something like the shiny `ui` below. 

```r
library(shiny)

ui <- fluidPage(
  tags$head(
    tags$script(src = "path/to/script.js")
  ),
  p(id = "content", "Trying JavaScript!")
)
```

Note that we use the `tags` object which comes with shiny and includes HTML tags that are not exported as standalone functions. For instance, you can create a `<div>` in shiny with the `div` function but `tags$div` will also work. This can now be applied to the shiny application, the `path/to/script.js` should be changed to `files/script.js` where `files` is the prefix we defined in `addResourcePath`.

```r
# app.R
library(shiny)

# serve the files
addResourcePath(prefix = "files", directoryPath = "assets")

ui <- fluidPage(
  tags$head(
    tags$script(src = "files/script.js")
  ),
  h1("R and JavaScript")
)

server <- function(input, output){}

shinyApp(ui, server)
```

From the browser, inspecting page (right click > inspect) one should see "Hello JS!" in the console which means our application correctly ran the code in our JavaScript file.

## Integration {-}

The follow sections will walk you through an example in which one first starts with a basic hello-world-like JavaScript example and ends up with a fully-fledged R package that brings new functionalities to shiny by integrating a third party library.

We first build an application that passes a message from the R server to the client to display said message as a vanilla JavaScript alert (pop-up), then send back to the R server whether the user has clicked "OK" on the alert. Finally we replicate that but with an external library and wrap the whole project into a fully functional package.

First, let's write a barebone shiny application which includes the JavaScript code which opens an alert.

```r
library(shiny)

ui <- fluidPage(
  tags$script(
    "alert('Hello from JavaScript');"
  ),
  h1("Hello")
)

server <- function(input, output, session){}

shinyApp(ui, server)
```

![JavaScript alert in shiny](images/alert.png)

One thing important to note for later is that the content of our application (`h1("hello")`) is not actually shown until the user clicks "OK." Alert will always block the execution of code, it is used less and less but allows making sure some code is only run with user consent or the user being aware of the consequences.

```js
alert('delete everything?');
deleteEverythingOnlyIfUserOK();
```

## From R to JavaScript {-}

Now that we have a simple alert displayed in the application we can tie with our R server; the alert should display a message sent by the R server, this would enable us to, for instance, easily have the alert display a message taken from a database or a user input. As might be expected there are two functions required to do so, an R function and its JavaScript complementary: one to send the data from the server and another to catch said data from the client. 

Let us start by writing the R code to send the data, thankfully very little is required of the developer. One can send data from the R server to the client from the `session` object using the `sendCustomMessage` method. The method takes two arguments, first an identifier (where to send the data to), second the actual data to send to JavaScript.  

```r
server <- function(input, output, session){
  # set the identifier to send-alert
  session$sendCustomMessage(type = "send-alert", message = "Hi there!")
}
```

This effectively sends our message to the JavaScript client but we are yet to use that message JavaScript-side so the application still displays the same alert on load. We can add a "handler" for the identifier we defined (`send-alert`) which will so something with the message we sent from the server. This is done with the `addCustomMessageHandler` method from the `Shiny` object where the first argument is the identifier and the second is the function that handles the message, generally a function that takes a single argument: the data sent from the server. 

```r
tags$script(
  "Shiny.addCustomMessageHandler(type = 'send-alert', function(message) {
    alert(message);
  });"
)
```

![Alert sent from shiny server](images/alert-shiny.png)

This enables you to pass a message that is taken from a database for instance, or as shown below from a user input.

```r
library(shiny)

ui <- fluidPage(
  tags$script(
    "Shiny.addCustomMessageHandler(type = 'send-alert', function(message) {
      alert(message);
    });"
  ),
  h1("Hello"),
  textInput("text", "Text to show in alert"),
  actionButton("submit", "Show alert")
)

server <- function(input, output, session){
  observeEvent(input$submit, {
    session$sendCustomMessage(type = "send-alert", message = input$text)
  })
}

shinyApp(ui, server)
```

In the application above, notice the path that our message follows: it goes from the client to the server which sends it back to the client. This might be considered suboptimal by some as it is not necessary (in this example at least) to use the server as intermediary. Though there is some truth to this the above will work perfectly fine and---our aim here is to make JavaScript work with R not alongside it.

## JavaScript to R {-}

Imagine if you will that instead of displaying a somewhat anodyne alert it was one that actually mattered where the user is warned that clicking "OK" will execute an irreversible action like the deletion of a record. In order to implement this the server would need to "know" whether the user has clicked said "OK" button. Doing means passing data from the client to the server.

This can be done by defining a new _simplified_ shiny input. While one can define a fully-fledged shiny input that can be registered, updated, etc. there is also a simplified version of the latter which allows sending reactive input value to the server where it can be picked up with the usual `input$id`. This can be done with the `setInputValue` method which takes the id of the input and the value to give it.

```r
tags$script(
  "Shiny.addCustomMessageHandler(type = 'send-alert', function(message) {
    alert(message);
    Shiny.setInputValue('delete_alert', true);
  });"
)
```

As mentioned earlier `alert` blocks code execution, therefore the input will not be fired before the button "OK" is pressed. The server can now listen to `input$delete_alert` which is by default `NULL` and set to `TRUE` when the user has pressed "OK."

```r
library(shiny)

ui <- fluidPage(
  tags$script(
    "Shiny.addCustomMessageHandler(type = 'send-alert', function(message) {
      alert(message);
      Shiny.setInputValue('delete_alert', true);
    });"
  ),
  h1("Hello")
)

server <- function(input, output, session){
  session$sendCustomMessage(type = "send-alert", message = "Deleting a record!")

  observeEvent(input$delete_alert, {
    # print TRUE when button is clicked
    print(input$delete_alert) 
  })
}

shinyApp(ui, server)
```

## External Library

Thus far this chapter has covered both ways data travels between JavaScript and R in Shiny. However, the alert displayed in the previous sections are rather hideous but, though it demonstrates how both languages can work together within shiny, comes short of illustrating how one makes use of external libraries.

Let us introduce an external in our library, [jBox](https://github.com/StephanWagner/jBox) which allows displaying modals (pop-ups), very similar to the vanilla JavaScript alert but much better looking and has additional functionalities.

The very first thing to do is to import jBox in our project, we could download the files and use them as described in the previous static files section or use the convenient CDNs detailed in the [get-started documentation](https://stephanwagner.me/jBox/get_started) of jBox. The "j" in jBox stands for jQuery which is already a dependency of shiny itself, there is therefore no need to import it.

```r
ui <- fluidPage(
  tags$head(
    tags$script(
      src="https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/dist/jBox.all.min.js"
    ),
    tags$link(
      rel="stylesheet",
      href="https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/dist/jBox.all.min.css"
    ),
    tags$script("Shiny.addCustomMessageHandler(type = 'send-alert', function(message) {
      // TO DO: code jBox
    });")
  )
)
```

The jBox library comes with numerous features to display tooltips, modals, notices, and more, which would make for too long a chapter; only notices shall be covered here.

```r
library(shiny)

ui <- fluidPage(
  tags$head(
    tags$script(
      src="https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/dist/jBox.all.min.js"
    ),
    tags$link(
      rel="stylesheet",
      href="https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/dist/jBox.all.min.css"
    ),
    tags$script("Shiny.addCustomMessageHandler(type = 'send-alert', function(message) {
      new jBox('Notice', {
        content: message,
        color: 'blue'
      });
    });")
  )
)

server <- function(input, output, session){
  session$sendCustomMessage(type = "send-alert", message = "Deleting a record!")
}

shinyApp(ui, server)
```

## In Packages {-}
