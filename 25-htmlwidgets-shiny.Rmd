# Working with Shiny

A previous set of chapters explored how to make JavaScript and R communicate in shiny applications by passing data from the server to the client and back. This chapter explores how to apply that to htmlwidgets so they can provide additional functionalities when used in Shiny applications. 

To demonstrate how to integrate these functionalities in widgets we shall implement them in the previously built gio package.

## Callback {-}

JavaScript visualisation libraries will often include callbacks or events that are triggered when the user interacts with the visualisation so one be notified and run code when a user clicks a point on a scatter plot, or when the user clicks the legend of a chart for example. Gio.js provides a callback that is fired when a country is selected on the globe, this callback function accepts two objects, one containing data on the country selected and another containing data on the related countries (the arcs coming and leaving the selected country). This could be used to send that data back to the R server where it could be used from many things like fetching more data on the selected country from a database, or use that information to generate a shiny UI element.

The [documentation of gio.js](https://giojs.org/html/docs/callbackPicked.html) gives the following example callback function.

```js
// define callback function
function callback (selectedCountry, relatedCountries) {
  console.log(selectedCountry);
  console.log(relatedCountries);
}

// use callback function
controller.onCountryPicked(callback);
```

This defines a function named `callback` which takes the two aforementioned objects and logs them in the JavaScript console. Then the function is passed to the `controller` which will run it every time a country is picked. This can be incorporated into the widget. Instead of logging the data in the console it is used to define two different shiny inputs. Note the use of the widget identifier to define the input name.

```js
...
renderValue: function(x) {

  var container = document.getElementById(el.id);
  var controller = new GIO.Controller(container);
  controller.addData(x.data);
  controller.setStyle(x.style);

  // callback
  function callback (selectedCountry, relatedCountries) {
    Shiny.setInputValue(el.id + '_selected', selectedCountry);
    Shiny.setInputValue(el.id + '_related', relatedCountries);
  }

  controller.onCountryPicked(callback);

  // render
  controller.init();

}
...
```

The package can then be installed with `devtools::install` so we can test these inputs in a shiny application.

```r
library(gio)
library(shiny)

# large sample data
url <- paste0(
  "https://raw.githubusercontent.com/syt123450/",
  "giojs/master/examples/data/sampleData.json"
)
arcs <- jsonlite::fromJSON(url)

ui <- fluidRow(
  gioOutput("globe"),
  fluidRow(
    column(6, verbatimTextOutput("selectedCountry")),
    column(6, verbatimTextOutput("relatedCountries"))
  )
)

server <- function(input, output){

  output$globe <- renderGio({
    gio(arcs)
  })

  output$selectedCountry <- renderPrint({
    print(input$globe_selected)
  })

  output$relatedCountries <- renderPrint({
    print(input$globe_related)
  })

}

shinyApp(ui, server)
```

The data is sent from the client to the server whether the user uses the input or not, though this likely will not negatively impact gio it can reduce performances if the callback function is triggered too frequently. For instance setting an input value when the user hovers a scatter plot might lead to the event being fired very frequently and too much data being sent to the server, slowing things down and providing a poor experience.

Therefore one might consider making the capture of such event optional so the web browser is not strained unless explicitly required. You can also consider not sending back all the data. For instance, gio returns the coordinates of the selected country where from arc connect; this is might be considered unnecessary. The code below only sets the input to the ISO code of the country selected.

```js
function callback (selectedCountry, relatedCountries) {
  Shiny.setInputValue(el.id + '_selected', selectedCountry.ISOCode);
}
```

## Input Handler {-}

While input handlers were explored previously we found limited use for them as the input were set to simple boolean values. It can be useful in this case as the inputs return more data which could do with some preprocessing. Namely the input returning data on the related countries, it is deserialised to a list but could be reshaped to a data frame of arcs.

Below we create a handler that is going to loop over the list and return a data frame.

```r
# R/zzz.R
related_countries_handler <- function(x, session, inputname){
  purrr::map_dfr(x, as.data.frame)
}
```

Then we register the handler when the package is loaded.

```r
# R/zzz.R
related_countries_handler <- function(x, session, inputname){
  purrr::map_dfr(x, as.data.frame)
}

.onLoad <- function(libname, pkgname) {
  shiny::registerInputHandler("gio.related.countries", related_countries_handler)
}
```

Finally, we can reinstall the package with `devtools::install` and create shiny application to observe the change. Below we use a large example dataset and, since the input now returns a data frame, we can display the input value in a table.

```r
library(DT)
library(gio)
library(shiny)

# large sample data
url <- paste0(
  "https://raw.githubusercontent.com/syt123450/",
  "giojs/master/examples/data/sampleData.json"
)
arcs <- jsonlite::fromJSON(url)

ui <- fluidRow(
  gioOutput("globe"),
  DTOutput("relatedCountries")
)

server <- function(input, output){

  output$globe <- renderGio({
    gio(arcs)
  })

  output$relatedCountries <- renderDT({
    datatable(input$globe_related)
  })

}

shinyApp(ui, server)
```

![Input transformed to data frame](images/gio-input-handler.png)

## R to JavaScript {-}

This book previously explored how to send data to the from the shiny server to the front-end, this section looks to apply this to htmlwidgets. Currently, gio in shiny consists of generating the globe with the `renderGio` and complimentary `gioOutput` functions. This generates the entire visualisation, it creates the globe, draws the arcs based on the data, sets the style, everything. 

Now imagine a scenario where we provide a `selectInput` to the user so they can choose between two datasets to visualise. First, there is no need to re-generate the entire visualisation, only the data changes, the style, background globe, and everything else can remain unchanged. This is more efficient computationally, both for the server and the client, and makes for much cleaner transitions and animations. Secondly, running `renderGio` currently does not work properly, gio.js does not replace the initigeneral visualisation but instead creates a new one below. This is admittedly somewhat particular to the gio.js functions and will likely not be the case with other libraries. The problem described can be observed running the application below: multiple visualisations are generated.

```r
library(gio)
library(shiny)

arcs1 <- data.frame(
  e = c("US", "CN", "RU"),
  i = c("CN", "RU", "US"),
  v = c(100, 120, 130)
)

arcs2 <- data.frame(
  e = c("CN", "CN", "JP"),
  i = c("IN", "JP", "US"),
  v = c(100, 120, 130)
)

ui <- fluidRow(
  selectInput(
    "dataset", 
    "Select a dataset", 
    choices = c("First", "Second")
  ),
  gioOutput("globe")
)

server <- function(input, output){

  reactive_arcs <- reactive({
    if(input$dataset == "First") 
      return(arcs1)
    return(arcs2)
  })

  output$globe <- renderGio({
    gio(reactive_arcs())
  })

}

shinyApp(ui, server)
```

Internally gio.js creates a new element (`<canvas>`) within the `<div>` created by `htmlwidgets`, we could empty this element before creating every visualisation, thereby removing any previously created visualisations (if there are any). We can do this using the `innerHTML` method already used in this book.

```js
// gio.js
var container = document.getElementById(el.id);
container.innerHTML = ''; // empty
controller = new GIO.Controller(container);
...
```

1. In R, Create a proxy of the visualisation
2. Send data to the client from R
3. In JavaScript, get the visualisation
4. Apply data to visualisation
