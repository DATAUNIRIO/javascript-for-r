# Working with Shiny

A previous set of chapters explored how to make JavaScript and R communicate by passing data from one to the other and back. This chapter explores how to apply that to htmlwidgets so one can dynamically interact with the rendered widget by sending it more data and capture server-side how the user interact with the widget.

To demonstrate how to integrate these functionalities in widgets we shall implement them in the previously built gio package.

## Callback {-}

Wouldn't it be grand if one were able to pick up server-side which country is selected by the user! This could enable fetching data on the selected country from a database or display the flag of the selected country in the application's UI, or both, or do many other things. With regard to the implementation itself little if anything changes from previous examples used in the collection of chapters on Shiny.

The [documentation of gio.js](https://giojs.org/html/docs/callbackPicked.html) shows the library features the possibility to pass a callback function that is run every time a country is selected, the example given is below.

```js
controller.onCountryPicked( callback );

function callback (selectedCountry, relatedCountries) {

  console.log(selectedCountry);
  console.log(relatedCountries);

}
```

This can be adapted as previously demonstrated and used in our widget as shown below.

```js
...
renderValue: function(x) {

  var container = document.getElementById(el.id);
  var controller = new GIO.Controller(container);
  controller.addData(x.data);
  controller.setStyle(x.style);

  // callback
  controller.onCountryPicked( callback );

  function callback (selectedCountry, relatedCountries) {
    Shiny.setInputValue(el.id + '_selected', selectedCountry);
    Shiny.setInputValue(el.id + '_related', relatedCountries);
  }

  // render
  controller.init();

}
...
```

This will set the input named `id_selected` and `id_related` with data on the selected country and data on countries connected to it respectively. Install the package with `devtools::install` and use those inputs in a shiny application.

```r
library(gio)
library(shiny)

arcs <- data.frame(
  e = c("US", "CN", "RU"),
  i = c("CN", "RU", "US"),
  v = c(100, 120, 130)
)

ui <- fluidRow(
  gioOutput("globe"),
  fluidRow(
    column(6, verbatimTextOutput("selectedCountry")),
    column(6, verbatimTextOutput("relatedCountries"))
  )
)

server <- function(input, output){

  output$globe <- renderGio({
    gio(arcs)
  })

  output$selectedCountry <- renderPrint({
    print(input$globe_selected)
  })

  output$relatedCountries <- renderPrint({
    print(input$globe_related)
  })

}

shinyApp(ui, server)
```

The data is sent from the client to the server whether the user uses the input or not, though this likely will not negatively impact gio it can reduce performances if the callback function is triggered too frequently. For instance setting an input value when the user hovers a scatter plot might lead to the event being fired very frequently and too much data being sent to the server, slowing things down and providing a poor experience.

Therefore one might consider making the capture of such event optional so the web browser is not strained unless explicitly required. You can also consider not sending back all the data. For instance, gio returns the coordinates of the selected country where from arc connect; this is might be considered unnecessary. The code below only sets the input to the ISO code of the country selected.

```js
function callback (selectedCountry, relatedCountries) {
  Shiny.setInputValue(el.id + '_selected', selectedCountry.ISOCode);
}
```

## Input Handler {-}

While input handlers were explored previously we found limited use for them as the input were set to simple boolean values. It can be useful in this case as the inputs return more data which could do with some preprocessing. Namely the input returning data on the related countries, it is deserialised to a list but could be reshaped to a data frame of arcs.

Below we create a handler that is going to loop over the list and return a data frame.

```r
# R/zzz.R
related_countries_handler <- function(x, session, inputname){
  purrr::map_dfr(x, as.data.frame)
}
```

Then we register the handler when the package is loaded.

```r
# R/zzz.R
related_countries_handler <- function(x, session, inputname){
  purrr::map_dfr(x, as.data.frame)
}

.onLoad <- function(libname, pkgname) {
  shiny::registerInputHandler("gio.related.countries", related_countries_handler)
}
```

Finally, we can reinstall the package with `devtools::install` and create shiny application to observe the change. Below we use a large example dataset and, since the input now returns a data frame, we can display the input value in a table.

```r
library(DT)
library(gio)
library(shiny)

# large sample data
url <- paste0(
  "https://raw.githubusercontent.com/syt123450/",
  "giojs/master/examples/data/sampleData.json"
)
arcs <- jsonlite::fromJSON(url)

ui <- fluidRow(
  gioOutput("globe"),
  DTOutput("relatedCountries")
)

server <- function(input, output){

  output$globe <- renderGio({
    gio(arcs)
  })

  output$relatedCountries <- renderDT({
    datatable(input$globe_related)
  })

}

shinyApp(ui, server)
```

![Input transformed to data frame](images/gio-input-handler.png)

## R to JavaScript {-}

This book previously explored how to send data to the from the shiny server to the front-end, this section looks to apply this to htmlwidgets. Currently, gio in shiny consists of generating the globe with the `renderGio` and complimentary `gioOutput` functions. This generates the entire visualisation, it creates the globe, draws the arcs based on the data, sets the style, everything. 

Now imagine a scenario where we provide a `selectInput` to the user so they can choose between two datasets to visualise. First, there is no need to re-generate the entire visualisation, only the data changes, the style, background globe, and everything else can remain unchanged. This is more efficient computationally, both for the server and the client, and makes for much cleaner transitions and animations. Secondly, running `renderGio` currently does not work properly, gio.js does not replace the initigeneral visualisation but instead creates a new one below. This is admittedly somewhat particular to the gio.js functions and will likely not be the case with other libraries. The problem described can be observed running the application below: multiple visualisations are generated.

```r
library(gio)
library(shiny)

arcs1 <- data.frame(
  e = c("US", "CN", "RU"),
  i = c("CN", "RU", "US"),
  v = c(100, 120, 130)
)

arcs2 <- data.frame(
  e = c("CN", "CN", "JP"),
  i = c("IN", "JP", "US"),
  v = c(100, 120, 130)
)

ui <- fluidRow(
  selectInput(
    "dataset", 
    "Select a dataset", 
    choices = c("First", "Second")
  ),
  gioOutput("globe")
)

server <- function(input, output){

  reactive_arcs <- reactive({
    if(input$dataset == "First") 
      return(arcs1)
    return(arcs2)
  })

  output$globe <- renderGio({
    gio(reactive_arcs())
  })

}

shinyApp(ui, server)
```

Internally gio.js creates a new element (`<canvas>`) within the `<div>` created by `htmlwidgets`, we could empty this element before creating every visualisation, thereby removing any previously created visualisations (if there are any). We can do this using the `innerHTML` method already used in this book.

```js
// gio.js
var container = document.getElementById(el.id);
container.innerHTML = ''; // empty
controller = new GIO.Controller(container);
...
```

1. In R, Create a proxy of the visualisation
2. Send data to the client from R
3. In JavaScript, get the visualisation
4. Apply data to visualisation
