# A Realistic Widget

In this section we build a package called `peity` which wraps the JavaScript library of the same name, [peity.js](https://github.com/benpickles/peity) to create inline charts. This builds upon many things we explored in the playground package built in the previous chapter.

```r
usethis::create_package("peity")
htmlwidgets::scaffoldWidget("peity")
```

As done with candidate libraries, let's take a look at documentation of peity.js to see how it works.

```html
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
  <!-- Import libraries -->
  <script src="jquery-3.5.1.min.js"></script>
  <script src="jquery.peity.min.js"></script>
</head>

<body>
  <!-- div to hold visualisation -->
  <span id="bar">5,3,9,6,5,9,7,3,5,2</span>

  <!-- Script to create visualisation -->
  <script>
    $("#bar").peity("bar");
  </script>
</body>

</html>
```

Peity.js depends on jQuery, hence the latter is imported first, the data for the chart is placed in a `<span>`, and the `peity` method is then used on the element containing the data. Peity.js uses `<span>` HTML tags as these work inline, using a `<div>` the chart will still display but the purpose of using peity.js would be defeated.

## Peity.js Dependencies 

Once the package created and the widget scaffold laid down we need to add the JavaScript dependencies without which nothing can move forward.

Two dependencies are required in order for peity.js to run: peity.js and jQuery, instead of using the CDN those are downloaded as this ultimately makes the package more robust (more easily reproducible outputs and no requirement for internet connection). Each of the two library is placed in its own respective directory.

```r
dir.create("./inst/htmlwidgets/jquery", recursive = TRUE)
dir.create("./inst/htmlwidgets/typed")

peity <- paste0(
  "https://raw.githubusercontent.com/benpickles/",
  "peity/master/jquery.peity.min.js"
)
jquery <- paste0(
  "https://code.jquery.com/jquery-3.5.1.min.js"
)

download.file(jquery, "./inst/htmlwidgets/jquery/jquery.min.js")
download.file(peity, "./inst/htmlwidgets/peity/jquery.peity.min.js")
```

This produces a directory that looks like this:

```
.
├── DESCRIPTION
├── NAMESPACE
├── R
│   └── peity.R
└── inst
    └── htmlwidgets
        ├── jquery
        │   └── jquery.min.js
        ├── peity.js
        ├── peity.yaml
        └── peity
            └── jquery.peity.min.js
```

In htmlwidgets dependencies are specified in the `.yml` file located at `inst/htmlwidgets` which at first contains a commented template.

```yml
# (uncomment to add a dependency)
# dependencies:
#  - name:
#    version:
#    src:
#    script:
#    stylesheet:
```

Let's uncomment those lines as instructed at the top of the file and fill it in. 

```yml
dependencies:
  - name: jQuery
    version: 3.5.1
    src: htmlwidgets/jquery
    script: jquery.min.js
  - name: peity
    version: 3.3.0
    src: htmlwidgets/peity
    script: jquery.peity.min.js
```

```{block, type='rmdnote'}
The order of the dependencies matters, peity.js depends on jQuery hence the latter comes first in the `.yml`.
```

The order in which one specifies the dependencies matters, just like it does in an HTML file, therefore jQuery is listed first. The `stylesheet` entries were removed as none of these libraries require CSS files. The `src` path points to the directory containing the JavaScript files and stylesheets relative to the `inst` directory of the package, this is akin to using the `system.file` function to return the full path to a file or directory within the package.

```r
devtools::load_all()
system.file("htmlwidgets/peity", package = "peity")                                         
#> "/home/me/packages/peity/inst/htmlwidgets/peity"
```

We should verify that this is correct by using the one R function the package features and check the source code of the output to verify that the the dependencies are well present in the HTML output. We thus run `peity("test")`, open the output in the browser (![](images/open-in-browser.png)) and look at the source code of the page. At the top of the page one should see `jquery.min.js` and `jquery.peity.min.js` imported, clicking those links will either present you with the content of the file or an error.

```html
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>body{background-color:white;}</style>
<script src="lib/htmlwidgets-1.5.1/htmlwidgets.js"></script>
<script src="lib/jQuery-3.5.1/jquery.min.js"></script>
<script src="lib/peity-3.3.0/jquery.peity.min.js"></script>
<script src="lib/peity-binding-0.0.0.9000/peity.js"></script>
...
```

## Peity.js Implementation

Peity.js' JavaScript code is rather uncomplicated, it's just one function, but integrating it with htmlwidgets requires some thinking. In the example below, peity is applied to the element with `id = 'elementId'`, the first argument of `peity` is the type of chart to produce form the data and the second optional argument is a JSON of options.

```js
$("#elementId").peity("bar", {
  fill: ["red", "green", "blue"]
})
```

Also, the data that peity uses to draw the inline chart is not passed to the function but taken from the HTML element.

```html
<span id="elementId">5,3,9,6</span>
```

Therefore, the htmlwidget will have to insert the data in the HTML element then run the `peity` function to render the chart. inserting the data is not easy as much as already done by htmlwidgets by default. Indeed the default htmlwidgets template takes a `message` from the R function and inserts said message in the HTML element, passing a vector instead of a message produces precisely what peity expects!

```r
peity(c(1,5,6,2))
```

```html
<div 
  id="htmlwidget-495cf47d1a2a4a56c851" 
  style="width:960px;height:500px;" 
  class="play html-widget">
  1,5,6,2
</div>
```

The argument ought to be renamed nonetheless from `message` to `data`.

```r
peity <- function(data, width = NULL, height = NULL, 
  elementId = NULL) {

  # forward options using x
  x = list(
    data = data
  )

  # create widget
  htmlwidgets::createWidget(
    name = 'peity',
    x,
    width = width,
    height = height,
    package = 'peity',
    elementId = elementId
  )
}
```

The change in the R code must be mirrored in the `peity.js` file where it should set the `innerText` to `x.data` instead of `x.message`. 

```js
// peity.js
// el.innerText = x.message;
el.innerText = x.data;
```

This leaves the implementation of peity.js to turn the data into an actual chart. The way we shall go about it is to paste one of the examples in the `renderValue` function.

```js
renderValue: function(x) {

  // insert data
  el.innerText = x.data;

  // run peity
  $("#elementId").peity("bar", {
    fill: ["red", "green", "blue"]
  })

}
```

One could be tempted to run `devtools::load_all` but this will not work, namely because the function uses a selector that is will not return any object; it needs to be applied to the div created by the widget not `#elementId`. As explained in the previous chapter, the selector of the element created is accessible from the `el` object. As a matter of fact, we did log in the browser console the id of the created div taken from `el.id`. Therefore concatenating the pound sign and the element id produces the select to said element (`.class`, `#id`).

```js
$("#" + el.id).peity("bar", {
  fill: ["red", "green", "blue"]
})
```

This will work but can be further simplified, there is no need to recreate a selector using the `id` of the `el` element, the latter can be used in the jQuery selector directly.

```js
$(el).peity("bar", {
  fill: ["red", "green", "blue"]
})
```

This will now produce a working widget, albeit limited to creating charts of a predefined type and color. Next these options defining the chart type, fill colors and others must be made available from R.

Below we add a `type` argument to the `peity` function, this `type` argument is then forwarded to `x` so it is serialised and accessible in the JavaScript file.

```r
peity <- function(data, type = c("bar", "line", "pie", "donut"), 
  width = NULL, height = NULL, elementId = NULL) {

  type <- match.arg(type)

  # forward options using x
  x = list(
    data = data,
    type = type
  )

  # create widget
  htmlwidgets::createWidget(
    name = 'peity',
    x,
    width = width,
    height = height,
    package = 'peity',
    elementId = elementId
  )
}
```

This should then be applied by replacing the hard-coded type (`"bar"`) to `x.type`.

```js
$(el).peity(x.type, {
  fill: ["red", "green", "blue"]
})
```

Reloading the package will now let one create a chart and define its type but some options remain hard-coded. These can be made available from R in a variety of ways depending on the interface one wants to provide users of the package. Here we simply make them available via the three-dot construct (`...`) which are captured in a list and forwarded to the `x` object.

```r
peity <- function(data, type = c("bar", "line", "pie", "donut"), ...,
  width = NULL, height = NULL, elementId = NULL) {

  type <- match.arg(type)

  # forward options using x
  x = list(
    data = data,
    type = type,
    options = list(...)
  )

  # create widget
  htmlwidgets::createWidget(
    name = 'peity',
    x,
    width = width,
    height = height,
    package = 'peity',
    elementId = elementId
  )
}
```

These can then be easily accessed from JavaScript.

```js
$(el).peity(x.type, x.options)
```

This makes (nearly) all of the functionalities of peity.js available from R. Below we use `htmltools::browsable` to create multiple widgets at once, the function only accepts a single value so the charts are wrapped in an `htmltools::tagList`.

```r
htmltools::browsable(
  htmltools::tagList(
    peity(runif(5)),
    peity(runif(5), type = "line"),
    peity("1/4", type = "pie", fill = c("#c6d9fd", "#4d89f9")),
    peity(c(3,5), type = "donut")
  )
)
```

```{r, echo = FALSE}
htmltools::browsable(
  htmltools::tagList(
    peity(runif(5)),
    htmltools::br(),
    peity(runif(5), type = "line"),
    htmltools::br(),
    peity("1/4", type = "pie", fill = c("#c6d9fd", "#4d89f9")),
    htmltools::br(),
    peity(c(3,5), type = "donut")
  )
)
```

There is nonetheless one remaining issue: peity.js is meant to create inline charts within `<span>` HTML tags but these are created within `<div>` hence each chart appears on a new line. 

## Peity.js HTML Element 

As pointed out multiple times, the widget is generated in a `<div>`, which is works fine for most visualisation libraries. But we saw that chart.js requires placing it in a `<canvas>`, so one needs the ability to change that. It could be interesting to apply this to typed.js too as within a `<div>` it cannot be placed inline, using a `<span>`, however, this would work.

This can be changed by placing a function named `nameOfWidget_html` which looked up by htmlwidgets and used if found. This function takes the three-dot construct `...` and uses them in an htmltools tag. The three-dots are necessary because internally htmlwidgets needs be able to pass arguments, such as the all too critical `id`.

```r
typed_html <- function(...){
  htmltools::tags$span(...)
}
```

Note that this can also be used to force certain attributes onto the element. For instance we could use the code below to force all output to use a red font.

```r
typed_html <- function(...){
  htmltools::tags$span(..., style = "color:red;")
}
```

We shall leave it at that and move on to building another widget but completing the package makes for an interesting exercise.
