# A Realistic Widget

In this section we build a package called `peity` which wraps the JavaScript library of the same name, [peity.js](https://github.com/benpickles/peity) to create inline charts. This builds upon many things we explored in the playground package built in the previous chapter.

```r
usethis::create_package("peity")
htmlwidgets::scaffoldWidget("peity")
```

As done with candidate libraries, let's take a look at documentation of peity.js to see how it works.

```html
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
  <!-- Import libraries -->
  <script src="jquery-3.5.1.min.js"></script>
  <script src="jquery.peity.min.js"></script>
</head>

<body>
  <!-- div to hold visualisation -->
  <span id="bar">5,3,9,6,5,9,7,3,5,2</span>

  <!-- Script to create visualisation -->
  <script>
    $("#bar").peity("bar");
  </script>
</body>

</html>
```

Peity.js depends on jQuery, hence the latter is imported first, the data for the chart is placed in a `<span>`, and the `peity` method is then used on the element containing the data. Peity.js uses `<span>` HTML tags as these work inline, using a `<div>` the chart will still display but the purpose of using peity.js would be defeated.

## Peity.js Dependencies 

Once the package created and the widget scaffold laid down we need to add the JavaScript dependencies without which nothing can move forward.

Two dependencies are required in order for peity.js to run: peity.js and jQuery, instead of using the CDN those are downloaded as this ultimately makes the package more robust (more easily reproducible outputs and no requirement for internet connection). Each of the two library is placed in its own respective directory.

```r
dir.create("./inst/htmlwidgets/jquery", recursive = TRUE)
dir.create("./inst/htmlwidgets/typed")

peity <- paste0(
  "https://raw.githubusercontent.com/benpickles/",
  "peity/master/jquery.peity.min.js"
)
jquery <- paste0(
  "https://code.jquery.com/jquery-3.5.1.min.js"
)

download.file(jquery, "./inst/htmlwidgets/jquery/jquery.min.js")
download.file(peity, "./inst/htmlwidgets/peity/jquery.peity.min.js")
```

This produces a directory that looks like this:

```
.
├── DESCRIPTION
├── NAMESPACE
├── R
│   └── peity.R
└── inst
    └── htmlwidgets
        ├── jquery
        │   └── jquery.min.js
        ├── peity.js
        ├── peity.yaml
        └── peity
            └── jquery.peity.min.js
```

In htmlwidgets dependencies are specified in the `.yml` file located at `inst/htmlwidgets` which at first contains a commented template.

```yml
# (uncomment to add a dependency)
# dependencies:
#  - name:
#    version:
#    src:
#    script:
#    stylesheet:
```

Let's uncomment those lines as instructed at the top of the file and fill it in. 

```yml
dependencies:
  - name: jQuery
    version: 3.5.1
    src: htmlwidgets/jquery
    script: jquery.min.js
  - name: peity
    version: 3.3.0
    src: htmlwidgets/peity
    script: jquery.peity.min.js
```

```{block, type='rmdnote'}
The order of the dependencies matters, peity.js depends on jQuery hence the latter comes first in the `.yml`.
```

The order in which one specifies the dependencies matters, just like it does in an HTML file, therefore jQuery is listed first. The `stylesheet` entries were removed as none of these libraries require CSS files. The `src` path points to the directory containing the JavaScript files and stylesheets relative to the `inst` directory of the package, this is akin to using the `system.file` function to return the full path to a file or directory within the package.

```r
devtools::load_all()
system.file("htmlwidgets/peity", package = "peity")                                         
#> "/home/me/packages/peity/inst/htmlwidgets/peity"
```

We should verify that this is correct by using the one R function the package features and check the source code of the output to verify that the the dependencies are well present in the HTML output. We thus run `peity("test")`, open the output in the browser (![](images/open-in-browser.png)) and look at the source code of the page. At the top of the page one should see `jquery.min.js` and `jquery.peity.min.js` imported, clicking those links will either present you with the content of the file or an error.

```html
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>body{background-color:white;}</style>
<script src="lib/htmlwidgets-1.5.1/htmlwidgets.js"></script>
<script src="lib/jQuery-3.5.1/jquery.min.js"></script>
<script src="lib/peity-3.3.0/jquery.peity.min.js"></script>
<script src="lib/peity-binding-0.0.0.9000/peity.js"></script>
...
```

## Peity.js JavaScript Code 

Peity.js' JavaScript code is rather uncomplicated, it's just one function, but integrating it with htmlwidgets requires some thinking. In the example below, peity is applied to the element with `id = 'elementId'`, the first argument of `peity` is the type of chart to produce form the data and the second optional argument is a JSON of options.

```js
$("#elementId").peity("bar", {
  fill: ["red", "green", "blue"]
})
```

Also, the data that peity uses to draw the inline chart is not passed to the function but taken from the HTML element.

```html
<span id="elementId">5,3,9,6</span>
```

Therefore, the htmlwidget will have to insert the data in the HTML element then run the `peity` function to render the chart. inserting the data is not easy as much as already done by htmlwidgets by default. Indeed the default htmlwidgets template takes a `message` from the R function and inserts said message in the HTML element, passing a vector instead of a message produces precisely what peity expects!

```r
peity(c(1,5,6,2))
```

```html
<div 
  id="htmlwidget-495cf47d1a2a4a56c851" 
  style="width:960px;height:500px;" 
  class="play html-widget">
  1,5,6,2
</div>
```



## Peity.js HTML Element 

As pointed out multiple times, the widget is generated in a `<div>`, which is works fine for most visualisation libraries. But we saw that chart.js requires placing it in a `<canvas>`, so one needs the ability to change that. It could be interesting to apply this to typed.js too as within a `<div>` it cannot be placed inline, using a `<span>`, however, this would work.

This can be changed by placing a function named `nameOfWidget_html` which looked up by htmlwidgets and used if found. This function takes the three-dot construct `...` and uses them in an htmltools tag. The three-dots are necessary because internally htmlwidgets needs be able to pass arguments, such as the all too critical `id`.

```r
typed_html <- function(...){
  htmltools::tags$span(...)
}
```

Note that this can also be used to force certain attributes onto the element. For instance we could use the code below to force all output to use a red font.

```r
typed_html <- function(...){
  htmltools::tags$span(..., style = "color:red;")
}
```

We shall leave it at that and move on to building another widget but completing the package makes for an interesting exercise.
