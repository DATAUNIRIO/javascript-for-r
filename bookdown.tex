% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames*,x11names*}{xcolor}
%
\documentclass[
]{krantz}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={JavaScript for R},
  pdfauthor={John Coene},
  colorlinks=true,
  linkcolor=Maroon,
  filecolor=Maroon,
  citecolor=Blue,
  urlcolor=Blue,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.33,0.33,0.33}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.61,0.61,0.61}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.06,0.06,0.06}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.27,0.27,0.27}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.27,0.27,0.27}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.06,0.06,0.06}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.14,0.14,0.14}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.06,0.06,0.06}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.27,0.27,0.27}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.43,0.43,0.43}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage[bf,singlelinecheck=off]{caption}

\usepackage{framed,color}
\definecolor{shadecolor}{RGB}{248,248,248}

\renewcommand{\textfraction}{0.05}
\renewcommand{\topfraction}{0.8}
\renewcommand{\bottomfraction}{0.8}
\renewcommand{\floatpagefraction}{0.75}

\renewenvironment{quote}{\begin{VF}}{\end{VF}}
\let\oldhref\href
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}

\makeatletter
\newenvironment{kframe}{%
\medskip{}
\setlength{\fboxsep}{.8em}
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\renewenvironment{Shaded}{\begin{kframe}}{\end{kframe}}

\usepackage{makeidx}
\makeindex

\urlstyle{tt}

\usepackage{amsthm}
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=8pt plus 2pt minus 4pt
  \thm@postskip=\thm@preskip
}
\makeatother

\frontmatter
\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{JavaScript for R}
\author{John Coene}
\date{2020-06-03}

\begin{document}
\maketitle

% you may need to leave a few empty pages before the dedication page

%\cleardoublepage\newpage\thispagestyle{empty}\null
%\cleardoublepage\newpage\thispagestyle{empty}\null
%\cleardoublepage\newpage
\thispagestyle{empty}

\begin{center}
To my son,

without whom I should have finished this book two years earlier
%\includegraphics{images/dedication.pdf}
\end{center}

\setlength{\abovedisplayskip}{-5pt}
\setlength{\abovedisplayshortskip}{-5pt}

{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}
\listoftables
\listoffigures
\hypertarget{preface}{%
\chapter*{Preface}\label{preface}}


The R programming language has seen the integration of many programming languages; C, C++, Python, to name a few, can be seamlessly embedded into R so one can easily call code written in other languages from the R console. Little known to many, R works just as well with JavaScript---this book delves into the various ways both languages can work together.

The ultimate aim of this work is to put the reader at ease with inviting JavaScript in their data science workflow. In that respect the book is not teaching one JavaScript but rather we show how little JavaScript can greatly support and enhance R code. Therefore focus is on integrating external JavaScript libraries and no prior knowledge of JavaScript is required.

\hypertarget{disclaimer}{%
\section*{Disclaimer}\label{disclaimer}}


This book is currently a work in progress.

\mainmatter

\hypertarget{part-basics-roadmap}{%
\part{Basics \& Roadmap}\label{part-basics-roadmap}}

\hypertarget{introduction}{%
\chapter{Introduction}\label{introduction}}

In this chapter, after briefly going through prerequisites, we provide a rationale for integrating JavaScript with R which we support with examples, namely packages already available on CRAN. Then, we list the various ways in which one might go about making both languages work together. Finally, we end with a review of concepts fundamental to fully understand the more advanced topics residing in the forthcoming chapters.

\hypertarget{rationale}{%
\section*{Rationale}\label{rationale}}


Why merge JavaScript and R? They are two fundamentally different languages that each have their strengths and weaknesses, combining the two allows making the most of their consolidated advantages and circumvent their respective limitations to produce software altogether better for it.

A fair reason to use JavaScript might simply be that the thing one wants to achieve in R has already been realised in JavaScript. Why reinvent the wheel when the solution already exists and that it can be made accessible from R? The R package \href{https://github.com/ropensci/lawn}{lawn} \citep{R-lawn} by Ropensci integrates \href{http://turfjs.org/}{turf.js}, a brilliant library for geo-spatial analysis. JavaScript is not required to make those computations, it could be rewritten solely in R but that would be vastly more laborious than wrapping the JavaScript API in R.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(lawn)}

\KeywordTok{lawn\_count}\NormalTok{(lawn\_data}\OperatorTok{$}\NormalTok{polygons\_count, lawn\_data}\OperatorTok{$}\NormalTok{points\_count, }\StringTok{"population"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## <FeatureCollection>
##   Bounding box: -112.1 46.6 -112.0 46.6
##   No. features: 2
##   No. points: 20
##   Properties: 
##     values count
## 1 200, 600     2
## 2              0
\end{verbatim}

Another great reason is that JavaScript can do things that R cannot, e.g.: run in the browser. Therefore one cannot natively create interactive visualisations with R. \href{https://plotly-r.com/}{Plotly} \citep{R-plotly} by Carson Sievert packages the \href{https://plot.ly/}{plotly JavaScript library} to let one create interactive visualisations solely from R code.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(plotly)}

\KeywordTok{plot\_ly}\NormalTok{(diamonds, }\DataTypeTok{x =} \OperatorTok{\textasciitilde{}}\NormalTok{cut, }\DataTypeTok{color =} \OperatorTok{\textasciitilde{}}\NormalTok{clarity)}
\end{Highlighting}
\end{Shaded}

\includegraphics{bookdown_files/figure-latex/unnamed-chunk-2-1.png}

Finally, JavaScript can work together with R to improve how we communicate insights. One of the many ways in which Shiny stands out is that it lets one create web applications solely from R code with no knowledge of HTML, CSS, or JavaScript but that does not mean they can't extend Shiny, quite the contrary. The \href{http://waiter.john-coene.com/}{waiter package} \citep{R-waiter} integrates a variety of JavaScript libraries to display loading screens in Shiny applications.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\KeywordTok{library}\NormalTok{(waiter)}

\NormalTok{ui <{-}}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \KeywordTok{use\_waiter}\NormalTok{(), }\CommentTok{\# include dependencies}
  \KeywordTok{actionButton}\NormalTok{(}\StringTok{"show"}\NormalTok{, }\StringTok{"Show loading for 3 seconds"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session)\{}
  \CommentTok{\# create a waiter}
\NormalTok{  w <{-}}\StringTok{ }\NormalTok{Waiter}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}

  \CommentTok{\# on button click}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{show, \{}
\NormalTok{    w}\OperatorTok{$}\KeywordTok{show}\NormalTok{()}
    \KeywordTok{Sys.sleep}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\NormalTok{    w}\OperatorTok{$}\KeywordTok{hide}\NormalTok{()}
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{flushleft}\includegraphics[width=6.25in]{images/waiter} \end{flushleft}

Hopefully this makes a couple of great reasons and alluring examples to entice you to persevere with this book.

\hypertarget{prerequisites}{%
\section*{Prerequisites}\label{prerequisites}}


The code contained in the following pages is approachable to readers with basic knowledge of R, although familiarity with package development using \href{https://devtools.r-lib.org/}{devtools} \citep{R-devtools}, as well as the \href{https://shiny.rstudio.com/}{Shiny} \citep{R-shiny} framework is helpful. The reason for the former is that some of the ways one builds integrations with JavaScript naturally take the form of R packages. The following section thus runs over the essentials of building a package to ensure everyone can keep up. As both Shiny and JavaScript run in the browser they make for axiomatic companions; we'll therefore use Shiny extensively.

Only basic knowledge of JavaScript is required to understand and learn from the book as not only is JavaScript rather uncomplicated and its syntax similar to R's in places, we write surprisingly little of it. Understanding of JSON and HTML, however, is essential. In essence, if one has already used external JavaScript libraries in HTML or R markdown documents then one is well-equipped to tackle this book but in the event that you have not, we will go through a quick review of the basics of both JavaScript and JSON.

It is highly recommended to use the freely available \href{https://rstudio.com/products/rstudio/}{RStudio IDE} to follow along, particularly if you are beginner in R.

\hypertarget{package-development}{%
\subsection*{Package Development}\label{package-development}}


Developing packages used to be notoriously difficult but things have greatly changed, namely thanks to the devtools and more recent \href{https://usethis.r-lib.org/}{usethis} \citep{R-usethis} packages. The first is specifically designed to help creating packages; setting up tests, running checks, building and installing packages, etc. The second, usethis, more broadly helps setting up projects, and automating repetitive tasks. Here, we only skim over the fundamentals, there is an entire book by Hadley Wickham called \href{http://r-pkgs.had.co.nz/}{R Packages} solely dedicated to the topic.

Start by installing the two packages from CRAN.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"devtools"}\NormalTok{, }\StringTok{"usethis"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

We'll create an admittedly ridiculous package to explain how it works. Despite being useless, this package will introduce certain concepts of package development that are essential to understand for what is following. The package will be named ``test'' and will provide a single function that will print a JavaScript file stored inside our package. Useless but bear with it.

Let's create the package, either do so using the RStudio IDE or with usethis. From the RStudio IDE go to \texttt{File\ \textgreater{}\ New\ Project\ \textgreater{}\ New\ Directory} then select ``R package'' and fill in the small form. But it could be argued that it's actually easier with usethis; type the code below in your R console to create a package named ``test'' in your current directory. If you run it from RStudio a new project window should open.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{usethis}\OperatorTok{::}\KeywordTok{create\_package}\NormalTok{(}\StringTok{"test"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This creates an empty package called ``test''. Let's add the JavaScript file that the yet-to-be-written R function will eventually print out. R packages must follow strict rules, this file cannot be placed anywhere we want; it must be stored in a directory called \texttt{inst} which stands for ``installation;'' these are files that will simply be copied to the users' machine when they install your package. Create the \texttt{inst} directory in the root of the package (e.g.: next to the already existing \texttt{R}) and place a file called \texttt{javascript.js} within it.

Let's create the following, extremely simple JavaScript file that contains code which declares a variable named \texttt{x}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// inst/javascript.js}
\KeywordTok{var}\NormalTok{ x }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This can all be done from the R console as shown below.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{dir.create}\NormalTok{(}\StringTok{"inst"}\NormalTok{) }\CommentTok{\# create directory}
\KeywordTok{writeLines}\NormalTok{(}\StringTok{"var x = 3;"}\NormalTok{, }\DataTypeTok{con =} \StringTok{"inst/javascript.js"}\NormalTok{) }\CommentTok{\# create file}
\end{Highlighting}
\end{Shaded}

This should produce a directory looking something like:

\begin{verbatim}
DESCRIPTION
NAMESPACE
R/
inst/
|-- javascript.js
\end{verbatim}

Onto creating the R function that will read and print this file. Then again, R is strict, R files must be placed in the \texttt{R} directory. Then again, this can be done from the console or the RStudio IDE.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# create the file from the R console}
\KeywordTok{file.create}\NormalTok{(}\StringTok{"R/function.R"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In the \texttt{function.R} file we just created we place a function that reads the \texttt{javascript.js} file and prints it to the R console. In order to read the file one needs to locate it, as packages are destined to be shared and installed on different machines one can never use absolute paths, where the \texttt{javascript.js} file is located will depend on where the user has installed the package: as the developer you can never know that for sure. Therefore R comes with a \texttt{system.file} function which will look for a file \emph{relative to a package \texttt{inst} directory} and return its full path.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# R/function.R}
\NormalTok{print\_file <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{()\{}
  \CommentTok{\# look for javascript.js in the inst folder of the test package}
\NormalTok{  file <{-}}\StringTok{ }\KeywordTok{system.file}\NormalTok{(}\StringTok{"javascript.js"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"test"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

With the file path one can read the contents of the \texttt{file} and print it.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{print\_file <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{()\{}
\NormalTok{  file <{-}}\StringTok{ }\KeywordTok{system.file}\NormalTok{(}\StringTok{"javascript.js"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"test"}\NormalTok{)}
\NormalTok{  content <{-}}\StringTok{ }\KeywordTok{readLines}\NormalTok{(file)}
  \KeywordTok{print}\NormalTok{(content)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Let's add a pretty message, using the \href{https://cli.r-lib.org/}{cli} \citep{R-cli} package, before we print the file as it allows introducing another concept; using external libraries in our package. To use cli we can run:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# install.packages("cli")}
\NormalTok{usethis}\OperatorTok{::}\KeywordTok{use\_package}\NormalTok{(}\StringTok{"cli"}\NormalTok{)}
\CommentTok{\#\# ✔ Adding \textquotesingle{}cli\textquotesingle{} to Imports field in DESCRIPTION}
\CommentTok{\#\# ● Refer to functions with \textasciigrave{}cli::fun()\textasciigrave{}}
\end{Highlighting}
\end{Shaded}

It does exactly what it printed. The \texttt{DESCRIPTION} file includes information about the package and, very importantly, dependencies. The package we are creating will depend on the cli package; the \texttt{DESCRIPTION} file essentially tells R to check whether it is installed on the machine, if not it installs it (packages are for sharing). You should now see the following entry in the \texttt{DESCRIPTION} file.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Imports}\OperatorTok{:}\StringTok{ }
\StringTok{    }\NormalTok{cli}
\end{Highlighting}
\end{Shaded}

We can add cli to our function, note that we use the namespace (or package name) followed by a double colon, as was printed by the \texttt{usethis::use\_package} function we ran earlier.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{print\_file <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{()\{}
\NormalTok{  file <{-}}\StringTok{ }\KeywordTok{system.file}\NormalTok{(}\StringTok{"javascript.js"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"test"}\NormalTok{)}
\NormalTok{  cli}\OperatorTok{::}\KeywordTok{cli\_alert\_info}\NormalTok{(}\StringTok{"JavaScript code below."}\NormalTok{)}
\NormalTok{  content <{-}}\StringTok{ }\KeywordTok{readLines}\NormalTok{(file)}
  \KeywordTok{print}\NormalTok{(content)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

It's not done just yet. Let's demonstrate why: it allows introducing devtools. We can install the ``test'' package we created with \texttt{devtools::install()}, afterwards we can expect to be able to run the \texttt{print\_file} function we wrote but it returns the following error: \texttt{could\ not\ find\ function\ "print\_file"}. Odd. This is because we have not explicitly ``exported'' the function, by default functions and objects declared in \texttt{.R} files (in packages) can only be used internally (within the package itself). In order to export it we need another package called roxygen2 \citep{R-roxygen2}, it allows writing the documentation in the \texttt{.R} file rather than have to create separate file, a lifesaver. Note that roxygen2 should already be installed on your machine. Using said documentation we can specify which function should be exported with a ``tag''.

Tags are preceded by \texttt{\#\textquotesingle{}\ @}, there are plenty of them, we don't explore any other here.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{print\_file <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{()\{}
\NormalTok{  file <{-}}\StringTok{ }\KeywordTok{system.file}\NormalTok{(}\StringTok{"javascript.js"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"test"}\NormalTok{)}
\NormalTok{  cli}\OperatorTok{::}\KeywordTok{cli\_alert\_info}\NormalTok{(}\StringTok{"JavaScript code below."}\NormalTok{)}
\NormalTok{  content <{-}}\StringTok{ }\KeywordTok{readLines}\NormalTok{(file)}
  \KeywordTok{print}\NormalTok{(content)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now one can run \texttt{devtools::document()} to document the package based on the tag we added: this exports the function. Then we can run \texttt{devtools::install()} to build and install the package.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{test}\OperatorTok{::}\KeywordTok{print\_file}\NormalTok{()}
\CommentTok{\#\# ℹ JavaScript code below.}
\CommentTok{\#\# [1] "var x = 3;"}
\end{Highlighting}
\end{Shaded}

Finally, the cyclical nature of building packages substitute \texttt{devtools::install()} with \texttt{devtools::load\_all()}, the latter does not install the package and simply loads all the functions and objects of the package in the environment, this is much faster than installing it.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write some code
\item
  Run \texttt{devtools::document()}
\item
  Run \texttt{devtools::load\_all()}
\item
  Repeat
\end{enumerate}

Note the package we built is good enough for your own machine but won't pass CRAN checks as we miss a lot of the documentation (roxygen2 tags).

\hypertarget{json}{%
\subsection*{JSON}\label{json}}


JSON (JavaScript Object Notation) is a very popular data \emph{interchange} format with which we will work extensively throughout this book, it is thus crucial that we have a good understanding of it before we plunge into the nitty-gritty. As one might foresee, if we want two languages to work together it is essential that we have a data format that can be understood by both---JSON lets us harmoniously pass data from one to the other. While it is natively supported in JavaScript, it can be graciously handled in R with the \href{https://CRAN.R-project.org/package=jsonlite}{jsonlite package} \citep{R-jsonlite}, in fact it is the serialiser used internally by all of the methods detailed in the previous section.

JSON is to all intents and purposes the equivalent of lists in R; a flexible data format that can store pretty much anything. Below we create a nested list and convert it to JSON with the help of jsonlite, we set \texttt{pretty} to \texttt{TRUE} to add indentation for clearer printing but this is an argument you should omit when writing production code, it will reduce the file size (fewer spaces = smaller file size).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# install.packages("jsonlite")}
\KeywordTok{library}\NormalTok{(jsonlite)}

\NormalTok{lst <{-}}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{a =} \DecValTok{1}\NormalTok{,}
  \DataTypeTok{b =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{c =} \KeywordTok{c}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\StringTok{"B"}\NormalTok{)}
\NormalTok{  ),}
  \DataTypeTok{d =} \DecValTok{1}\OperatorTok{:}\DecValTok{5}
\NormalTok{)}

\KeywordTok{toJSON}\NormalTok{(lst, }\DataTypeTok{pretty =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## {
##   "a": [1],
##   "b": {
##     "c": ["A", "B"]
##   },
##   "d": [1, 2, 3, 4, 5]
## }
\end{verbatim}

Looking closely at the list and JSON output above one quickly sees the resemblance. Something seems odd though, the first value in the list (\texttt{a\ =\ 1}) was serialised to an array (vector) of length one (\texttt{"a":\ {[}1{]}}) where one would probably expect an integer instead, \texttt{1} not \texttt{{[}1{]}}. This is not a mistake, we often forget that there are no scalar types in R and that \texttt{a} is in fact a vector as we can observe below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <{-}}\StringTok{ }\DecValTok{1}
\KeywordTok{length}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.vector}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

JavaScript, on the other hand, does have scalar types, more often than not we will want to convert our vectors of length one to scalar types rather than arrays of length one. To do so we need use the \texttt{auto\_unbox} argument in \texttt{jsonlite::toJSON}, we'll do this most of the time we have to convert data to JSON.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{toJSON}\NormalTok{(lst, }\DataTypeTok{pretty =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{auto\_unbox =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## {
##   "a": 1,
##   "b": {
##     "c": ["A", "B"]
##   },
##   "d": [1, 2, 3, 4, 5]
## }
\end{verbatim}

As demonstrated above the vector of length one was ``unboxed'' into an integer, with \texttt{auto\_unbox} set to \texttt{TRUE} jsonlite will properly convert such vectors into their appropriate type; integer, numeric, boolean, etc. If JSON is more or less the equivalent of lists in R one might wonder how jsonlite handles dataframes.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# subset of built{-}in dataset}
\NormalTok{df <{-}}\StringTok{ }\NormalTok{cars[}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, ]}

\KeywordTok{toJSON}\NormalTok{(df, }\DataTypeTok{pretty =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [
##   {
##     "speed": 4,
##     "dist": 2
##   },
##   {
##     "speed": 4,
##     "dist": 10
##   }
## ]
\end{verbatim}

What jsonlite does internally is essentially turn the data.frame into a list \emph{rowwise} to produce a sub-list for every row then it serialises to JSON. This is generally how rectangular data is represented in lists, for instance, \texttt{purrr::transpose} does the same. We can reproduce this with the snippet below, we remove row names and use apply to turn every row into a list.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{row.names}\NormalTok{(df) <{-}}\StringTok{ }\OtherTok{NULL}
\NormalTok{df\_list <{-}}\StringTok{ }\KeywordTok{apply}\NormalTok{(df, }\DecValTok{1}\NormalTok{, as.list)}

\KeywordTok{toJSON}\NormalTok{(df\_list, }\DataTypeTok{pretty =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{auto\_unbox =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [
##   {
##     "speed": 4,
##     "dist": 2
##   },
##   {
##     "speed": 4,
##     "dist": 10
##   }
## ]
\end{verbatim}

Jsonlite of course also enables reading data from JSON into R with the function \texttt{fromJSON}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{json <{-}}\StringTok{ }\KeywordTok{toJSON}\NormalTok{(df) }\CommentTok{\# convert to JSON}
\KeywordTok{fromJSON}\NormalTok{(json) }\CommentTok{\# read from JSON}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   speed dist
## 1     4    2
## 2     4   10
\end{verbatim}

It's important to note that jsonlite did the conversion back to a data frame. Therefore the code below also returns a data frame even though the object we initially converted to JSON is a list.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(df\_list)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "list"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{json <{-}}\StringTok{ }\KeywordTok{toJSON}\NormalTok{(df\_list)}
\KeywordTok{fromJSON}\NormalTok{(json)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   speed dist
## 1     4    2
## 2     4   10
\end{verbatim}

Jsonlite provides many more options and functions that will let you tune how JSON data is read and written. Also, the jsonlite package does far more than what we detailed in this section but at this juncture this is an adequate understanding of things.

\hypertarget{javascript}{%
\subsection*{JavaScript}\label{javascript}}


The book is not meant to teach one JavaScript, only to show how graciously it can work with R; in that endeavour we aim at writing little JavaScript so the book remains approachable to a wide audience. Let us just go through the very basics to ensure we know enough to get started with the next chapter.

In the event that you would want to try what we briefly explore here: the easiest way is to create an HTML file (e.g.: \texttt{index.html}), write your code within a script tag and open the file in your web browser. The output can be observed in the console of the browser which can be opened with a right click and selecting ``inspect'' then going to the ``console'' tab.

\begin{Shaded}
\begin{Highlighting}[]
 \ErrorTok{<}\NormalTok{!–– index.html ––>}
\KeywordTok{<html>}
  \KeywordTok{<head>}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \KeywordTok{<p}\OtherTok{ id=}\StringTok{"content"}\KeywordTok{>}\NormalTok{Trying JavaScript!}\KeywordTok{</p>}
  \KeywordTok{</body>}
  \KeywordTok{<script>}
    \CommentTok{// place your JavaScript code here}
  \KeywordTok{</script>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

The first difference with R is that the end of every line should be marked with a semi-colon. JavaScript code will often work without but one should always include them to avoid future headaches. Below we use \texttt{console.log}, JavaScript equivalent of R's \texttt{print} function.

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\StringTok{"hello JavaScript"}\NormalTok{) }\CommentTok{// bad}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\StringTok{"hello JavaScript"}\NormalTok{)}\OperatorTok{;} \CommentTok{// good}
\end{Highlighting}
\end{Shaded}

Another difference is that variables must be declared with keywords such as \texttt{var} or \texttt{const} to declare a constant.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{1}\OperatorTok{;} \CommentTok{// bad}
\KeywordTok{var}\NormalTok{ x }\OperatorTok{=} \DecValTok{1}\OperatorTok{;} \CommentTok{// good}
\end{Highlighting}
\end{Shaded}

One can declare a variable without assigning a value to it, to then do so later on.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// good}
\KeywordTok{var}\NormalTok{ y}\OperatorTok{;} 
\NormalTok{y }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\OperatorTok{,}\DecValTok{2}\OperatorTok{,}\DecValTok{3}\NormalTok{]}\OperatorTok{;} \CommentTok{// define it as array}
\NormalTok{y }\OperatorTok{=} \StringTok{\textquotesingle{}string\textquotesingle{}}\OperatorTok{;} \CommentTok{// change to character string}
\end{Highlighting}
\end{Shaded}

In R like in JavaScript, variables can be accessed from the parent environment (often referred to as ``context'' in the latter). One immense difference though is that while it is seen as bad practice in R it is not in JavaScript where it comes very useful.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# it works but don\textquotesingle{}t do this in R}
\NormalTok{x <{-}}\StringTok{ }\DecValTok{123}
\NormalTok{foo <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{()\{}
  \KeywordTok{print}\NormalTok{(x)}
\NormalTok{\}}
\KeywordTok{foo}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 123
\end{verbatim}

The above R code can be re-written in JavaScript. Note the slight variation in the function declaration.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// this is perfectly fine}
\KeywordTok{var}\NormalTok{ x }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}

\KeywordTok{function} \AttributeTok{foo}\NormalTok{()}\OperatorTok{\{}
  \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(x)}\OperatorTok{;} 
\OperatorTok{\}}

\AttributeTok{foo}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

One concept which does not exist in R is that of the ``DOM'' which stands for Document Object Model. When a web page is loaded, the browser creates a Document Object Model of the web page which can be accessed in JavaScript from the \texttt{document} object. This lets the developer programmatically manipulate the page itself so one can for instance, add an element (e.g.: a button), change the text of another, and plenty more.

The JavaScript code below grabs the element where \texttt{id=\textquotesingle{}content\textquotesingle{}} from the \texttt{document} with \texttt{getElementById} and replaces the text (\texttt{innerText}). Even though our page only contains ``Trying JavaScript!'' when the page is opened (loaded) in your web browse JavaScript runs our code and changes it: this happen very fast so you likely don't even see the original text.

\begin{Shaded}
\begin{Highlighting}[]
 \ErrorTok{<}\NormalTok{!–– index.html ––>}
\KeywordTok{<html>}
  \KeywordTok{<head>}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \KeywordTok{<p}\OtherTok{ id=}\StringTok{"content"}\KeywordTok{>}\NormalTok{Trying JavaScript!}\KeywordTok{</p>}
  \KeywordTok{</body>}
  \KeywordTok{<script>}
    \KeywordTok{var}\NormalTok{ cnt }\OperatorTok{=} \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\StringTok{"content"}\NormalTok{)}\OperatorTok{;}
    \VariableTok{cnt}\NormalTok{.}\AttributeTok{innerText} \OperatorTok{=} \StringTok{"The text has changed"}\OperatorTok{;}
  \KeywordTok{</script>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

This of course only scratches the surface of JavaScript but provides ample understanding of the language to keep up with the next chapters. Also, a somewhat interesting fact that will prove useful later in the book: the RStudio IDE is actually is a browser, therefore, in the IDE, one can right-click and ``inspect element'' to rendered source code.

\hypertarget{methods}{%
\section*{Methods}\label{methods}}


Though perhaps not obvious at first, all of the packages used as examples in the previous section internally interface with JavaScript very differently. As we'll discover, there many ways in which one can blend JavaScript with R, generally the way to go about it is dictated by the nature of what is to be achieved.

Let's list the methods available to us to blend JavaScript with R before covering them each in-depth in their own respective chapter later in the book.

\hypertarget{v8}{%
\subsection*{V8}\label{v8}}


\href{https://github.com/jeroen/v8}{V8} by Jeroen Ooms is an R interface to Google's JavaScript engine. It will let you run JavaScript code directly from R and get the result back, it even comes with an interactive console. This is the way the lawn package used in a previous example internally calls turf.js.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(V8)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Using V8 engine 3.14.5.9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ctx <{-}}\StringTok{ }\KeywordTok{v8}\NormalTok{()}

\NormalTok{ctx}\OperatorTok{$}\KeywordTok{eval}\NormalTok{(}\StringTok{"2 + 2"}\NormalTok{) }\CommentTok{\# this is evaluated in JavaScript!}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "4"
\end{verbatim}

\hypertarget{htmlwidgets}{%
\subsection*{htmlwidgets}\label{htmlwidgets}}


\href{http://www.htmlwidgets.org/}{htmlwidgets} \citep{R-htmlwidgets} specialises in wrapping JavaScript libraries that generate visual outputs. This is what packages such as plotly, \href{https://rstudio.github.io/DT/}{DT} \citep{R-DT}, \href{http://jkunst.com/highcharter/}{highcharter} \citep{R-highcharter}, and many more use to provide interactive visualisation with R.

It is by far the most popular integration out there, at the time of writing this it has been downloaded nearly 10 million times from CRAN. It will therefore be covered extensively in later chapters.

\hypertarget{shiny}{%
\subsection*{Shiny}\label{shiny}}


The Shiny framework allows creating applications accessible from web browsers where JavaScript natively runs, it follows that JavaScript can run \emph{alongside} such applications. Often overlooked though, the two can also work \emph{hand-in-hand} as one can pass data from the R server to the JavaScript front-end and vice versa. Some form of that tends to be included in htmlwidgets so one can pick up server-side which point on a scatter plot was clicked for instance.

\hypertarget{reactr}{%
\subsection*{reactR}\label{reactr}}


\href{https://react-r.github.io/reactR/}{ReactR} \citep{R-reactR} is an R package that emulates very well htmlwidgets but specifically for the \href{https://reactjs.org/}{React framework}. Unlike htmlwidgets it is not limited to visual outputs and also provides functions to build inputs, e.g.: a drop-down menu (like \texttt{shiny::selectInput}). The \href{https://glin.github.io/reactable/}{reactable package} \citep{R-reactable} uses reactR to enable building interactive tables solely from R code.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{reactable}\OperatorTok{::}\KeywordTok{reactable}\NormalTok{(iris[}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, ], }\DataTypeTok{showPagination =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{bookdown_files/figure-latex/unnamed-chunk-12-1.png}

Note that custom Shiny inputs can also be built, this is however not covered in this book for it is very well \href{https://shiny.rstudio.com/articles/building-inputs.html}{documented}.

\hypertarget{bubble}{%
\subsection*{bubble}\label{bubble}}


\href{https://github.com/ColinFay/bubble}{bubble} \citep{R-bubble} by Colin Fay is a more recent R package, still under heady development but very promising: it lets one run \href{https://nodejs.org/en/}{node.js} code in R, comes with an interactive node REPL, the ability to install npm packages, and even an R markdown engine. It's similar to V8 in many ways.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(bubble)}

\NormalTok{n <{-}}\StringTok{ }\NormalTok{NodeSession}\OperatorTok{$}\KeywordTok{new}\NormalTok{() }

\NormalTok{n}\OperatorTok{$}\KeywordTok{eval}\NormalTok{(}\StringTok{"2 + 2"}\NormalTok{) }\CommentTok{\# this is evaluated in node.js}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 4
\end{verbatim}

\hypertarget{r2d3}{%
\subsection*{r2d3}\label{r2d3}}


\href{https://rstudio.github.io/r2d3/}{r2d3} \citep{R-r2d3} by RStudio is an R package designed specifically to work with \href{https://d3js.org/}{d3.js}. It is similar to htmlwidgets but works rather differently.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# https://rstudio.github.io/r2d3/articles/gallery/chord/}
\NormalTok{r2d3}\OperatorTok{::}\KeywordTok{r2d3}\NormalTok{(}\DataTypeTok{data =} \KeywordTok{matrix}\NormalTok{(}\KeywordTok{round}\NormalTok{(}\KeywordTok{runif}\NormalTok{(}\DecValTok{16}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{10000}\NormalTok{)), }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{4}\NormalTok{), }\DataTypeTok{script =} \StringTok{"chord.js"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{bookdown_files/figure-latex/unnamed-chunk-14-1.png}

The packages bubble and V8 are intended for use of JavaScript for computations while r2d3, htmlwidgets, and reactR are designed to produce visual outputs (e.g.: graphs and tables), using JavaScript in Shiny can of course be used for the latter but is certainly not limited to that.

\hypertarget{part-javascript-for-computations}{%
\part{JavaScript for Computations}\label{part-javascript-for-computations}}

\hypertarget{the-v8-engine}{%
\chapter{The V8 Engine}\label{the-v8-engine}}

V8 is an R interface to Google's open source JavaScript engine of the same name, it powers Google Chrome, node.js and many other things. It is the first integration of JavaScript with R that we cover in this book. Both the V8 package and the engine it wraps are simple yet amazingly powerful.

\hypertarget{installation}{%
\section*{Installation}\label{installation}}


First install the V8 engine itself, instructions to do so are well detailed on \href{https://github.com/jeroen/v8\#installation}{V8's README} and below.

On Debian or Ubuntu use the code below from the terminal to install \href{https://v8.dev/}{libv8}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sudo}\NormalTok{ apt{-}get install {-}y libv8{-}dev}
\end{Highlighting}
\end{Shaded}

On Centos install v8-devel, which requires the EPEL tools.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sudo}\NormalTok{ yum install epel{-}release}
\FunctionTok{sudo}\NormalTok{ yum install v8{-}devel}
\end{Highlighting}
\end{Shaded}

On Mac OS use \href{https://brew.sh/}{Homebrew}.

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{brew}\NormalTok{ install v8}
\end{Highlighting}
\end{Shaded}

Then install the R package from CRAN.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"V8"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{basics}{%
\section*{Basics}\label{basics}}


V8 provides a reference class via \href{https://github.com/r-lib/R6}{R6} \citep{R-R6}, which pertains to object-oriented programming, hence it might look unconventional to many R users. It's nonetheless easy to grasp. If one wants to learn more about the R6's reference class system Hadley Wickham has a very good chapter on it in his \href{https://adv-r.hadley.nz/r6.html}{Advanced R} book.

Let's explore the basic functionalities of the package. First, load the library and use the function \texttt{v8} to instantiate a class.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(V8)}

\NormalTok{engine <{-}}\StringTok{ }\KeywordTok{v8}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

The \texttt{eval} method allows running JavaScript code from R and retrive the results.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{engine}\OperatorTok{$}\KeywordTok{eval}\NormalTok{(}\StringTok{"var x = 3 + 4;"}\NormalTok{) }\CommentTok{\# this is evealuated in R}
\NormalTok{engine}\OperatorTok{$}\KeywordTok{eval}\NormalTok{(}\StringTok{"x"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "7"
\end{verbatim}

Two observations on the above snippet of code. First, the variable we got back in R is a character vector when it should have been either an integer or a numeric. This is because we used the \texttt{eval} method which merely prints the output, \texttt{get} is more appropriate; it converts it to an appropriate R equivalent.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# retrieve our previously created variable}
\NormalTok{(x <{-}}\StringTok{ }\NormalTok{engine}\OperatorTok{$}\KeywordTok{get}\NormalTok{(}\StringTok{"x"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "integer"
\end{verbatim}

Second, while creating a scalar with \texttt{eval("var\ x\ =\ 1;")} appears painless, imagine if you will the horror of having to convert a data frame to a JavaScript array via jsonlite then flatten it to character string so it can be used with the \texttt{eval} method. Horrid. Thankfully V8 comes with a method \texttt{assign}, complimentary to \texttt{get}, which declares R objects as JavaScript variables. It takes two arguments, first the name of the variable to create, second the object to assign to it.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# assign and retrieve a data.frame}
\NormalTok{engine}\OperatorTok{$}\KeywordTok{assign}\NormalTok{(}\StringTok{"vehicles"}\NormalTok{, cars[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, ])}
\NormalTok{engine}\OperatorTok{$}\KeywordTok{get}\NormalTok{(}\StringTok{"vehicles"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   speed dist
## 1     4    2
## 2     4   10
## 3     7    4
\end{verbatim}

All of the conversion is handled by V8 internally with jsonlite as demonstrated in the previous chapter. We can confirm that the data frame was converted to a list rowwise; using \texttt{JSON.stringify} to display how the object is store in V8.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cat}\NormalTok{(engine}\OperatorTok{$}\KeywordTok{eval}\NormalTok{(}\StringTok{"JSON.stringify(vehicles, null, 2);"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [
##   {
##     "speed": 4,
##     "dist": 2
##   },
##   {
##     "speed": 4,
##     "dist": 10
##   },
##   {
##     "speed": 7,
##     "dist": 4
##   }
## ]
\end{verbatim}

However the cyclical loop of 1) creating a variable in JavaScript to 2) run a function on the aforementioned object 3) get the results back in R, can be tedious. So V8 also allows calling JavaScript functions on R objects directly with the \texttt{call} method and obtain the results back in R.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{engine}\OperatorTok{$}\KeywordTok{eval}\NormalTok{(}\StringTok{"new Date();"}\NormalTok{) }\CommentTok{\# using eval}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Wed Jun 03 2020 21:23:13 GMT+0200 (CEST)"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{engine}\OperatorTok{$}\KeywordTok{call}\NormalTok{(}\StringTok{"Date"}\NormalTok{, }\KeywordTok{Sys.Date}\NormalTok{()) }\CommentTok{\# using call}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Wed Jun 03 2020 21:23:13 GMT+0200 (CEST)"
\end{verbatim}

Finally, one can run code interactively rather than as strings by calling the console from the engine with \texttt{engine\$console()} you can then exit the console by typing \texttt{exit} or hitting the ESC key.

\hypertarget{external-libraries}{%
\section*{External Libraries}\label{external-libraries}}


V8 is actually quite bare in and of itself, there is for instance no functionalities built-in to read or write files from disk, it thus becomes truly interesting when you can use it JavaScript libraries. We do so with the \texttt{source} method which takes a \texttt{file} argument that will accept a path or URL to a JavaScript file to source. We'll demonstrate this using \href{https://fusejs.io/}{fuse.js} a fuzzy-search library.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{engine}\OperatorTok{$}\KeywordTok{source}\NormalTok{(}\StringTok{"https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.4.6/fuse.min.js"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "true"
\end{verbatim}

You can think of it as using the \texttt{script} tag in HTML to source (\texttt{src}) said file from disk or CDN.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<html>}
  \KeywordTok{<head>}
    \KeywordTok{<script}\OtherTok{ src=}\StringTok{\textquotesingle{}https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.4.6/fuse.min.js\textquotesingle{}}\KeywordTok{></script>}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \KeywordTok{<p>}\NormalTok{Content}\KeywordTok{</p>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

With the library imported we can use its functionalities. We'll replicate an example from fuse.js official website where it executes a search on an object that contains books and looks like JSON below.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ books }\OperatorTok{=}\NormalTok{ [}\OperatorTok{\{}
  \StringTok{\textquotesingle{}ISBN\textquotesingle{}}\OperatorTok{:} \StringTok{\textquotesingle{}A\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}title\textquotesingle{}}\OperatorTok{:} \StringTok{"Old Man\textquotesingle{}s War"}\OperatorTok{,}
  \StringTok{\textquotesingle{}author\textquotesingle{}}\OperatorTok{:} \StringTok{\textquotesingle{}John Scalzi\textquotesingle{}}
\OperatorTok{\},} \OperatorTok{\{}
  \StringTok{\textquotesingle{}ISBN\textquotesingle{}}\OperatorTok{:} \StringTok{\textquotesingle{}B\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}title\textquotesingle{}}\OperatorTok{:} \StringTok{\textquotesingle{}The Lock Artist\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}author\textquotesingle{}}\OperatorTok{:} \StringTok{\textquotesingle{}Steve Hamilton\textquotesingle{}}
\OperatorTok{\}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

This can be easily created, as we've already seen this is just how V8 creates data frames. We define a data.frame of books that looks similar and load it into our engine.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{books <{-}}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{title =} \KeywordTok{c}\NormalTok{(}
    \StringTok{"Rights of Man"}\NormalTok{,}
    \StringTok{"Black Swan"}\NormalTok{,}
    \StringTok{"Common Sense"}\NormalTok{,}
    \StringTok{"Sense and Sensibility"}
\NormalTok{  ),}
  \DataTypeTok{id =} \KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"d"}\NormalTok{)}
\NormalTok{)}

\NormalTok{engine}\OperatorTok{$}\KeywordTok{assign}\NormalTok{(}\StringTok{"books"}\NormalTok{, books)}
\end{Highlighting}
\end{Shaded}

Then again we can make sure that the data.frame was turned into a rowwise JSON object.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cat}\NormalTok{(engine}\OperatorTok{$}\KeywordTok{eval}\NormalTok{(}\StringTok{"JSON.stringify(books, null, 2);"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [
##   {
##     "title": "Rights of Man",
##     "id": "a"
##   },
##   {
##     "title": "Black Swan",
##     "id": "b"
##   },
##   {
##     "title": "Common Sense",
##     "id": "c"
##   },
##   {
##     "title": "Sense and Sensibility",
##     "id": "d"
##   }
## ]
\end{verbatim}

Now we can define options for our search, we don't get into the details of fuse.js here as this is not the purpose of this book, you can read more about the options in the \href{https://fusejs.io/\#Examples}{examples section} of the site. We can mimic the format of the JSON options shown on the website with a simple list and assign that to our engine. If this confuses read the \href{intro.html\#json}{JSON section of the introduction}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// JavaScript}
\KeywordTok{var}\NormalTok{ options }\OperatorTok{=} \OperatorTok{\{}
  \DataTypeTok{keys}\OperatorTok{:}\NormalTok{ [}\StringTok{\textquotesingle{}title\textquotesingle{}}\NormalTok{]}\OperatorTok{,}
  \DataTypeTok{id}\OperatorTok{:} \StringTok{\textquotesingle{}id\textquotesingle{}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# R}
\NormalTok{options <{-}}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{keys =} \KeywordTok{list}\NormalTok{(}\StringTok{"title"}\NormalTok{),}
  \DataTypeTok{id =} \StringTok{"id"}
\NormalTok{)}

\NormalTok{engine}\OperatorTok{$}\KeywordTok{assign}\NormalTok{(}\StringTok{"options"}\NormalTok{, options)}
\end{Highlighting}
\end{Shaded}

Then we can finish the second step of the online examples, instantiate a fuse.js object with our books and options objects then make a simple search, we assign the results of the search to an object which we then retrieve in R with \texttt{get}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{engine}\OperatorTok{$}\KeywordTok{eval}\NormalTok{(}\StringTok{"var fuse = new Fuse(books, options)"}\NormalTok{)}
\NormalTok{engine}\OperatorTok{$}\KeywordTok{eval}\NormalTok{(}\StringTok{"var results = fuse.search(\textquotesingle{}sense\textquotesingle{})"}\NormalTok{)}
\NormalTok{engine}\OperatorTok{$}\KeywordTok{get}\NormalTok{(}\StringTok{"results"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "d" "c"
\end{verbatim}

A search for ``sense'' returns a vector of ids where the term ``sense'' was found; \texttt{c} and \texttt{d} or the books Common Sense, Sense and Sensibility. We could perhaps make that last code simpler using the \texttt{call} method.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{engine}\OperatorTok{$}\KeywordTok{call}\NormalTok{(}\StringTok{"fuse.search"}\NormalTok{, }\StringTok{"sense"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "d" "c"
\end{verbatim}

\hypertarget{with-npm}{%
\section*{With Npm}\label{with-npm}}


We can also use \href{https://www.npmjs.com/}{npm} packages, though not all will work. Npm is Node's Package Manager, or in a sense Node's equivalent of CRAN.

To use npm packages we need \href{http://browserify.org/}{browserify}, a node library to bundle all dependencies of an npm package into a single, file which we can subsequently source in V8. Browserify is itself an npm package and there requires node and npm installed.

You can install browserify globally with the following command from the terminal.

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{npm}\NormalTok{ install {-}g browserify}
\end{Highlighting}
\end{Shaded}

We can now browserify an npm package. To demonstrate we will use \href{https://github.com/zeit/ms}{ms} which converts various time formats to milliseconds. First we install the package.

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{npm}\NormalTok{ install ms}
\end{Highlighting}
\end{Shaded}

Then we browserify it. The first line creates a file called \texttt{in.js} which contains \texttt{global.ms\ =\ require(\textquotesingle{}ms\textquotesingle{});} we then call browserify on that file specifying \texttt{ms.js} as output file.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{echo} \StringTok{"global.ms = require(\textquotesingle{}ms\textquotesingle{});"} \OperatorTok{>}\NormalTok{ in.js}
\ExtensionTok{browserify}\NormalTok{ in.js {-}o ms.js}
\end{Highlighting}
\end{Shaded}

We can now source \texttt{ms.js} with v8.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(V8)}

\NormalTok{ms <{-}}\StringTok{ }\KeywordTok{v8}\NormalTok{()}
\NormalTok{ms}\OperatorTok{$}\KeywordTok{source}\NormalTok{(}\StringTok{"ms.js"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Then use the library.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ms}\OperatorTok{$}\KeywordTok{eval}\NormalTok{(}\StringTok{"ms(\textquotesingle{}2 days\textquotesingle{})"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "172800000"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ms}\OperatorTok{$}\KeywordTok{eval}\NormalTok{(}\StringTok{"ms(\textquotesingle{}1y\textquotesingle{})"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "31557600000"
\end{verbatim}

\hypertarget{use-in-packages}{%
\section*{Use in Packages}\label{use-in-packages}}


In this section we detail how one should go about using V8 in an R package, if you are not familiar with package development you can skip ahead.

Create a package however you usually do, using usethis, devtools or the RStudio IDE interface. Below we create a package called ``ms'' that will hold functionalities we explored in the previous section on npm packages.

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{R}\NormalTok{ {-}e }\StringTok{"usethis::create\_package(\textquotesingle{}ms\textquotesingle{})"}
\BuiltInTok{cd}\NormalTok{ ./ms}
\end{Highlighting}
\end{Shaded}

The package is going to rely on V8 so you can add it under \texttt{Imports} in the \texttt{DESCRIPTION}. We are going to need to instantiate the class at some point (\texttt{engine\ \textless{}-\ v8()}).

One could perhaps require the user to do create such an object but it would not be convenient. Instead we can use \texttt{.onLoad}. You can read more about this function Hadley Wickham's \href{http://r-pkgs.had.co.nz/r.html}{Advanced R book}. The Python integration of R, \href{https://rstudio.github.io/reticulate}{reticulate} \citep{R-reticulate} also advises \href{https://rstudio.github.io/reticulate/articles/package.html}{this method} to import modules too. We often see this function placed in a \texttt{zzz.R} file.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# zzz.R}
\NormalTok{ms <{-}}\StringTok{ }\OtherTok{NULL}

\NormalTok{.onLoad <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(libname, pkgname)\{}
\NormalTok{  ms <<{-}}\StringTok{ }\KeywordTok{v8}\NormalTok{()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Our package should also include the external library \texttt{ms.js} we built from the npm package. We should place it in the \texttt{inst} directory. Create it and place the \texttt{ms.js} file within the latter.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mkdir}\NormalTok{ {-}p inst}
\end{Highlighting}
\end{Shaded}

This should give a directory similar to this, for brevity we exclude \texttt{DESCRIPTION}, \texttt{NAMESPACE}, and other files that make up a package.

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{R/}
\KeywordTok{|} \ExtensionTok{zzz.R}
\ExtensionTok{inst/}
\KeywordTok{|} \ExtensionTok{{-}{-}}\NormalTok{ ms.js}
\end{Highlighting}
\end{Shaded}

Now the dependency can be sourced in the \texttt{.onLoad} function. We can access the files in the \texttt{inst} directory with the \texttt{system.file} function. When using the \texttt{.onLoad} function it is good practice to clean up with \texttt{.onUnload}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# zzz.R}
\NormalTok{ms <{-}}\StringTok{ }\OtherTok{NULL}

\NormalTok{.onLoad <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(libname, pkgname)\{}
\NormalTok{  ms <<{-}}\StringTok{ }\NormalTok{V8}\OperatorTok{::}\KeywordTok{v8}\NormalTok{()}

\NormalTok{  dep <{-}}\StringTok{ }\KeywordTok{system.file}\NormalTok{(}\StringTok{"ms.js"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"ms"}\NormalTok{)}
\NormalTok{  ms}\OperatorTok{$}\KeywordTok{source}\NormalTok{(dep)}
\NormalTok{\}}

\NormalTok{.onUnload <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(libpath)\{}
\NormalTok{  ms}\OperatorTok{$}\KeywordTok{reset}\NormalTok{()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We can then create a \texttt{to\_ms} function, it will have access the \texttt{ms} object we instantiated in \texttt{.onLoad}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Convert To Millisecond}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} Convert to milliseconds to various formats.}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @param string String to convert.}
\CommentTok{\#\textquotesingle{} }
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{to\_ms <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(string)\{}
\NormalTok{  ms}\OperatorTok{$}\KeywordTok{call}\NormalTok{(}\StringTok{"ms"}\NormalTok{, string)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

After running \texttt{devtools::document()} and \texttt{devtools::load\_all()} the call \texttt{to\_ms("2\ days")} will return \texttt{172800000}. Finally,, remember to add V8 as dependency.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{usethis}\OperatorTok{::}\KeywordTok{use\_package}\NormalTok{(}\StringTok{"V8"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{node}{%
\chapter{Node.js with Bubble}\label{node}}

A more recent R package, called bubble which will will let you run node.js code from R, the package comes with an REPL and an R markdown engine. As it is still under heavy development the package is not yet available on CRAN, you can get it from Github using either the devtools or \href{https://remotes.r-lib.org/}{remotes package} \citep{R-remotes}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# install.packages("remotes")}
\NormalTok{remotes}\OperatorTok{::}\KeywordTok{install\_github}\NormalTok{(}\StringTok{"ColinFay/bubble"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{basics-1}{%
\section*{Basics}\label{basics-1}}


bubble is very similar to V8, it's also a reference class and the name of the methods are identical.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(bubble)}

\NormalTok{n <{-}}\StringTok{ }\NormalTok{NodeSession}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}
\NormalTok{n}\OperatorTok{$}\KeywordTok{eval}\NormalTok{(}\StringTok{"2 + 2;"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 4
\end{verbatim}

You can also assign and get variables, just like with v8.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n}\OperatorTok{$}\KeywordTok{assign}\NormalTok{(vehicles, cars[}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, ])}
\NormalTok{n}\OperatorTok{$}\KeywordTok{get}\NormalTok{(vehicles)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   speed dist
## 1     4    2
## 2     4   10
\end{verbatim}

Bubble also comes with an REPL terminal (read-eval-print loop), which can be launched with \texttt{bubble::node\_repl()}.

\hypertarget{r-markdown-engine}{%
\section*{R Markdown Engine}\label{r-markdown-engine}}


Bubble comes with an R markdown engine so JavaScript code can be evaluated in node from an R markdown document such as this one. To do so we simply need to place \texttt{bubble::set\_node\_engine()} at the top of the document, subsequent \texttt{node} chunks will be evaluated in a node session.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bubble}\OperatorTok{::}\KeywordTok{set\_node\_engine}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Once set we can run node code.

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\DecValTok{2} \OperatorTok{+} \DecValTok{3}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 5
## undefined
\end{verbatim}

\hypertarget{npm}{%
\section*{Npm}\label{npm}}


Npm is to node.js what CRAN is to R; a repository of packages that can be conveniently installed. Such packages can be installed using another Reference class called \texttt{NPM}. While with V8 one needs to ``browserify'' npm packages in hope that they work, with bubble, since it interacts with node js directly, there is no need for to ``browserify'' packages and we can be assured that they work.

Let us demonstrate with the \href{https://github.com/NaturalNode/natural}{natural} package which provides general natural language facility.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# initialise and install}
\NormalTok{npm <{-}}\StringTok{ }\NormalTok{Npm}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}\OperatorTok{$}\KeywordTok{install}\NormalTok{(}\StringTok{"natural"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## > Add `node_modules` to .gitignore
\end{verbatim}

The above snippet initialises npm, which creates the pacakge.json file and a node\_modules directory. The first is a DESCRIPTION file for node projects so to speak, the latter is a directory to hold dependencies installed.

The packages can then be imported in the node session and interacted with.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n}\OperatorTok{$}\KeywordTok{eval}\NormalTok{(}\StringTok{"const natural = require(\textquotesingle{}natural\textquotesingle{})"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## undefined
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n}\OperatorTok{$}\KeywordTok{eval}\NormalTok{(}\StringTok{"var tokenizer = new natural.WordTokenizer();"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## undefined
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n}\OperatorTok{$}\KeywordTok{eval}\NormalTok{(}\StringTok{"tokenizer.tokenize(\textquotesingle{}Using nodejs from R with npm.\textquotesingle{})"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [ 'Using', 'nodejs', 'from', 'R', 'with', 'npm' ]
\end{verbatim}

\hypertarget{use-in-packages-1}{%
\section*{Use in Packages}\label{use-in-packages-1}}


To demonstrate how to use bubble in packages we shall build one to hold the functions we explored in the previous section.

Create a package called ``organic'' using devtools, the RStudio IDE, or usethis as shown below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{usethis}\OperatorTok{::}\KeywordTok{create\_package}\NormalTok{(}\StringTok{"organic"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Then edit the DESCRIPTION file so that it imports the bubble package, since it is not yet on CRAN the Github dependency should be specified under \texttt{Remotes}.

\begin{verbatim}
Package: organic
Title: Natural Language Facilities
Imports:
  bubble
Remotes:
  ColinFay/bubble
\end{verbatim}

\hypertarget{part-web-development-with-shiny}{%
\part{Web Development with Shiny}\label{part-web-development-with-shiny}}

\hypertarget{shiny-1}{%
\chapter{Shiny}\label{shiny-1}}

Shiny is by far most popular, if not the only, web framework for the R programming language. In this chapter, after brushing up on the necessary to include JavaScript in shiny applications, we explore how to blend the JavaScript language with our R server and front-end.

Then again, the aim is not to write a lot of convoluted JavaScript, on the contrary, it is to write as little as possible and demonstrate to the reader that it is often enough to greatly improve the user experience of shiny applications. Making shiny work with JavaScript can essentially be broken down into two operations: 1) passing data from the R server to the JavaScript client and 2) the other way around, from the client to the R server.

In this chapter every section builds upon the previous, only skip those if you truly feel confident you understand it fully or you will get confused.

\hypertarget{static-files}{%
\section*{Static Files}\label{static-files}}


In order to introduce JavaScript to shiny applications one must understand static files and how they work with the framework. Static files are files that are downloaded by the clients, in this case web browsers accessing shiny applications, as-is, these generally include images, CSS (\texttt{.css}), and JavaScript (\texttt{.js}).

If you are familiar with R package development, static files are to shiny applications what the ``inst'' directory is to an R package, those files are installed as-is and do not require further processing as opposed to the ``src'' folder which contains files that need compiling for instance.

There are numerous ways to run a shiny application locally; the two most used probably are \texttt{shinyApp} and \texttt{runApp}. The RStudio IDE comes with a convenient ``Run'' button when writing a shiny application, which when clicked actually uses the function \texttt{shiny::runApp} in the background, this function looks for said static files in the \texttt{www} directory and makes them available at the same path (\texttt{/www}). If you are building your applications outside of RStudio, you should either also use \texttt{shiny::runApp} or specify the directory which then allows using \texttt{shiny::shinyApp}. Note that this only applies locally, shiny server (community and pro) as well as \href{https://www.shinyapps.io/}{shinyapps.io} use the same defaults as the RStudio IDE and \texttt{shiny::runApp}.

In order to ensure the code in this book can run regardless of the reader's machine or editor, the asset directory is always specified explicitly. This is probably advised to steer clear of the potential headaches as, unlike the default, it'll work regardless of the environment. If you are using \href{https://thinkr-open.github.io/golem/}{golem} \citep{R-golem} to develop your application then you should not worry about this as it specifies the directory internally.

Below we build a basic shiny application, however, before we define the ui and server we use the \texttt{shiny::addResourcePath} function to specify the location of the directory of static files that will be served by the server and thus accessible by the client. This function takes two arguments, first the \texttt{prefix}, which is the path (URL) at which the assets will be available, second the path to the directory of static assets.

We thus create the ``assets'' directory and a JavaScript file called \texttt{script.js} within it.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# run from root of app (where app.R is located)}
\KeywordTok{dir.create}\NormalTok{(}\StringTok{"assets"}\NormalTok{)}
\KeywordTok{writeLines}\NormalTok{(}\StringTok{"console.log(\textquotesingle{}Hello JS!\textquotesingle{});"}\NormalTok{, }\DataTypeTok{con =} \StringTok{"assets/script.js"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can now use the \texttt{shiny::addResourcePath} to point to this directory. Generally the same name for the directory of static assets and prefix is used so as to avoid confusion, below we name them differently in order for the reader to clearly distinguish which is which.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# app.R}
\KeywordTok{library}\NormalTok{(shiny)}

\CommentTok{\# serve the files}
\KeywordTok{addResourcePath}\NormalTok{(}
  \CommentTok{\# will be accessible at /files}
  \DataTypeTok{prefix =} \StringTok{"files"}\NormalTok{, }
  \CommentTok{\# path to our assets directory}
  \DataTypeTok{directoryPath =} \StringTok{"assets"}
\NormalTok{)}

\NormalTok{ui <{-}}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \KeywordTok{h1}\NormalTok{(}\StringTok{"R and JavaScript"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output)\{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

If you then run the application and open it at the \texttt{/files/script.js} path (e.g.: \texttt{127.0.0.1:3000/files/script.js}) you should see the content of our JavaScript file (\texttt{console.log(\textquotesingle{}Hello\ JS!\textquotesingle{})}), commenting the \texttt{addResourcePath} line will have a ``Not Found'' error displayed on the page instead.

All files in your asset directory will be served online and accessible to anyone: do not place sensitive files in it.

Though one may create multiple such directory and correspondingly use \texttt{addResourcePath} to specify multiple paths and prefixes, one will routinely specify a single one, named ``assets'' or ``static,'' which contains multiple subdirectories, one for each type of static file to obtain a directory that looks something like the tree below. This is, however, an unwritten convention which is by no means forced upon the developer: do as you wish.

\begin{verbatim}
assets/
├── js/
│    └── script.js
├── css/
│    └── style.css
└── img/
     └── pic.png
\end{verbatim}

At this stage we have made the JavaScript file we created accessible by the clients but we still have to source this file in our \texttt{ui} as currently this file is, though served, not used by our application. Were one creating a static HTML page one would use the \texttt{script} to \texttt{src} the file in the \texttt{head} of the page.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<html>}
  \KeywordTok{<head>}
    \ErrorTok{<}\NormalTok{!–– source the JavaScript file ––>}
    \KeywordTok{<script}\OtherTok{ src=}\StringTok{"path/to/script.js"}\KeywordTok{></script>}
  \KeywordTok{</head>}
  \KeywordTok{<body>}
    \KeywordTok{<p}\OtherTok{ id=}\StringTok{"content"}\KeywordTok{>}\NormalTok{Trying JavaScript!}\KeywordTok{</p>}
  \KeywordTok{</body>}
\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

In shiny we write the ui in R and not in HTML (though this is also supported). Given the resemblance between the names of HTML tags and shiny UI functions it's pretty straightforward, the html page above would look something like the shiny \texttt{ui} below.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}

\NormalTok{ui <{-}}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}\DataTypeTok{src =} \StringTok{"path/to/script.js"}\NormalTok{)}
\NormalTok{  ),}
  \KeywordTok{p}\NormalTok{(}\DataTypeTok{id =} \StringTok{"content"}\NormalTok{, }\StringTok{"Trying JavaScript!"}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Note that we use the \texttt{tags} object which comes from the shiny package and includes HTML tags that are not exported as standalone functions. For instance, you can create a \texttt{\textless{}div\textgreater{}} in shiny with the \texttt{div} function but \texttt{tags\$div} will also work. This can now be applied to the shiny application, the \texttt{path/to/script.js} should be changed to \texttt{files/script.js} where \texttt{files} is the prefix we defined in \texttt{addResourcePath}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# app.R}
\KeywordTok{library}\NormalTok{(shiny)}

\CommentTok{\# serve the files}
\KeywordTok{addResourcePath}\NormalTok{(}\DataTypeTok{prefix =} \StringTok{"files"}\NormalTok{, }\DataTypeTok{directoryPath =} \StringTok{"assets"}\NormalTok{)}

\NormalTok{ui <{-}}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}\DataTypeTok{src =} \StringTok{"files/script.js"}\NormalTok{)}
\NormalTok{  ),}
  \KeywordTok{h1}\NormalTok{(}\StringTok{"R and JavaScript"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output)\{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

From the browser, inspecting page (right click \textgreater{} inspect \textgreater{} console tab) one should see ``Hello JS!'' in the console which means our application correctly ran the code in our JavaScript file.

\hypertarget{integration}{%
\section*{Integration}\label{integration}}


The following sections will walk you through an example in which one first starts with a basic hello-world-like JavaScript example running in shiny and ends with a fully-fledged R package that brings new functionalities to shiny by integrating a third party library.

We first build an application that passes a message from the R server to the client to display said message as a vanilla JavaScript alert (pop-up), then send back to the R server whether the user has clicked ``OK'' on the alert. Finally we replicate that but with an external library and wrap the whole project into a fully functional package. This package will look similar to others that provide JavaScript integrations with shiny such as shinyjs \citep{R-shinyjs} or waiter \citep{R-waiter}.

First, let's write a barebone shiny application which includes the JavaScript code which opens an alert.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}

\NormalTok{ui <{-}}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \StringTok{"alert(\textquotesingle{}Hello from JavaScript\textquotesingle{});"}
\NormalTok{  ),}
  \KeywordTok{h1}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session)\{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\centering
\includegraphics{images/alert.png}
\caption{JavaScript alert in shiny}
\end{figure}

One thing important to note for later is that alerts will always block the execution of code which allows making sure some code is only run with user consent or the user being aware of the consequences.

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{alert}\NormalTok{(}\StringTok{\textquotesingle{}delete everything?\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\AttributeTok{deleteEverythingOnlyIfUserOK}\NormalTok{()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{from-r-to-javascript}{%
\section*{From R to JavaScript}\label{from-r-to-javascript}}


Now that we have a simple alert displayed in the application we can tie it with our R server; the alert should display a message sent by the R server, this would enable, for instance, displaying a message taken from a database or a user input. As might be expected there are two functions required to do so, an R function and its JavaScript complementary: one to send the data from the server and another to catch said data from the client and display the alert.

Let us start by writing the R code to send the data, thankfully very little is required of the developer. One can send data from the R server to the client from the \texttt{session} object using the \texttt{sendCustomMessage} method. The method takes two arguments, first an identifier (where to send the data to), second the actual data to send to JavaScript.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{server <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session)\{}
  \CommentTok{\# set the identifier to send{-}alert}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"send{-}alert"}\NormalTok{, }\DataTypeTok{message =} \StringTok{"Hi there!"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This effectively sends our message to the JavaScript client but we are yet to use that message JavaScript-side so the application still displays the same alert on load. We can add a ``handler'' for the identifier we defined (\texttt{send-alert}) which will so something with the message we sent from the server. This is done with the \texttt{addCustomMessageHandler} method from the \texttt{Shiny} object where the first argument is the identifier and the second is the function that handles the message, generally a function that takes a single argument: the data sent from the server.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
  \StringTok{"Shiny.addCustomMessageHandler(type = \textquotesingle{}send{-}alert\textquotesingle{}, function(message) \{}
\StringTok{    alert(message);}
\StringTok{  \});"}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\centering
\includegraphics{images/alert-shiny.png}
\caption{Alert sent from shiny server}
\end{figure}

This enables you to pass a message that is taken from a database for instance, or as shown below from a user input, to the alert.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}

\NormalTok{ui <{-}}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \StringTok{"Shiny.addCustomMessageHandler(type = \textquotesingle{}send{-}alert\textquotesingle{}, function(message) \{}
\StringTok{      alert(message);}
\StringTok{    \});"}
\NormalTok{  ),}
  \KeywordTok{h1}\NormalTok{(}\StringTok{"Hello"}\NormalTok{),}
  \KeywordTok{textInput}\NormalTok{(}\StringTok{"text"}\NormalTok{, }\StringTok{"Text to show in alert"}\NormalTok{),}
  \KeywordTok{actionButton}\NormalTok{(}\StringTok{"submit"}\NormalTok{, }\StringTok{"Show alert"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session)\{}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{submit, \{}
\NormalTok{    session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"send{-}alert"}\NormalTok{, }\DataTypeTok{message =}\NormalTok{ input}\OperatorTok{$}\NormalTok{text)}
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

In the application above, notice the path that our message follows: it goes from the client to the server which sends it back to the client. This might be considered suboptimal by some as it is not necessary to use the server as intermediary (in this example at least). Though there is some truth to this the above will work perfectly fine---and our aim here is to make JavaScript work with R---not alongside it.

\hypertarget{from-javascript-to-r}{%
\section*{From JavaScript to R}\label{from-javascript-to-r}}


Imagine if you will that instead of displaying a somewhat anodyne alert it was one that actually mattered where the user is warned that clicking ``OK'' will execute an irreversible action like the deletion of a record. In order to implement this the server would need to ``know'' whether the user has clicked said ``OK'' button. To do so one needs to pass data from the client to the server.

This can be done by defining a new \emph{simplified} shiny input. While one can define a fully-fledged shiny input that can be registered, updated, etc. there is also a simplified version of the latter which allows sending reactive input value to the server where it can be used just like any other inputs (\texttt{input\$id}). The value of the input can be defined using the \texttt{setInputValue} method which takes the id of the input and the value to give it.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
  \StringTok{"Shiny.addCustomMessageHandler(type = \textquotesingle{}send{-}alert\textquotesingle{}, function(message) \{}
\StringTok{    }
\StringTok{    // show alert}
\StringTok{    alert(message);}

\StringTok{    // set to true when clicked OK}
\StringTok{    Shiny.setInputValue(\textquotesingle{}delete\_alert\textquotesingle{}, true);}
\StringTok{  \});"}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

As mentioned earlier \texttt{alert} blocks code execution, therefore the input value will not be defined before the button ``OK'' is pressed. The server can now access the \texttt{input\$delete\_alert} input which is by default \texttt{NULL} and set to \texttt{TRUE} when the user has pressed ``OK,'' as done in the application below which prints the input to the console when the button is clicked.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}

\NormalTok{ui <{-}}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
    \StringTok{"Shiny.addCustomMessageHandler(type = \textquotesingle{}send{-}alert\textquotesingle{}, function(message) \{}
\StringTok{      alert(message);}
\StringTok{      Shiny.setInputValue(\textquotesingle{}delete\_alert\textquotesingle{}, true);}
\StringTok{    \});"}
\NormalTok{  ),}
  \KeywordTok{h1}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session)\{}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"send{-}alert"}\NormalTok{, }\DataTypeTok{message =} \StringTok{"Deleting a record!"}\NormalTok{)}

  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{delete\_alert, \{}
    \CommentTok{\# print TRUE when button is clicked}
    \KeywordTok{print}\NormalTok{(input}\OperatorTok{$}\NormalTok{delete\_alert) }
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\hypertarget{external-library}{%
\section*{External Library}\label{external-library}}


Thus far this chapter has covered both ways data travels between JavaScript and R in Shiny. However, the alerts displayed in the previous sections are rather hideous and, though demonstrates how both languages can work together within shiny, comes short of illustrating how to make use of external libraries, which is frequently performed as one progressively learn a language.

Let's exploit an external library to improve upon the work done so far: \href{https://github.com/StephanWagner/jBox}{jBox} allows displaying modals (pop-ups), very similar to the vanilla JavaScript alerts, but much better looking and with additional functionalities.

The very first thing to do is to import jBox in our project, we could download the files and use them as described in the previous static files section but it comes with very convenient CDNs detailed in the \href{https://stephanwagner.me/jBox/get_started}{get-started page of the documentation}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<script}\OtherTok{ src=}\StringTok{"https://code.jquery.com/jquery{-}3.5.1.min.js"}\KeywordTok{></script>}
\KeywordTok{<script}\OtherTok{ src=}\StringTok{"https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/dist/jBox.all.min.js"}\KeywordTok{></script>}
\KeywordTok{<link}\OtherTok{ href=}\StringTok{"https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/dist/jBox.all.min.css"}\OtherTok{ rel=}\StringTok{"stylesheet"}\KeywordTok{>}
\end{Highlighting}
\end{Shaded}

Note that the ``j'' in jBox stands for jQuery which is already a dependency of shiny itself, there is therefore no need to import it, on the contrary one should not in order to avoid clashes. We can adapt the ui of the shiny application built up to this point to import the dependencies, keeping the handler, to obtain the code below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ui <{-}}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
      \DataTypeTok{src =} \StringTok{"https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/dist/jBox.all.min.js"}
\NormalTok{    ),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{link}\NormalTok{(}
      \DataTypeTok{rel =} \StringTok{"stylesheet"}\NormalTok{,}
      \DataTypeTok{href =} \StringTok{"https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/dist/jBox.all.min.css"}
\NormalTok{    ),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}\StringTok{"Shiny.addCustomMessageHandler(type = \textquotesingle{}send{-}alert\textquotesingle{}, function(message) \{}
\StringTok{      // TO DO: code jBox}
\StringTok{    \});"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The jBox library comes with numerous features to display tooltips, modals, notices, and more, which would make for too long a chapter; only notices shall be covered here. Further down the \href{https://stephanwagner.me/jBox/get_started\#notices}{get-started document} lies an example of a jBox notice.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{new} \AttributeTok{jBox}\NormalTok{(}\StringTok{\textquotesingle{}Notice\textquotesingle{}}\OperatorTok{,} \OperatorTok{\{}
  \DataTypeTok{content}\OperatorTok{:} \StringTok{\textquotesingle{}Hurray! A notice!\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{color}\OperatorTok{:} \StringTok{\textquotesingle{}blue\textquotesingle{}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Let us copy that in the placeholder of the shiny ui already put together.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}

\NormalTok{ui <{-}}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
      \DataTypeTok{src =} \StringTok{"https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/dist/jBox.all.min.js"}
\NormalTok{    ),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{link}\NormalTok{(}
      \DataTypeTok{rel =} \StringTok{"stylesheet"}\NormalTok{,}
      \DataTypeTok{href =} \StringTok{"https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/dist/jBox.all.min.css"}
\NormalTok{    ),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}\StringTok{"Shiny.addCustomMessageHandler(type = \textquotesingle{}send{-}alert\textquotesingle{}, function(message) \{}
\StringTok{      new jBox(\textquotesingle{}Notice\textquotesingle{}, \{}
\StringTok{        content: \textquotesingle{}Hurray! A notice!\textquotesingle{},}
\StringTok{        color: \textquotesingle{}blue\textquotesingle{}}
\StringTok{      \});}
\StringTok{    \});"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session)\{}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"send{-}alert"}\NormalTok{, }\DataTypeTok{message =} \StringTok{"Deleting a record!"}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\centering
\includegraphics{images/notice-1.png}
\caption{First jBox Notice}
\end{figure}

With some minor changes the application can display the message passed, one only needs to replace `Hurray! A notice!' with the \texttt{message} variable.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}\StringTok{"Shiny.addCustomMessageHandler(type = \textquotesingle{}send{-}alert\textquotesingle{}, function(message) \{}
\StringTok{  new jBox(\textquotesingle{}Notice\textquotesingle{}, \{}
\StringTok{    content: message,}
\StringTok{    color: \textquotesingle{}blue\textquotesingle{}}
\StringTok{  \});}
\StringTok{\});"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This though only allows passing a single variable, the message, to JavaScript but jBox has many more options.

\hypertarget{serialisation}{%
\section*{Serialisation}\label{serialisation}}


Let's delve deeper into the communication between the server and the front-end to understand how we can further customise the notice displayed, e.g.: change the colour.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
  \DataTypeTok{content}\OperatorTok{:} \StringTok{\textquotesingle{}Hurray! A notice!\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{color}\OperatorTok{:} \StringTok{\textquotesingle{}blue\textquotesingle{}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Notice that the jBox notice takes a JSON object containing the options that define said notice to display, including but not limited to the message. The most straightforward way to make all those options accessible to the server is to construct that list of options server-side before sending it to the the front-end. For instance the JSON of options displayed above would look like the R list below.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{content =} \StringTok{\textquotesingle{}Hurray! A notice!\textquotesingle{}}\NormalTok{,}
  \DataTypeTok{color =} \StringTok{\textquotesingle{}blue\textquotesingle{}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Therefore one could construct this list server-side and use it in jBox straight away, without any further processing from the client. Doing so means we can simplify the JavaScript to \texttt{new\ jBox(\textquotesingle{}Notice\textquotesingle{},\ message);} rather than use \texttt{message} within the JSON.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}

\NormalTok{ui <{-}}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
      \DataTypeTok{src =} \StringTok{"https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/dist/jBox.all.min.js"}
\NormalTok{    ),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{link}\NormalTok{(}
      \DataTypeTok{rel =} \StringTok{"stylesheet"}\NormalTok{,}
      \DataTypeTok{href =} \StringTok{"https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/dist/jBox.all.min.css"}
\NormalTok{    ),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}\StringTok{"Shiny.addCustomMessageHandler(type = \textquotesingle{}send{-}alert\textquotesingle{}, function(message) \{}
\StringTok{      // use notice send from the server}
\StringTok{      new jBox(\textquotesingle{}Notice\textquotesingle{}, message);}
\StringTok{    \});"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session)\{}

  \CommentTok{\# define notice options}
\NormalTok{  notice =}\StringTok{ }\KeywordTok{list}\NormalTok{(}
    \DataTypeTok{content =} \StringTok{\textquotesingle{}Hello from the server\textquotesingle{}}\NormalTok{,}
    \DataTypeTok{color =} \StringTok{\textquotesingle{}black\textquotesingle{}}
\NormalTok{  )}

  \CommentTok{\# send the notice}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"send{-}alert"}\NormalTok{, }\DataTypeTok{message =}\NormalTok{ notice)}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\centering
\includegraphics{images/notice-2.png}
\caption{Customised jBox Notice}
\end{figure}

This sets a solid basis to further integrate other functionalities of jBox.

\hypertarget{events-callbacks}{%
\section*{Events \& Callbacks}\label{events-callbacks}}


In the example of the vanilla JavaScript alert one could simply place a line of code after the \texttt{alert()} function in order to ``tell'' the server whether the button on the alert had been clicked. This was feasible because \texttt{alert} stops the execution of code, this is, however, rather uncommon in JavaScript. What is far more used are events and callback functions which are triggered upon an action is performed by the user (like the click of a button) or when other interesting things happen in the code. \href{https://stephanwagner.me/jBox/options\#events}{jBox provides numerous such events}: callback functions can be used when a modal is closed or when it is created for instance.

The concept of the callback function is not totally foreign to R albeit rarely used. Shiny comes with such functions, e.g.: \texttt{shiny::onStop}. This allows having a function be triggered when the application exits (useful to close database connections for instance).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{server <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output)\{}
\NormalTok{  shiny}\OperatorTok{::}\KeywordTok{onStop}\NormalTok{(}
    \CommentTok{\# callback function fired when app is closed}
    \ControlFlowTok{function}\NormalTok{()\{}
      \KeywordTok{cat}\NormalTok{(}\StringTok{"App has been closed"}\NormalTok{)}
\NormalTok{    \} }\ControlFlowTok{for}\NormalTok{ instance}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In jBox, these callback functions are included in the JSON of options, below the \texttt{onClose} event is fired when the notice is closed.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
  \DataTypeTok{content}\OperatorTok{:} \StringTok{\textquotesingle{}Alert!\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{onClose}\OperatorTok{:} \KeywordTok{function}\NormalTok{()}\OperatorTok{\{}
    \CommentTok{// Fired when closed }
    \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Alert is closed\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This raises one issue, one cannot truly serialise an object of type function (there are exceptions later in the book).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# try to serialise an R function}
\NormalTok{jsonlite}\OperatorTok{::}\KeywordTok{toJSON}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x)\{x }\OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## ["function (x) ","{","    x + 1","}"]
\end{verbatim}

One solution is to append the callback function to the object of options JavaScript-side.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}\StringTok{"Shiny.addCustomMessageHandler(type = \textquotesingle{}send{-}alert\textquotesingle{}, function(message) \{}
\StringTok{  // append callback}
\StringTok{  message.onClose = function()\{}
\StringTok{    Shiny.setInputValue(\textquotesingle{}alert\_close\textquotesingle{}, true);}
\StringTok{  \}}
\StringTok{  new jBox(\textquotesingle{}Notice\textquotesingle{}, message);}
\StringTok{\});"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Placing a function inside a JSON object is common in JavaScript, in contrast with R where though it works is rarely if ever done (outside of reference class/R6). The above JavaScript code to append the callback function could look something like the snippet below in R.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{message <{-}}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{content =} \StringTok{"hello"}\NormalTok{)}
\NormalTok{message}\OperatorTok{$}\NormalTok{onClose <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x)\{}
\NormalTok{  x }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{\}}

\NormalTok{message}\OperatorTok{$}\KeywordTok{onClose}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

That done it can be incorporated into the application built thus far. Something interesting could be done server-side but for the sake of this example we merely print the value of the input to the R console.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}

\NormalTok{ui <{-}}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
\NormalTok{  tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}
      \DataTypeTok{src =} \StringTok{"https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/dist/jBox.all.min.js"}
\NormalTok{    ),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{link}\NormalTok{(}
      \DataTypeTok{rel =} \StringTok{"stylesheet"}\NormalTok{,}
      \DataTypeTok{href =} \StringTok{"https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/dist/jBox.all.min.css"}
\NormalTok{    ),}
\NormalTok{    tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}\StringTok{"Shiny.addCustomMessageHandler(type = \textquotesingle{}send{-}alert\textquotesingle{}, function(message) \{}
\StringTok{      message.onClose = function()\{}
\StringTok{        Shiny.setInputValue(\textquotesingle{}alert\_close\textquotesingle{}, true);}
\StringTok{      \}}
\StringTok{      new jBox(\textquotesingle{}Notice\textquotesingle{}, message);}
\StringTok{    \});"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{server <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output, session)\{}

  \CommentTok{\# define notice options}
\NormalTok{  notice =}\StringTok{ }\KeywordTok{list}\NormalTok{(}
    \DataTypeTok{content =} \StringTok{\textquotesingle{}Hello from the server\textquotesingle{}}\NormalTok{,}
    \DataTypeTok{color =} \StringTok{\textquotesingle{}black\textquotesingle{}}
\NormalTok{  )}

  \CommentTok{\# send the notice}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"send{-}alert"}\NormalTok{, }\DataTypeTok{message =}\NormalTok{ notice)}

  \CommentTok{\# print the output of the alert\_close event (when fired)}
  \KeywordTok{observeEvent}\NormalTok{(input}\OperatorTok{$}\NormalTok{alert\_close, \{}
    \KeywordTok{print}\NormalTok{(input}\OperatorTok{$}\NormalTok{alert\_close)}
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

\hypertarget{as-a-package}{%
\section*{As a Package}\label{as-a-package}}


\emph{If confused by any of the following please visit the \href{package-development}{package development section} in the first chapter.}

Packages are a fundamental part of R and allow conveniently sharing and reusing code. The work done so far is probably fitting for a single application but one should not have to reproduce all of that every time one wants to use jBox in a shiny application: we ought to wrap these functionalities into a handy package that can be used, reused and shared with others. Moreover, this will benefit from all the other advantages that R packages bring to code such as documentation, reproducibility, and tests.

Before we delve into building the package let us think through what it should include. The application using jBox gives some indication as to what the package will look like. Users of the package should be able to reproduce what is executed in the application, namely import dependencies (including the message handler) as well as send data to the JavaScript front-end. Finally, we shall provide, with the package, a static directory of dependencies to avoid relying on the CDNs as this ensures reproducibility (code hosted online by third-party might change and break the package). Concretely, the package will export a \texttt{useJbox} function to be placed in the shiny ui to import the dependencies (essentially replacing the \texttt{tags\$*}) and a function to send the alert from the server to the client.

Let's start by creating an R package, here we name it ``jbox,'' after the JavaScript of the same name, partly because the author lacks creativity: feel free to name it however you want.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{usethis}\OperatorTok{::}\KeywordTok{create\_package}\NormalTok{(}\StringTok{"jbox"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{dependencies}{%
\subsection*{Dependencies}\label{dependencies}}


\emph{If confused by any of the following please visit the \protect\hyperlink{static-files}{static files section} of this chapter.}

The very first thing that is required are the dependencies without which nothing can work, let's create a directory of static assets, download and place the jBox CSS and JavaScript files within it. We create the directory ``inst'' as per the R package convention and within it create another to hold our assets.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# create directories}
\KeywordTok{dir.create}\NormalTok{(}\StringTok{"inst/assets"}\NormalTok{, }\DataTypeTok{recursive =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The jBox files can be downloaded from the CDN and placed within the directory that was created above. Moreover, we also create an empty JavaScript file that will eventually contain the custom JavaScript code that ``connects'' R to JavaScript.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# URLs of CDNs}
\NormalTok{js\_dep <{-}}\StringTok{ "https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/dist/jBox.all.min.js"}
\NormalTok{css\_dep <{-}}\StringTok{ "https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/dist/jBox.all.min.css"}

\CommentTok{\# download}
\KeywordTok{download.file}\NormalTok{(js\_dep, }\DataTypeTok{destfile =} \StringTok{"./inst/assets/jBox.all.min.js"}\NormalTok{)}
\KeywordTok{download.file}\NormalTok{(css\_dep, }\DataTypeTok{destfile =} \StringTok{"./inst/assets/jBox.all.min.css"}\NormalTok{)}

\CommentTok{\# create file to eventually hold custom JavaScript}
\KeywordTok{file.create}\NormalTok{(}\StringTok{"./inst/assets/custom.js"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This done one should obtain a directory that looks similar to the tree below (some files and folders omitted for brevity).

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{DESCRIPTION}
\ExtensionTok{R/}
\ExtensionTok{inst/}
\NormalTok{├── }\ExtensionTok{assets/}
\NormalTok{│    ├── }\ExtensionTok{jBox.all.min.js}
\NormalTok{│    └── }\ExtensionTok{jBox.all.min.css}
\end{Highlighting}
\end{Shaded}

Next, one needs to have those files served, the user of the package could be asked to use \texttt{shiny::addResourcePath} but it's very inelegant, this should be built-in the package so the user does not even have to know this happening in the background. Therefore, we ought to ensure the static files are served when the user uses the package. Packages can optionally run functions when it is loaded or attached, Hadley Wickham writes about it extensively in the namespace chapter of his \href{http://r-pkgs.had.co.nz/namespace.html}{book on R packages}. By convention, these functions are placed in a \texttt{zzz.R} file.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{file.create}\NormalTok{(}\StringTok{"./R/zzz.R"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The difference between loading and attaching a package can be subtle, in this case it's probably best to run the function when the package is loaded using \texttt{onLoad} which the R Packages book describes as:

\begin{quote}
Loading will load code, data and any DLLs; register S3 and S4 methods; and run the .onLoad() function. After loading, the package is available in memory, but because it's not in the search path, you won't be able to access its components without using ::. Confusingly, :: will also load a package automatically if it isn't already loaded. It's rare to load a package explicitly, but you can do so with requireNamespace() or loadNamespace().
\end{quote}

The \texttt{addResourcePath} function should thus be placed within the \texttt{.onLoad} function, this way the files are served by shiny when the package is loaded. Note the few changes below, we refer to the path using \texttt{system.file} (detailed in the \protect\hyperlink{package-development}{Package Development section}) and change the the prefix to \texttt{jbox-assets} to avoid the url serving our static files to clash with others.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# R/zzz.R}
\NormalTok{.onLoad <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(libname, pkgname) \{}
\NormalTok{  shiny}\OperatorTok{::}\KeywordTok{addResourcePath}\NormalTok{(}
    \StringTok{"jbox{-}assets"}\NormalTok{,}
    \KeywordTok{system.file}\NormalTok{(}\StringTok{"assets"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"jbox"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This serves the file and allows not having to explicitly use \texttt{addResourcePath} but the package nonetheless needs to feature a function to let the user import them into their application.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Import Dependencies}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{usejBox <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{()\{}
\NormalTok{  shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{head}\NormalTok{(}
\NormalTok{    shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}\DataTypeTok{src =} \StringTok{"jbox{-}assets/jBox.all.min.js"}\NormalTok{),}
\NormalTok{    shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{link}\NormalTok{(}\DataTypeTok{rel =} \StringTok{"stylesheet"}\NormalTok{, }\DataTypeTok{href =} \StringTok{"jbox{-}assets/jBox.all.min.css"}\NormalTok{),}
\NormalTok{    shiny}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{script}\NormalTok{(}\DataTypeTok{src =} \StringTok{"jbox{-}assets/custom.js"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Users of the package can place the function defined above in the UI of their application to import the dependencies.

\hypertarget{r-code}{%
\subsection*{R Code}\label{r-code}}


Not much changes from what was written before, however, it poses interesting questions with regard to the interface we want to provide users. From the user's perspective the core of the package is the function that actually sends an alert to the clients, here created in \texttt{R/core.R}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Create an Alert}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{send\_alert <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{content =} \StringTok{"alert"}\NormalTok{, }\DataTypeTok{color =} \StringTok{"blue"}\NormalTok{, session)\{}
  \CommentTok{\# define notice options}
\NormalTok{  notice =}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{content =}\NormalTok{ content, }\DataTypeTok{color =} \StringTok{"black"}\NormalTok{)}

  \CommentTok{\# send the notice}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"send{-}alert"}\NormalTok{, }\DataTypeTok{message =}\NormalTok{ notice)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

One could leave it at the function above, it could be sufficient in providing a functional R package. However one could improve somewhat on it, currently, the function requires the \texttt{session} object, which confuses many, most R developers, including I, have little understanding of it. This can be mitigated by providing a default using \texttt{shiny::getDefaultReactiveDomain} which, notwithstanding its grandiose name, simply returns the shiny \texttt{session}. This means that function has be run from a shiny server function but that is no limitation in this case.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Create an Alert}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{send\_alert <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{content =} \StringTok{"alert"}\NormalTok{, }\DataTypeTok{color =} \StringTok{"blue"}\NormalTok{, }\DataTypeTok{session =}\NormalTok{ shiny}\OperatorTok{::}\KeywordTok{getDefaultReactiveDomain}\NormalTok{())\{}
  \CommentTok{\# define notice options}
\NormalTok{  notice =}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{content =}\NormalTok{ content, }\DataTypeTok{color =} \StringTok{"black"}\NormalTok{)}

  \CommentTok{\# send the notice}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"send{-}alert"}\NormalTok{, }\DataTypeTok{message =}\NormalTok{ notice)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This covers most of the R code that needs to be written, though we will come back to it shortly on as we uncover an interesting caveat.

\hypertarget{javascript-code}{%
\subsection*{JavaScript Code}\label{javascript-code}}


Onto the JavaScript code, the \texttt{custom.js} to host said code is already created but remains empty. Simply using the code that was written previously will do the job for now.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// custom.js}
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(type }\OperatorTok{=} \StringTok{\textquotesingle{}send{-}alert\textquotesingle{}}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
  \VariableTok{message}\NormalTok{.}\AttributeTok{onClose} \OperatorTok{=} \KeywordTok{function}\NormalTok{()}\OperatorTok{\{}
    \VariableTok{Shiny}\NormalTok{.}\AttributeTok{setInputValue}\NormalTok{(}\StringTok{\textquotesingle{}alert\_close\textquotesingle{}}\OperatorTok{,} \KeywordTok{true}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
  \KeywordTok{new} \AttributeTok{jBox}\NormalTok{(}\StringTok{\textquotesingle{}Notice\textquotesingle{}}\OperatorTok{,}\NormalTok{ message)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{shortcoming}{%
\subsection*{Shortcoming}\label{shortcoming}}


At this stage one has a fully functional package: document, load the functions, and it can be used.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{document}\NormalTok{()}
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{load\_all}\NormalTok{()}

\KeywordTok{library}\NormalTok{(shiny)}

\NormalTok{ui <{-}}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \KeywordTok{usejBox}\NormalTok{(),}
  \KeywordTok{verbatimTextOutput}\NormalTok{(}\StringTok{"callback"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output)\{}
  \KeywordTok{send\_alert}\NormalTok{(}\StringTok{"Hello from the server!"}\NormalTok{)}

\NormalTok{  output}\OperatorTok{$}\NormalTok{callback <{-}}\StringTok{ }\KeywordTok{renderPrint}\NormalTok{(\{}
    \KeywordTok{paste}\NormalTok{(}\StringTok{"Is the alert closed: "}\NormalTok{, input}\OperatorTok{$}\NormalTok{alert\_close)}
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

However, while the above will work for a single alert it will run into issues when creating more than one alert as multiple alerts will set a value for a single input (\texttt{input\$alert\_close}). This is can be remedied to.

\hypertarget{input}{%
\subsection*{Input}\label{input}}


The package needs to provide the user a way to distinguish between alerts in order to be able to observe the correct inputs server-side.
A simple solution consists in asking the user to provide an identifier (\texttt{id}). This identifier must be passed to the JavaScript client so the function can dynamically set the input value for that identifier, therefore it is included in the \texttt{message}, below we do so in such a way that the original JSON of options remains unchanged.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\textquotesingle{} Create an Alert}
\CommentTok{\#\textquotesingle{} @export}
\NormalTok{send\_alert <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(id, }\DataTypeTok{content =} \StringTok{"alert"}\NormalTok{, }\DataTypeTok{color =} \StringTok{"blue"}\NormalTok{, }\DataTypeTok{session =}\NormalTok{ shiny}\OperatorTok{::}\KeywordTok{getDefaultReactiveDomain}\NormalTok{())\{}
  \CommentTok{\# define notice options}
\NormalTok{  notice =}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{content =}\NormalTok{ content, }\DataTypeTok{color =} \StringTok{"black"}\NormalTok{)}

  \CommentTok{\# add id}
\NormalTok{  message <{-}}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ id, }\DataTypeTok{notice =}\NormalTok{ notice)}

  \CommentTok{\# send the notice}
\NormalTok{  session}\OperatorTok{$}\KeywordTok{sendCustomMessage}\NormalTok{(}\DataTypeTok{type =} \StringTok{"send{-}alert"}\NormalTok{, }\DataTypeTok{message =}\NormalTok{ message)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now one can adapt the JavaScript code to make use of the identifier. One needs to include said identifier in the name of the input the value of which is set, below we concatenate before the original input name. This is not forced upon the developer but is a convention, packages like DT and plotly approach the issue the same way: \texttt{id\ +\ name\_of\_input}. The event is thus now appended to \texttt{message.notice}, which is also used when creating the jBox alert.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// custom.js}
\VariableTok{Shiny}\NormalTok{.}\AttributeTok{addCustomMessageHandler}\NormalTok{(type }\OperatorTok{=} \StringTok{\textquotesingle{}send{-}alert\textquotesingle{}}\OperatorTok{,} \KeywordTok{function}\NormalTok{(message) }\OperatorTok{\{}
  \VariableTok{message}\NormalTok{.}\VariableTok{notice}\NormalTok{.}\AttributeTok{onClose} \OperatorTok{=} \KeywordTok{function}\NormalTok{()}\OperatorTok{\{}
    \VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\StringTok{"close"}\NormalTok{)}\OperatorTok{;}
    \VariableTok{Shiny}\NormalTok{.}\AttributeTok{setInputValue}\NormalTok{(}\VariableTok{message}\NormalTok{.}\AttributeTok{id} \OperatorTok{+} \StringTok{\textquotesingle{}\_alert\_close\textquotesingle{}}\OperatorTok{,} \KeywordTok{true}\NormalTok{)}\OperatorTok{;}
  \OperatorTok{\}}
  \KeywordTok{new} \AttributeTok{jBox}\NormalTok{(}\StringTok{\textquotesingle{}Notice\textquotesingle{}}\OperatorTok{,} \VariableTok{message}\NormalTok{.}\AttributeTok{notice}\NormalTok{)}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{wrapping-up}{%
\subsection*{Wrapping up}\label{wrapping-up}}


Building and installing the package will now provide the user an interface demonstrated below.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(jbox)}
\KeywordTok{library}\NormalTok{(shiny)}

\NormalTok{ui <{-}}\StringTok{ }\KeywordTok{fluidPage}\NormalTok{(}
  \KeywordTok{usejBox}\NormalTok{(),}
  \KeywordTok{verbatimTextOutput}\NormalTok{(}\StringTok{"callback"}\NormalTok{)}
\NormalTok{)}

\NormalTok{server <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(input, output)\{}
  \KeywordTok{send\_alert}\NormalTok{(}\StringTok{"myid"}\NormalTok{, }\StringTok{"Hello from the server!"}\NormalTok{)}

\NormalTok{  output}\OperatorTok{$}\NormalTok{callback <{-}}\StringTok{ }\KeywordTok{renderPrint}\NormalTok{(\{}
    \KeywordTok{paste}\NormalTok{(}\StringTok{"Is the alert closed: "}\NormalTok{, input}\OperatorTok{$}\NormalTok{myid\_alert\_close)}
\NormalTok{  \})}
\NormalTok{\}}

\KeywordTok{shinyApp}\NormalTok{(ui, server)}
\end{Highlighting}
\end{Shaded}

It must be noted that though the package will be fully functional it will not pass any checks as documentation is poor and the DESCRIPTION incomplete. The API provided to the user is probably subpar in places, namely with the use of the id, which, unless the user needs to observe the respective input, is not necessary: forcing the user to provide it is not great design, consider making this optional.

\hypertarget{exercises}{%
\section*{Exercises}\label{exercises}}


If one wants to create such packages or make extensive use of such integrations with Shiny, it is greatly encouraged to explore it further, namely by improving the API constructed and extending the functionalities (jBox comes with much more than just alerts), even integrate a JavaScript of your choice. At the time of writing this there is not package providing integration with jBox, if that is not of interest to the reader below are some other great libraries that are yet to be packaged in R and would greatly benefit the R community:

\begin{itemize}
\tightlist
\item
  \href{https://github.com/Ghosh/micromodal}{micromodal.js} - tiny, dependency-free javascript library for creating accessible modal dialogs
\item
  \href{https://github.com/jaywcjlove/hotkeys}{hotkeys} - Capturing keyboard inputs
\item
  \href{https://github.com/victordibia/handtrack.js}{handtrack.js} - realtime hand detection
\item
  \href{https://github.com/skt-t1-byungi/rsup-progress}{Rsup-progress} - simple progress bars
\end{itemize}

\hypertarget{part-data-visualisation}{%
\part{Data Visualisation}\label{part-data-visualisation}}

\hypertarget{html-widgets}{%
\chapter{HTML widgets}\label{html-widgets}}

In this chapter we cover the integration of JavaScript with R using the htmlwidgets package, which focuses on libraries that produce a visual output, it is often used for data visualisation but is not limited to it.

As in previous chapters we mainly learn by example, building multiple widgets of increasing complexity as we progress through the chapter. Before writing the first widget, we explore JavaScript libraries that make great candidates for htmlwidgets and attempt to understand how they work to grasp what is expected from the developer in order to integrate them with R. Finally, we build up on the previous chapter to improve how HTML widgets work with shiny.

\hypertarget{candidate-libraries}{%
\section*{Candidate Libraries}\label{candidate-libraries}}


Before going down the rabbit hole it is good to take a look at the types of libraries one will work with. As htmlwidgets' main client are JavaScript visualisation libraries let us take a look at some such popular libraries and briefly look at how they work and what they have in common. This will greatly help conceptualise what one is trying to achieve in this chapter.

\hypertarget{plotly}{%
\subsection*{Plotly}\label{plotly}}


\href{https://plotly.com/javascript/}{Plotly.js} is probably one of the more popular out there, it provides over 40 fully customiseable chart types, many of which are very sophisticated. This is indeed the JavaScript library used by the R package of the same name: plotly.

Looking at the code presented in the ``Get Started'' guide reveals just how convenient the library is. One must import plotly, of course, then have a \texttt{\textless{}div\textgreater{}} where to visualisation will be placed, then, using \texttt{Plotly.newPlot}, create the actual visualisation by passing it first the element previously mentioned and a JSON of options.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{html}\DataTypeTok{>}
\KeywordTok{<html}\OtherTok{ xmlns=}\StringTok{"http://www.w3.org/1999/xhtml"}\OtherTok{ lang=}\StringTok{""}\OtherTok{ xml:lang=}\StringTok{""}\KeywordTok{>}

\KeywordTok{<head>}
  \CommentTok{<!{-}{-} Import library {-}{-}>}
  \KeywordTok{<script}\OtherTok{ src=}\StringTok{"plotly{-}latest.min.js"}\KeywordTok{></script>}
\KeywordTok{</head>}

\KeywordTok{<body>}
  \CommentTok{<!{-}{-} div to hold visualisation {-}{-}>}
  \KeywordTok{<div}\OtherTok{ id=}\StringTok{"chart"}\OtherTok{ style=}\StringTok{"width:600px;height:250px;"}\KeywordTok{></div>}

  \CommentTok{<!{-}{-} Script to create visualsiation {-}{-}>}
  \KeywordTok{<script>}
\NormalTok{    el }\OperatorTok{=} \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\StringTok{\textquotesingle{}chart\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
    \VariableTok{Plotly}\NormalTok{.}\AttributeTok{newPlot}\NormalTok{(el}\OperatorTok{,}\NormalTok{ [}\OperatorTok{\{}
      \DataTypeTok{x}\OperatorTok{:}\NormalTok{ [}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\NormalTok{]}\OperatorTok{,}
      \DataTypeTok{y}\OperatorTok{:}\NormalTok{ [}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{8}\OperatorTok{,} \DecValTok{16}\NormalTok{] }\OperatorTok{\}}\NormalTok{]}
\NormalTok{    )}\OperatorTok{;}
  \KeywordTok{</script>}
\KeywordTok{</body>}

\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

Now let's look at how another popular library does it.

\hypertarget{highchart.js}{%
\subsection*{Highchart.js}\label{highchart.js}}


\href{https://www.highcharts.com/}{Highcharts} is another library which allows creating gorgeous visualisation, maps, and more, it's also very popular albeit not being entirely open-source.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{html}\DataTypeTok{>}
\KeywordTok{<html}\OtherTok{ xmlns=}\StringTok{"http://www.w3.org/1999/xhtml"}\OtherTok{ lang=}\StringTok{""}\OtherTok{ xml:lang=}\StringTok{""}\KeywordTok{>}

\KeywordTok{<head>}
  \CommentTok{<!{-}{-} Import library {-}{-}>}
  \KeywordTok{<script}\OtherTok{ src=}\StringTok{"highcharts.js"}\KeywordTok{></script>}
\KeywordTok{</head>}

\KeywordTok{<body>}
  \CommentTok{<!{-}{-} div to hold visualisation {-}{-}>}
  \KeywordTok{<div}\OtherTok{ id=}\StringTok{"chart"}\OtherTok{ style=}\StringTok{"width:100\%; height:400px;"}\KeywordTok{></div>}

  \CommentTok{<!{-}{-} Script to create visualsiation {-}{-}>}
  \KeywordTok{<script>}
    \KeywordTok{var}\NormalTok{ myChart }\OperatorTok{=} \VariableTok{Highcharts}\NormalTok{.}\AttributeTok{chart}\NormalTok{(}\StringTok{\textquotesingle{}chart\textquotesingle{}}\OperatorTok{,} \OperatorTok{\{}
        \DataTypeTok{xAxis}\OperatorTok{:} \OperatorTok{\{}
            \DataTypeTok{categories}\OperatorTok{:}\NormalTok{ [}\StringTok{\textquotesingle{}Apples\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}Bananas\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}Oranges\textquotesingle{}}\NormalTok{]}
        \OperatorTok{\},}
        \DataTypeTok{series}\OperatorTok{:}\NormalTok{ [}\OperatorTok{\{}
            \DataTypeTok{name}\OperatorTok{:} \StringTok{\textquotesingle{}Jane\textquotesingle{}}\OperatorTok{,}
            \DataTypeTok{data}\OperatorTok{:}\NormalTok{ [}\DecValTok{1}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{4}\NormalTok{]}
        \OperatorTok{\},} \OperatorTok{\{}
            \DataTypeTok{name}\OperatorTok{:} \StringTok{\textquotesingle{}John\textquotesingle{}}\OperatorTok{,}
            \DataTypeTok{data}\OperatorTok{:}\NormalTok{ [}\DecValTok{5}\OperatorTok{,} \DecValTok{7}\OperatorTok{,} \DecValTok{3}\NormalTok{]}
        \OperatorTok{\}}\NormalTok{]}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \KeywordTok{</script>}
\KeywordTok{</body>}

\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

The above is very similar to what plotly.js requires: import libraries, create a \texttt{\textless{}div\textgreater{}} where to put the visualisation, and, to create the chart, run a function which also takes the id of the div where to place the chart and a JSON of options defining the actual chart, including the data.

\hypertarget{chart.js}{%
\subsection*{Chart.js}\label{chart.js}}


\href{https://www.chartjs.org/}{Chart.js} is yet another library which to draw standard charts popular for its permissive license and convenient API.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{html}\DataTypeTok{>}
\KeywordTok{<html}\OtherTok{ xmlns=}\StringTok{"http://www.w3.org/1999/xhtml"}\OtherTok{ lang=}\StringTok{""}\OtherTok{ xml:lang=}\StringTok{""}\KeywordTok{>}

\KeywordTok{<head>}
  \CommentTok{<!{-}{-} Import library {-}{-}>}
  \KeywordTok{<script}\OtherTok{ src=}\StringTok{"Chart.min.js"}\KeywordTok{></script>}
\KeywordTok{</head>}

\KeywordTok{<body>}
  \CommentTok{<!{-}{-} canvas to hold visualisation {-}{-}>}
  \KeywordTok{<canvas}\OtherTok{ id=}\StringTok{"chart"}\OtherTok{ width=}\StringTok{"400"}\OtherTok{ height=}\StringTok{"400"}\KeywordTok{></canvas>}

  \CommentTok{<!{-}{-} Script to create visualsiation {-}{-}>}
  \KeywordTok{<script>}
    \KeywordTok{var}\NormalTok{ el }\OperatorTok{=} \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\StringTok{\textquotesingle{}chart\textquotesingle{}}\NormalTok{).}\AttributeTok{getContext}\NormalTok{(}\StringTok{\textquotesingle{}2d\textquotesingle{}}\NormalTok{)}\OperatorTok{;}    
    \KeywordTok{var}\NormalTok{ myChart }\OperatorTok{=} \KeywordTok{new} \AttributeTok{Chart}\NormalTok{(el}\OperatorTok{,} \OperatorTok{\{}
      \DataTypeTok{type}\OperatorTok{:} \StringTok{\textquotesingle{}bar\textquotesingle{}}\OperatorTok{,}
      \DataTypeTok{data}\OperatorTok{:} \OperatorTok{\{}
        \DataTypeTok{labels}\OperatorTok{:}\NormalTok{ [}\StringTok{\textquotesingle{}Red\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}Blue\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}Yellow\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}Green\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}Purple\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}Orange\textquotesingle{}}\NormalTok{]}\OperatorTok{,}
        \DataTypeTok{datasets}\OperatorTok{:}\NormalTok{ [}\OperatorTok{\{}
          \DataTypeTok{label}\OperatorTok{:} \StringTok{\textquotesingle{}\# of Votes\textquotesingle{}}\OperatorTok{,}
          \DataTypeTok{data}\OperatorTok{:}\NormalTok{ [}\DecValTok{12}\OperatorTok{,} \DecValTok{19}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\NormalTok{]}
        \OperatorTok{\}}\NormalTok{]}
      \OperatorTok{\}}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \KeywordTok{</script>}
\KeywordTok{</body>}

\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

We again observe a very similar structure as with previous libraries. The library is imported, instead of a \texttt{div} chart.js uses a \texttt{canvas}, and the visualisation is also created from a single function which takes the canvas as first argument and a JSON of options as second.

Hopefully this reveals the repeating structure such libraries tend to follow and also hints at should be reproduced, to some extent at least, using R.

\hypertarget{how-it-works}{%
\section*{How it works}\label{how-it-works}}


Imagine there is no such package as HTML widgets to help create interactive visualisations from R: how would one attempt to go about it?

An interactive visualisation using JavaScript will will be contained within an HTML document, therefore it would probably have to be created first. Secondly, the visualisation that is yet to be created likely relies on external libraries, these would need to be imported in the document. The document should also include an HTML element (e.g.: \texttt{\textless{}div\textgreater{}}) to host said visualisation. Then data would have to be serialised in R and embedded into the document where it should be read by JavaScript code that uses it to create the visualisation. Finally all should be managed to work seamlessly across R markdown, shiny, and other settings.

Thankfully the htmlwidgets package is there to handle most of this. Nonetheless, it is important to understand that these operations are undertaken (to some degree) by htmlwidgets as it greatly helps use the package.

Must remember when building HTML widgets:

\begin{itemize}
\tightlist
\item
  Import dependencies
\item
  Create an html element to hold visualisation
\item
  Serialise R data to JSON
\item
  Handle JSON data to produce visualisation
\end{itemize}

\hypertarget{the-scaffold}{%
\section*{The Scaffold}\label{the-scaffold}}


With some vague understanding of how such widgets work internally one is ready to ``scaffold'' one with the aim of rummaging through its components to grasp a greater understanding of how such interactive outputs are actually produced. The way one sets up such a package is stunningly simple. Below we create a package named ``playground'' which will be used to mess around and explore. Though one could probably create widgets outside of an R package, it would only make things more complicated.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{create\_package}\NormalTok{(}\StringTok{"playground"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Then, from the root of the package created, we scaffold a widget which we call ``play''.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{htmlwidgets}\OperatorTok{::}\KeywordTok{scaffoldWidget}\NormalTok{(}\StringTok{"play"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This function puts together the minimalistic structure necessary to implement an HTML widget and opens \texttt{play.R}, \texttt{play.js} and \texttt{play.yaml} in the RStudio IDE or the default text editor. These files are named after the widget and will form the core of the package. The R file contains core functions of the R API, namely the \texttt{play} function which creates the widget itself, and the \texttt{render*} and \texttt{*output} functions that handle the widget in the shiny server and UI respectively. The \texttt{.js} file contains JavaScript functions that actually generate the visual output.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{document}\NormalTok{()}
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{load\_all}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

It might be hard to believe, but at this stage one already has a fully functioning widget ready to use after documenting, and building the package. Indeed, the \texttt{play.R} file that that was created contains a function named ``play'' ẁhich takes, amongst other arguments, a message.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{play}\NormalTok{(}\DataTypeTok{message =} \StringTok{"This is a widget!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\centering
\includegraphics{images/playground-1.png}
\caption{First HTML widget}
\end{figure}

This displays the message in the RStudio ``Viewer,'' or the your default browser which indicates that the function does indeed create an HTML output. One can use the the \includegraphics{images/open-in-browser.png} button located in the top right of the RStudio ``Viewer'' to open the message in web browser which can prove very useful to look under the hood of the widgets for debugging.

\hypertarget{the-output}{%
\section*{The Output}\label{the-output}}


With an out-of-the-box HTML widget package one can start exploring the internals to understand how it works. Let's start by retracing the path taken by the message written in R to its seemingly magical appearance in HTML. The \texttt{play} function previously used, takes the \texttt{message} wraps it into a list which is then used in \texttt{htmlwidgets::createWidget}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# forward options using x}
\NormalTok{x =}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{message =}\NormalTok{ message}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Wrapping a string in a list might seem unnecessary but one will eventually add variables when building a more complex widget, starting with a list makes it easier to add them later on.

To investigate the widget we should look under the hood; the source code of the created (and rendered) output can be accessed in different ways, 1) by right-clicking on the message displayed in the RStudio Viewer and selecting ``Inspect element,'' or 2) by opening the visualisation in your browser using the \includegraphics{images/open-in-browser.png} button located in the top right of the ``Viewer,'' and in the browser right clicking on the message to select ``Inspect.'' The latter is advised as web browsers such as Chrome or Firefox provide much friendlier interfaces for such functionalities as well as shortcuts to inspect or view the source code of a page.

Below is a part of the \texttt{\textless{}body\textgreater{}} of the output of \texttt{play("This\ is\ a\ widget!")} obtained with the method described in the previous paragraph.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<div}\OtherTok{ id=}\StringTok{"htmlwidget\_container"}\KeywordTok{>}
  \KeywordTok{<div}\OtherTok{ id=}\StringTok{"htmlwidget{-}c21cca0e76e520b46fc7"}\OtherTok{ style=}\StringTok{"width:960px;height:500px;"}\OtherTok{ class=}\StringTok{"play html{-}widget"}\KeywordTok{>}\NormalTok{This is a widget!}\KeywordTok{</div>}
\KeywordTok{</div>}
\KeywordTok{<script}\OtherTok{ type=}\StringTok{"application/json"}\OtherTok{ data{-}for=}\StringTok{"htmlwidget{-}c21cca0e76e520b46fc7"}\KeywordTok{>}\OperatorTok{\{}\StringTok{"x"}\OperatorTok{:\{}\StringTok{"message"}\OperatorTok{:}\StringTok{"This is a widget!"}\OperatorTok{\},}\StringTok{"evals"}\OperatorTok{:}\NormalTok{[]}\OperatorTok{,}\StringTok{"jsHooks"}\OperatorTok{:}\NormalTok{[]}\OperatorTok{\}}\KeywordTok{</script>}
\end{Highlighting}
\end{Shaded}

One thing the source code of the rendered output reveals is the element (\texttt{div}) created by the htmlwidgets package to hold the message (the class name is identical to that of the widget, \texttt{play}), as well as, below it, in the \texttt{\textless{}script\textgreater{}} tag, the JSON object which includes the \texttt{x} variable used in the \texttt{play} function. The \texttt{div} created bears a randomly generated \texttt{id} which one can define when creating the widget using the \texttt{elementId} argument.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# specify the id}
\KeywordTok{play}\NormalTok{(}\StringTok{"This is another widget"}\NormalTok{, }\DataTypeTok{elementId =} \StringTok{"myViz"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{<!{-}{-} div bears id specified in R {-}{-}>}
\KeywordTok{<div}\OtherTok{ id=}\StringTok{"myViz"}\OtherTok{ style=}\StringTok{"width:960px;height:500px;"}\OtherTok{ class=}\StringTok{"play html{-}widget"}\KeywordTok{>}\NormalTok{This is another widget}\KeywordTok{</div>}
\end{Highlighting}
\end{Shaded}

You will also notice that this affects the \texttt{script} tag below it, the \texttt{data-for} attribute of which is also set to ``myViz,'' this indicates that it is used to tie the JSON data to a \texttt{div}, essential for htmlwidgets to manage multiple visualisation in R markdown or Shiny for instance. Then again, this happens in the background without the developer (you) having to worry about it.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<script}\OtherTok{ type=}\StringTok{"application/json"}\OtherTok{ data{-}for=}\StringTok{"myViz"}\KeywordTok{>}\OperatorTok{\{}\StringTok{"x"}\OperatorTok{:\{}\StringTok{"message"}\OperatorTok{:}\StringTok{"This is a widget!"}\OperatorTok{\},}\StringTok{"evals"}\OperatorTok{:}\NormalTok{[]}\OperatorTok{,}\StringTok{"jsHooks"}\OperatorTok{:}\NormalTok{[]}\OperatorTok{\}}\KeywordTok{</script>}
\end{Highlighting}
\end{Shaded}

Inspecting the output also shows the dependencies imported, these are placed within the \texttt{head} HTML tags at the top of the page.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<script}\OtherTok{ src=}\StringTok{"lib/htmlwidgets{-}1.5.1/htmlwidgets.js"}\KeywordTok{></script>}
\KeywordTok{<script}\OtherTok{ src=}\StringTok{"lib/play{-}binding{-}0.0.0.9000/play.js"}\KeywordTok{></script>}
\end{Highlighting}
\end{Shaded}

This effectively imports the \texttt{htmlwidgets.js} library as well as the \texttt{play.js} file, and were the visualisation depending on external libraries they would appear alongside those. Peaking inside the \texttt{play.js} file located at \texttt{inst/htmlwidgets/play.js} reveals the code below we see:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// play.js}
\VariableTok{HTMLWidgets}\NormalTok{.}\AttributeTok{widget}\NormalTok{(}\OperatorTok{\{}

  \DataTypeTok{name}\OperatorTok{:} \StringTok{\textquotesingle{}play\textquotesingle{}}\OperatorTok{,}

  \DataTypeTok{type}\OperatorTok{:} \StringTok{\textquotesingle{}output\textquotesingle{}}\OperatorTok{,}

  \DataTypeTok{factory}\OperatorTok{:} \KeywordTok{function}\NormalTok{(el}\OperatorTok{,}\NormalTok{ width}\OperatorTok{,}\NormalTok{ height) }\OperatorTok{\{}

    \CommentTok{// }\AlertTok{TODO}\CommentTok{: define shared variables for this instance}

    \ControlFlowTok{return} \OperatorTok{\{}

      \DataTypeTok{renderValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(x) }\OperatorTok{\{}

        \CommentTok{// }\AlertTok{TODO}\CommentTok{: code to render the widget, e.g.}
        \VariableTok{el}\NormalTok{.}\AttributeTok{innerText} \OperatorTok{=} \VariableTok{x}\NormalTok{.}\AttributeTok{message}\OperatorTok{;}

      \OperatorTok{\},}

      \DataTypeTok{resize}\OperatorTok{:} \KeywordTok{function}\NormalTok{(width}\OperatorTok{,}\NormalTok{ height) }\OperatorTok{\{}

        \CommentTok{// }\AlertTok{TODO}\CommentTok{: code to re{-}render the widget with a new size}

      \OperatorTok{\}}

    \OperatorTok{\};}
  \OperatorTok{\}}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

However convoluted this may appear at first do not let that intimate you. The \texttt{factory} function returns two functions, one of which, \texttt{resize}, is currently empty, let's therefore look at the other one first, \texttt{renderValue}: the function that in fact renders the visualisation. It takes an object \texttt{x} from which is accesses the ``message'' variable that it uses as text for object \texttt{el} (\texttt{el.innerText}). The object \texttt{x} passed to this function is actually the list of the same name that was build in the R function \texttt{play}! While in R one would access the \texttt{message} in list \texttt{x} with \texttt{x\$message} in JavaScript to access the \texttt{message} in the JSON \texttt{x} one writes \texttt{x.message}, only changing the dollar sign to a dot. Let's show this perhaps more clearly by printing the content of \texttt{x}.

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(x)}\OperatorTok{;}
\VariableTok{el}\NormalTok{.}\AttributeTok{innerText} \OperatorTok{=} \VariableTok{x}\NormalTok{.}\AttributeTok{message}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

We place \texttt{console.log} to print the content of \texttt{x} in the console, reload the package with \texttt{devtools::load\_all} and use the function \texttt{play} again then explore the console from the browser (inspect and go to the ``console'' tab).

\begin{figure}
\centering
\includegraphics{images/playground-console-x.png}
\caption{Console tab output}
\end{figure}

This displays the JSON object containing the message: it looks eerily similar to the list that was created in R (\texttt{x\ =\ list(message\ =\ "This\ is\ a\ widget!")}). What one should take away from this is that data that needs to be communicated from R to the JavaScript function should be placed in the R list \texttt{x}. This list is serialised to JSON and placed in the HTML output in a \texttt{script} tag with a \texttt{data-for} attribute. This attribute indicates which widget the data is destined for. This effectively enables htmlwidgets to match the serialised data with the output elements: data in \texttt{\textless{}script\ data-for=\textquotesingle{}viz\textquotesingle{}\textgreater{}} is to be used to create a visualisation in \texttt{\textless{}div\ id=\textquotesingle{}viz\textquotesingle{}\textgreater{}}.

Before we move on to other things one should also grasp a better understanding of the \texttt{el} object, which can also be logged in the console.

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(x)}\OperatorTok{;}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(el)}\OperatorTok{;}
\VariableTok{el}\NormalTok{.}\AttributeTok{innerText} \OperatorTok{=} \VariableTok{x}\NormalTok{.}\AttributeTok{message}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\centering
\includegraphics{images/playground-console-el.png}
\caption{Console tab output}
\end{figure}

This displays the HTML element created by htmlwidgets that is meant to hold the visualisation, or in this case, the message. If you are familiar with JavaScript, this is the element that would be returned by \texttt{document.getElementById}. This object allows manipulating the element in pretty much any way imaginable, change its position, its colour, its size, or, as done here, to insert some text in its place. What's more one can access attributes of the object just like a JSON array. Therefore one can log the \texttt{id} of the element.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// print the id of the element}
\VariableTok{console}\NormalTok{.}\AttributeTok{log}\NormalTok{(}\VariableTok{el}\NormalTok{.}\AttributeTok{id}\NormalTok{)}\OperatorTok{;}
\VariableTok{el}\NormalTok{.}\AttributeTok{innerText} \OperatorTok{=} \VariableTok{x}\NormalTok{.}\AttributeTok{message}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Making the modifications above and reloading the package, one can create a widget given a specific id and see it displayed in the console, e.g.: \texttt{play("hello",\ elementId\ =\ "see-you-in-the-console")}.

In an attempt to become more at ease with this setup let us change something and play with the widget. Out-of-the-box htmlwidgets uses \texttt{innerText}, which does very much what it says on the tin, it places text inside an element. JavaScript comes with another function akin to \texttt{innerText}, \texttt{innerHTML}. While the former only allows inserting text the former lets one insert any HTML.

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{el}\NormalTok{.}\AttributeTok{innerHTML} \OperatorTok{=} \VariableTok{x}\NormalTok{.}\AttributeTok{message}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

After changing the \texttt{play.js} file as above, and re-loading the package, one can use arbitrary HTML as messages.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{play}\NormalTok{(}\StringTok{"<h1>Using HTML!</h1>"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\centering
\includegraphics{images/playground-h1.png}
\caption{Widget output}
\end{figure}

That makes for a great improvement which opens the door to many possibilities. However, the interface this provides is unintuitive. Albeit similar, R users are more familiar with shiny and htmltools \citep{R-htmltools} tags than HTML tags, e.g.: \texttt{\textless{}h1\textgreater{}\textless{}/h1\textgreater{}} translates to \texttt{h1()} in R. The package should allow users to use those instead of forcing them to collapse HTML content in a string. Fortunately, there is a very easy way to obtain the HTML from those functions: convert it to a character string.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{html <{-}}\StringTok{ }\NormalTok{shiny}\OperatorTok{::}\KeywordTok{h1}\NormalTok{(}\StringTok{"HTML tag"}\NormalTok{)}

\KeywordTok{class}\NormalTok{(html)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "shiny.tag"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# returns string}
\KeywordTok{as.character}\NormalTok{(html)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "<h1>HTML tag</h1>"
\end{verbatim}

Implementing this in the \texttt{play} function will look like this.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# forward options using x}
\NormalTok{x =}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{message =} \KeywordTok{as.character}\NormalTok{(message)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Reloading the package with \texttt{devtools::load\_all} lets one use shiny tags as the message.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{play}\NormalTok{(shiny}\OperatorTok{::}\KeywordTok{h2}\NormalTok{(}\StringTok{"Chocolate is a colour"}\NormalTok{, }\DataTypeTok{style =} \StringTok{"color:chocolate;"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\centering
\includegraphics{images/playground-color.png}
\caption{Using shiny tags}
\end{figure}

This hopefully provides some understanding of how htmlwidgets work internally and thereby helps building such packages. To recapitulate, an HTML document is created in which div is placed and given a certain id, this id is also used in a script tag that contains JSON data passed from R so that a JavaScript function we define can read that data in and use it to generate a visual output in a div. However, as much as this section covered, the topic of JavaScript dependencies was not touched, this is approached in the following section where we build another, more interesting widget, which uses an external dependency.

\hypertarget{typed.js}{%
\section*{Typed.js}\label{typed.js}}


In this section we build a package called \texttt{typed}, which wraps the JavaScript library of the same name, \href{https://github.com/mattboldt/typed.js/}{typed.js} that mimics text being typed. This builds upon many things we explored in the playground package.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{usethis}\OperatorTok{::}\KeywordTok{create\_package}\NormalTok{(}\StringTok{"typed"}\NormalTok{)}
\NormalTok{htmlwidgets}\OperatorTok{::}\KeywordTok{scaffoldWidget}\NormalTok{(}\StringTok{"typed"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

As done with candidate libraries, let's take a look at documentation of \href{https://github.com/mattboldt/typed.js/}{typed.js} to see how typed.js works.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{html}\DataTypeTok{>}
\KeywordTok{<html}\OtherTok{ xmlns=}\StringTok{"http://www.w3.org/1999/xhtml"}\OtherTok{ lang=}\StringTok{""}\OtherTok{ xml:lang=}\StringTok{""}\KeywordTok{>}

\KeywordTok{<head>}
  \CommentTok{<!{-}{-} Import library {-}{-}>}
  \KeywordTok{<script}\OtherTok{ src=}\StringTok{"typed.js"}\KeywordTok{></script>}
\KeywordTok{</head>}

\KeywordTok{<body>}
  \CommentTok{<!{-}{-} div to hold visualisation {-}{-}>}
  \KeywordTok{<div}\OtherTok{ class=}\StringTok{"element"}\KeywordTok{></div>}

  \CommentTok{<!{-}{-} Script to create visualsiation {-}{-}>}
  \KeywordTok{<script>}
    \KeywordTok{var}\NormalTok{ typed }\OperatorTok{=} \KeywordTok{new} \AttributeTok{Typed}\NormalTok{(}\StringTok{\textquotesingle{}.element\textquotesingle{}}\OperatorTok{,} \OperatorTok{\{}
      \DataTypeTok{strings}\OperatorTok{:}\NormalTok{ [}\StringTok{\textquotesingle{}First sentence.\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}And a second sentence.\textquotesingle{}}\NormalTok{]}
    \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
  \KeywordTok{</script>}
\KeywordTok{</body>}

\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

The code above is not very different from what was observed in other libraries: the library is imported, there is a \texttt{\textless{}div\textgreater{}} where the output will be generated, and a script which also takes a selector and a JSON of options.

\hypertarget{dependency}{%
\subsection*{Dependency}\label{dependency}}


Once the package created and the widget scaffold laid down we need to add the JavaScript dependency without which nothing can move forward. The \href{https://github.com/mattboldt/typed.js}{documentation in the README of typed.js} states that it can be imported like so.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<script}\OtherTok{ src=}\StringTok{"https://cdn.jsdelivr.net/npm/typed.js@2.0.11"}\KeywordTok{></script>}
\end{Highlighting}
\end{Shaded}

First, we will download the dependency, which consists of a single JavaScript file, instead of using the CDN as this ultimately makes the package more robust (more easily reproducible outputs and no requirement for internet connection). Below we place the dependency in a ``typed'' directory within the ``htmlwidgets'' folder.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{dir.create}\NormalTok{(}\StringTok{"./inst/htmlwidgets/typed"}\NormalTok{)}
\NormalTok{cdn <{-}}\StringTok{ "https://cdn.jsdelivr.net/npm/typed.js@2.0.11"}
\KeywordTok{download.file}\NormalTok{(cdn, }\StringTok{"./inst/htmlwidgets/typed/typed.min.js"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This produces a directory that looks like this:

\begin{verbatim}
.
├── DESCRIPTION
├── NAMESPACE
├── R
│   └── typed.R
└── inst
    └── htmlwidgets
        ├── typed
        │   └── typed.min.js
        ├── typed.js
        └── typed.yaml
\end{verbatim}

In htmlwidgets packages dependencies are specified in the \texttt{.yml} file located at \texttt{inst/htmlwidgets} which at first contains a commented template.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# (uncomment to add a dependency)}
\CommentTok{\# dependencies:}
\CommentTok{\#  {-} name:}
\CommentTok{\#    version:}
\CommentTok{\#    src:}
\CommentTok{\#    script:}
\CommentTok{\#    stylesheet:}
\end{Highlighting}
\end{Shaded}

Let's uncomment those lines as instructed at the top of the file and fill it in.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dependencies}\KeywordTok{:}
\AttributeTok{  }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{name}\KeywordTok{:}\AttributeTok{ typed.js}
\AttributeTok{    }\FunctionTok{version}\KeywordTok{:}\AttributeTok{ }\FloatTok{2.0.11}
\AttributeTok{    }\FunctionTok{src}\KeywordTok{:}\AttributeTok{ htmlwidgets/typed}
\AttributeTok{    }\FunctionTok{script}\KeywordTok{:}\AttributeTok{ typed.min.js}
\end{Highlighting}
\end{Shaded}

We remove the \texttt{stylesheet} entry as this package does not require any CSS files. The \texttt{src} specifies the path to the directory containing the scripts and stylesheets. This is akin to using the \texttt{system.file} function to return the full path to a file or directory within the package.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{load\_all}\NormalTok{()}
\KeywordTok{system.file}\NormalTok{(}\StringTok{"htmlwidgets/typed"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"typed"}\NormalTok{)                                         }
\CommentTok{\#> "/home/me/packages/typed/inst/htmlwidgets/typed"}
\end{Highlighting}
\end{Shaded}

We should verify that this is correct by using the one R function the package features and check the source code of the output to verify that the typed.js is indeed imported. We thus run \texttt{typed("test")}, open the output in the browser (\includegraphics{images/open-in-browser.png}) and look at the source code of the page (right click and select ``View page source''). At the top of the page one should see \texttt{typed.min.js} imported, click the link to ensure it correctly points to the dependency.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{html}\DataTypeTok{>}
\KeywordTok{<html>}
\KeywordTok{<head>}
\KeywordTok{<meta}\OtherTok{ charset=}\StringTok{"utf{-}8"}\KeywordTok{/>}
\KeywordTok{<style>}\NormalTok{body\{}\KeywordTok{background{-}color}\NormalTok{:}\ConstantTok{white}\OperatorTok{;}\NormalTok{\}}\KeywordTok{</style>}
\KeywordTok{<script}\OtherTok{ src=}\StringTok{"lib/htmlwidgets{-}1.5.1/htmlwidgets.js"}\KeywordTok{></script>}
\KeywordTok{<script}\OtherTok{ src=}\StringTok{"lib/typed.js{-}2.0.11/typed.min.js"}\KeywordTok{></script>}
\KeywordTok{<script}\OtherTok{ src=}\StringTok{"lib/typed{-}binding{-}0.0.0.9000/typed.js"}\KeywordTok{></script>}
\NormalTok{...}
\end{Highlighting}
\end{Shaded}

\hypertarget{javascript-1}{%
\subsection*{JavaScript}\label{javascript-1}}


On its \href{https://mattboldt.com/demos/typed-js/}{official website}, typed.js gives the following example. The JavaScript function \texttt{Typed} takes two arguments, first the selector, the element to hold the output, second a JSON of options to specify what is being typed and a myriad of other things.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ typed }\OperatorTok{=} \KeywordTok{new} \AttributeTok{Typed}\NormalTok{(}\StringTok{\textquotesingle{}.element\textquotesingle{}}\OperatorTok{,} \OperatorTok{\{}
  \DataTypeTok{strings}\OperatorTok{:}\NormalTok{ [}\StringTok{"First sentence."}\OperatorTok{,} \StringTok{"Second sentence."}\NormalTok{]}\OperatorTok{,}
  \DataTypeTok{typeSpeed}\OperatorTok{:} \DecValTok{30}
\OperatorTok{\}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Let's place it in the package by replacing the content of the \texttt{renderValue} in \texttt{typed.js} with the above.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{...}
\NormalTok{renderValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(x) }\OperatorTok{\{}

  \KeywordTok{var}\NormalTok{ typed }\OperatorTok{=} \KeywordTok{new} \AttributeTok{Typed}\NormalTok{(}\StringTok{\textquotesingle{}.element\textquotesingle{}}\OperatorTok{,} \OperatorTok{\{}
    \DataTypeTok{strings}\OperatorTok{:}\NormalTok{ [}\StringTok{"First sentence."}\OperatorTok{,} \StringTok{"Second sentence."}\NormalTok{]}\OperatorTok{,}
    \DataTypeTok{typeSpeed}\OperatorTok{:} \DecValTok{30}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

\OperatorTok{\}}
\NormalTok{...}
\end{Highlighting}
\end{Shaded}

One could be tempted to run \texttt{devtools::load\_all} but this will not work, namely because the function uses a selector that is will not return any object; it needs to be applied to the div created by the widget not \texttt{.element}. As hinted at in the playground, the selector of the element created is accessible from the \texttt{el} object. As a matter of fact, we did log in the browser console the id of the created div taken from \texttt{el.id}. Therefore concatenating the pound sign and the element id produces the select to said element. (\texttt{.class}, \texttt{\#id})

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// typed.js}
\NormalTok{...}
\NormalTok{renderValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(x) }\OperatorTok{\{}

  \KeywordTok{var}\NormalTok{ typed }\OperatorTok{=} \KeywordTok{new} \AttributeTok{Typed}\NormalTok{(}\StringTok{\textquotesingle{}\#\textquotesingle{}} \OperatorTok{+} \VariableTok{el}\NormalTok{.}\AttributeTok{id}\OperatorTok{,} \OperatorTok{\{}
    \DataTypeTok{strings}\OperatorTok{:}\NormalTok{ [}\StringTok{"First sentence."}\OperatorTok{,} \StringTok{"Second sentence."}\NormalTok{]}\OperatorTok{,}
    \DataTypeTok{typeSpeed}\OperatorTok{:} \DecValTok{30}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

\OperatorTok{\}}
\NormalTok{...}
\end{Highlighting}
\end{Shaded}

This should now work, run \texttt{devtools::load\_all} followed by \texttt{typed("whatever")} and the JavaScript animated text will appear! It's not of any use just yet as the options, included the text being typed is predefined: the package is currently not making any use the of the inputs passed from R. Below change the default strings to \texttt{x.message}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// typed.js}
\NormalTok{...}
\NormalTok{renderValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(x) }\OperatorTok{\{}

  \KeywordTok{var}\NormalTok{ typed }\OperatorTok{=} \KeywordTok{new} \AttributeTok{Typed}\NormalTok{(}\StringTok{\textquotesingle{}\#\textquotesingle{}} \OperatorTok{+} \VariableTok{el}\NormalTok{.}\AttributeTok{id}\OperatorTok{,} \OperatorTok{\{}
    \DataTypeTok{strings}\OperatorTok{:} \VariableTok{x}\NormalTok{.}\AttributeTok{message}\OperatorTok{,}
    \DataTypeTok{typeSpeed}\OperatorTok{:} \DecValTok{30}
  \OperatorTok{\}}\NormalTok{)}\OperatorTok{;}

\OperatorTok{\}}
\NormalTok{...}
\end{Highlighting}
\end{Shaded}

This, however, will cause issues as the \texttt{strings} options expects and array (vector) and not a single string. This is something often forgotten when working with R, there is no scalar values, in R a scalar is vector of length 1.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typed}\NormalTok{(}\StringTok{"does not work"}\NormalTok{) }\CommentTok{\# length =  1}
\KeywordTok{typed}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"This"}\NormalTok{, }\StringTok{"will"}\NormalTok{, }\StringTok{"work"}\NormalTok{)) }\CommentTok{\# length > 1}
\end{Highlighting}
\end{Shaded}

One solution is to force the input into a list.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# typed.R}
\NormalTok{x =}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{message =} \KeywordTok{as.list}\NormalTok{(message)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

At this juncture the package works but there is a salient issue with the way it handles options. Why build a list in R to reconstruct it in JavaScript manually. Since the options are serialised in R to JSON and that typed.js expects a JSON of options it is actually cleaner and more convenient to construct an R list that mirrors the JSON array so one can use is as-is in JavaScript.

In fact, renaming the \texttt{message} to \texttt{strings} effectively does this.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# typed.R}
\NormalTok{x =}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{strings =} \KeywordTok{as.list}\NormalTok{(message)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This allows greatly simplifying the code JavaScript side, making it much easier to add other options down the line, maintain, debug, and read.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// typed.js}
\NormalTok{...}
\NormalTok{renderValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(x) }\OperatorTok{\{}

  \KeywordTok{var}\NormalTok{ typed }\OperatorTok{=} \KeywordTok{new} \AttributeTok{Typed}\NormalTok{(}\StringTok{\textquotesingle{}\#\textquotesingle{}} \OperatorTok{+} \VariableTok{el}\NormalTok{.}\AttributeTok{id}\OperatorTok{,}\NormalTok{ x)}\OperatorTok{;}

\OperatorTok{\}}
\NormalTok{...}
\end{Highlighting}
\end{Shaded}

One can now add more options from the R code without having to alter any of the JavaScript. Let us demonstrate with the \texttt{loop} option.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{typed <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(message, }\DataTypeTok{loop =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{width =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{height =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{elementId =} \OtherTok{NULL}\NormalTok{) \{}

  \CommentTok{\# forward options using x}
\NormalTok{  x =}\StringTok{ }\KeywordTok{list}\NormalTok{(}
    \DataTypeTok{loop =}\NormalTok{ loop,}
    \DataTypeTok{strings =} \KeywordTok{as.list}\NormalTok{(message)}
\NormalTok{  )}

  \CommentTok{\# create widget}
\NormalTok{  htmlwidgets}\OperatorTok{::}\KeywordTok{createWidget}\NormalTok{(}
    \DataTypeTok{name =} \StringTok{\textquotesingle{}typed\textquotesingle{}}\NormalTok{,}
\NormalTok{    x,}
    \DataTypeTok{width =}\NormalTok{ width,}
    \DataTypeTok{height =}\NormalTok{ height,}
    \DataTypeTok{package =} \StringTok{\textquotesingle{}typed\textquotesingle{}}\NormalTok{,}
    \DataTypeTok{elementId =}\NormalTok{ elementId}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{html-element}{%
\subsection*{HTML Element}\label{html-element}}


As pointed out multiple times, the widget is generated in a \texttt{\textless{}div\textgreater{}}, which is works fine for most visualisation libraries. But we saw that chart.js requires placing it in a \texttt{\textless{}canvas\textgreater{}}, so one needs the ability to change that. It could be interesting to apply this to typed.js too as within a \texttt{\textless{}div\textgreater{}} it cannot be placed inline, using a \texttt{\textless{}span\textgreater{}}, however, this would work.

This can be changed by placing a function named \texttt{nameOfWidget\_html} which looked up by htmlwidgets and used if found. This function takes the three-dot construct \texttt{...} and uses them in an htmltools tag. The three-dots are necessary because internally htmlwidgets needs be able to pass arguments, such as the all too critical \texttt{id}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{typed\_html <{-}}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...)\{}
\NormalTok{  htmltools}\OperatorTok{::}\NormalTok{tags}\OperatorTok{$}\KeywordTok{span}\NormalTok{(...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-1}{%
\subsection*{Exercises}\label{exercises-1}}


The full list of which is available in the \href{https://github.com/mattboldt/typed.js/\#customization}{documentation of typed.js}. There are multiple ways to complete this package with regard to the options that are made available R-side and the API one wants to provide users of the package.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Keep adding arguments as done with \texttt{loop}
\item
  Use the three-dot construct (\texttt{...}) instead of adding arguments individually.
\item
  Provide other functions for additional options.
\end{enumerate}

It might be unclear how to implement the last point, this is something we'll explore in the following section.

\hypertarget{gio.js}{%
\section*{Gio.js}\label{gio.js}}


With a first widget built one can jump onto another one: \href{https://giojs.org/}{gio.js}, a library to draw arcs between countries on a 3 dimensional globe. This will include many more functionalities such packages can comprise.

\begin{figure}
\centering
\includegraphics{images/gio-example.png}
\caption{Example of Gio.js visualisation}
\end{figure}

Then again, the first order of business when looking to integrate a library is to look at the documentation to understand what is should be reproduced in R.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{<!DOCTYPE }\NormalTok{html}\DataTypeTok{>}
\KeywordTok{<html}\OtherTok{ xmlns=}\StringTok{"http://www.w3.org/1999/xhtml"}\OtherTok{ lang=}\StringTok{""}\OtherTok{ xml:lang=}\StringTok{""}\KeywordTok{>}

\KeywordTok{<head>}
  \CommentTok{<!{-}{-} Import libraries {-}{-}>}
  \KeywordTok{<script}\OtherTok{ src=}\StringTok{"three.min.js"}\KeywordTok{></script>}
  \KeywordTok{<script}\OtherTok{ src=}\StringTok{"gio.min.js"}\KeywordTok{></script>}
\KeywordTok{</head>}

\KeywordTok{<body>}
  \CommentTok{<!{-}{-} div to hold visualisation {-}{-}>}
  \KeywordTok{<div}\OtherTok{ id=}\StringTok{"globe"}\OtherTok{ style=}\StringTok{"width: 200px; height: 200px"}\KeywordTok{></div>}

  \CommentTok{<!{-}{-} Script to create visualsiation {-}{-}>}
  \KeywordTok{<script>}
    \KeywordTok{var}\NormalTok{ container }\OperatorTok{=} \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\StringTok{"globe"}\NormalTok{)}\OperatorTok{;}
    \KeywordTok{var}\NormalTok{ controller }\OperatorTok{=} \KeywordTok{new} \VariableTok{GIO}\NormalTok{.}\AttributeTok{Controller}\NormalTok{(container)}\OperatorTok{;}
    \VariableTok{controller}\NormalTok{.}\AttributeTok{addData}\NormalTok{(data)}\OperatorTok{;}
    \VariableTok{controller}\NormalTok{.}\AttributeTok{init}\NormalTok{()}\OperatorTok{;}
  \KeywordTok{</script>}
\KeywordTok{</body>}

\KeywordTok{</html>}
\end{Highlighting}
\end{Shaded}

Gio.js has itself a dependency, \href{https://threejs.org/}{three.js}, which needs to be imported before gio.js, other than that not much differs from libraries previously explored in this chapter.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{usethis}\OperatorTok{::}\KeywordTok{create\_package}\NormalTok{(}\StringTok{"gio"}\NormalTok{)}
\NormalTok{htmlwidgets}\OperatorTok{::}\KeywordTok{scaffoldWidget}\NormalTok{(}\StringTok{"gio"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{dependencies-1}{%
\subsection*{Dependencies}\label{dependencies-1}}


Handling the dependencies does differ much, we only need to download two libraries instead of one.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# create directories for JS dependencies}
\KeywordTok{dir.create}\NormalTok{(}\StringTok{"./inst/htmlwidgets/three"}\NormalTok{, }\DataTypeTok{recursive =} \OtherTok{TRUE}\NormalTok{)}
\KeywordTok{dir.create}\NormalTok{(}\StringTok{"./inst/htmlwidgets/gio"}\NormalTok{, }\DataTypeTok{recursive =} \OtherTok{TRUE}\NormalTok{)}

\CommentTok{\# download JS dependencies}
\NormalTok{three <{-}}\StringTok{ "https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"}
\NormalTok{gio <{-}}\StringTok{ "https://raw.githubusercontent.com/syt123450/giojs/master/build/gio.min.js"}

\KeywordTok{download.file}\NormalTok{(three, }\StringTok{"./inst/htmlwidgets/three/three.min.js"}\NormalTok{)}
\KeywordTok{download.file}\NormalTok{(gio, }\StringTok{"./inst/htmlwidgets/gio/gio.min.js"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This should produce the following working directory.

\begin{verbatim}
.
├── DESCRIPTION
├── NAMESPACE
├── R
│   └── gio.R
└── inst
    └── htmlwidgets
        ├── gio
        │   └── gio.min.js
        ├── gio.js
        ├── gio.yaml
        └── three
            └── three.min.js
\end{verbatim}

The libraries have been downloaded but the \texttt{gio.yml} file is yet to be edited. The order in which the libraries are listed matters; just as in HTML three.js needs to precede gio.js as the former depends on the latter and not vice versa.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dependencies}\KeywordTok{:}
\AttributeTok{  }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{name}\KeywordTok{:}\AttributeTok{ three}
\AttributeTok{    }\FunctionTok{version}\KeywordTok{:}\AttributeTok{ }\DecValTok{110}
\AttributeTok{    }\FunctionTok{src}\KeywordTok{:}\AttributeTok{ htmlwidgets/three}
\AttributeTok{    }\FunctionTok{script}\KeywordTok{:}\AttributeTok{ three.min.js}
\AttributeTok{  }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{name}\KeywordTok{:}\AttributeTok{ gio}
\AttributeTok{    }\FunctionTok{version}\KeywordTok{:}\AttributeTok{ }\FloatTok{2.0}
\AttributeTok{    }\FunctionTok{src}\KeywordTok{:}\AttributeTok{ htmlwidgets/gio}
\AttributeTok{    }\FunctionTok{script}\KeywordTok{:}\AttributeTok{ gio.min.js}
\end{Highlighting}
\end{Shaded}

\hypertarget{javascript-2}{%
\subsection*{JavaScript}\label{javascript-2}}


Let's copy the JavaScript code from the \href{https://giojs.org/index.html}{Get Started section of gio.js} in the \texttt{gio.js} file's \texttt{renderValue} function. At this point the data format is not known so we comment the line which adds data to the visualisation.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{...}
\NormalTok{renderValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(x) }\OperatorTok{\{}

  \KeywordTok{var}\NormalTok{ container }\OperatorTok{=} \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\StringTok{"globe"}\NormalTok{)}\OperatorTok{;}
  \KeywordTok{var}\NormalTok{ controller }\OperatorTok{=} \KeywordTok{new} \VariableTok{GIO}\NormalTok{.}\AttributeTok{Controller}\NormalTok{(container)}\OperatorTok{;}
  \CommentTok{//controller.addData(data);}
  \VariableTok{controller}\NormalTok{.}\AttributeTok{init}\NormalTok{()}\OperatorTok{;}

\OperatorTok{\}}
\NormalTok{...}
\end{Highlighting}
\end{Shaded}

One can document and load the package build it likely will not work as the code above attempts to place the visualisation in a \texttt{div} with \texttt{id\ =\ "globe"}. As for the previously written widget, this needs to be changed to \texttt{el.id} so the visualisation can correctly render in the HTML element generated by the widget.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{...}
\NormalTok{renderValue}\OperatorTok{:} \KeywordTok{function}\NormalTok{(x) }\OperatorTok{\{}

  \KeywordTok{var}\NormalTok{ container }\OperatorTok{=} \VariableTok{document}\NormalTok{.}\AttributeTok{getElementById}\NormalTok{(}\VariableTok{el}\NormalTok{.}\AttributeTok{id}\NormalTok{)}\OperatorTok{;}
  \KeywordTok{var}\NormalTok{ controller }\OperatorTok{=} \KeywordTok{new} \VariableTok{GIO}\NormalTok{.}\AttributeTok{Controller}\NormalTok{(container)}\OperatorTok{;}
  \CommentTok{//controller.addData(data);}
  \VariableTok{controller}\NormalTok{.}\AttributeTok{init}\NormalTok{()}\OperatorTok{;}

\OperatorTok{\}}
\NormalTok{...}
\end{Highlighting}
\end{Shaded}

At this stage the widget should generate a visualisation.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{document}\NormalTok{()}
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{load\_all}\NormalTok{()}
\KeywordTok{gio}\NormalTok{(}\DataTypeTok{message =} \StringTok{"This required but not used"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\centering
\includegraphics{images/gio-init.png}
\caption{Output without data}
\end{figure}

Not too shabby!

\hypertarget{adding-data}{%
\subsection*{Adding Data}\label{adding-data}}


  \bibliography{book.bib,packages.bib}

\backmatter
\printindex

\end{document}
