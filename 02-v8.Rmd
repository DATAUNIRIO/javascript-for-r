# (PART) JavaScript for Computations {-}

# The V8 Engine

V8 is an R interface to Google's open source JavaScript engine of the same name, it powers Google Chrome, node.js and many other things. It is the first integration of JavaScript with R that we cover in this book. Both the V8 package and the engine it wraps are simple yet amazingly powerful.

## Installation {-}

First install the V8 engine itself, instructions to do so are well detailed on [V8's README](https://github.com/jeroen/v8#installation) and below.

On Debian or Ubuntu use the code below from the terminal to install [libv8](https://v8.dev/).

```bash
sudo apt-get install -y libv8-dev
```

On Centos install v8-devel, which requires the EPEL tools.

```bash
sudo yum install epel-release
sudo yum install v8-devel
```

On Mac OS use [Homebrew](https://brew.sh/).

```bash
brew install v8
```

Then install the R package from CRAN.

```r
install.packages("V8")
```

## Basics {-}

V8 provides a reference class via [R6](https://github.com/r-lib/R6) [@R-R6], which pertains to object-oriented programming, hence it might look unconventional to many R users. It's nonetheless easy to grasp. If one wants to learn more about the R6's reference class system Hadley Wickham has a very good chapter on it in his [Advanced R](https://adv-r.hadley.nz/r6.html) book.

Let's explore the basic functionalities of the package. First, load the library and use the function `v8` to instantiate a class.

```{r v8-baisc-load}
library(V8)

engine <- v8()
```

The `eval` method allows running JavaScript code from R and retrive the results.

```{r}
engine$eval("var x = 3 + 4;") # this is evealuated in R
engine$eval("x")
```

Two observations on the above snippet of code. First, the variable we got back in R is a character vector when it should have been either an integer or a numeric. This is because we used the `eval` method which merely prints the output, `get` is more appropriate; it converts it to an appropriate R equivalent.

```{r}
# retrieve our previously created variable
(x <- engine$get("x"))
class(x)
```

Second, while creating a scalar with `eval("var x = 1;")` appears painless, imagine if you will the horror of having to convert a data frame to a JavaScript array via jsonlite then flatten it to character string so it can be used with the `eval` method. Horrid. Thankfully V8 comes with a method `assign`, complimentary to `get`,  which declares R objects as JavaScript variables. It takes two arguments, first the name of the variable to create, second the object to assign to it.

```{r}
# assign and retrieve a data.frame
engine$assign("vehicles", cars[1:3, ])
engine$get("vehicles")
```

All of the conversion is handled by V8 internally with jsonlite as demonstrated in the previous chapter. We can confirm that the data frame was converted to a list rowwise; using `JSON.stringify` to display how the object is store in V8.

```{r}
cat(engine$eval("JSON.stringify(vehicles, null, 2);"))
```

However the cyclical loop of 1) creating a variable in JavaScript to 2) run a function on the aforementioned object 3) get the results back in R, can be tedious. So V8 also allows calling JavaScript functions on R objects directly with the `call` method and obtain the results back in R. 

```{r}
engine$eval("new Date();") # using eval
engine$call("Date", Sys.Date()) # using call
```

Finally, one can run code interactively rather than as strings by calling the console from the engine with `engine$console()` you can then exit the console by typing `exit` or hitting the <kbd>ESC</kbd> key.

## External Libraries {-}

V8 is actually quite bare in and of itself, there is for instance no functionalities built-in to read or write files from disk, it thus becomes truly interesting when you can use it JavaScript libraries. We do so with the `source` method which takes a `file` argument that will accept a path or URL to a JavaScript file to source. We'll demonstrate this using [fuse.js](https://fusejs.io/) a fuzzy-search library. 

```{r v8-load-fuse}
engine$source("https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.4.6/fuse.min.js")
```

You can think of it as using the `script` tag in HTML to source (`src`) said file from disk or CDN.

```html
<html>
  <head>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.4.6/fuse.min.js'></script>
  </head>
  <body>
    <p>Content</p>
  </body>
</html>
```

With the library imported we can use its functionalities. We'll replicate an example from fuse.js official website where it executes a search on an object that contains books and looks like JSON below.

```js
var books = [{
  'ISBN': 'A',
  'title': "Old Man's War",
  'author': 'John Scalzi'
}, {
  'ISBN': 'B',
  'title': 'The Lock Artist',
  'author': 'Steve Hamilton'
}]
```

This can be easily created, as we've already seen this is just how V8 creates data frames. We define a data.frame of books that looks similar and load it into our engine.

```{r}
books <- data.frame(
  title = c(
    "Rights of Man",
    "Black Swan",
    "Common Sense",
    "Sense and Sensibility"
  ),
  id = c("a", "b", "c", "d")
)

engine$assign("books", books)
```

Then again we can make sure that the data.frame was turned into a rowwise JSON object.

```{r}
cat(engine$eval("JSON.stringify(books, null, 2);"))
```

Now we can define options for our search, we don't get into the details of fuse.js here as this is not the purpose of this book, you can read more about the options in the [examples section](https://fusejs.io/#Examples) of the site. We can mimic the format of the JSON options shown on the website with a simple list and assign that to our engine. If this confuses read the [JSON section of the introduction](intro.html#json).

```js
// JavaScript
var options = {
  keys: ['title'],
  id: 'id'
}
```

```{r}
# R
options <- list(
  keys = list("title"),
  id = "id"
)

engine$assign("options", options)
```

Then we can finish the second step of the online examples, instantiate a fuse.js object with our books and options objects then make a simple search, we assign the results of the search to an object which we then retrieve in R with `get`.

```{r}
engine$eval("var fuse = new Fuse(books, options)")
engine$eval("var results = fuse.search('sense')")
engine$get("results")
```

A search for "sense" returns a vector of ids where the term "sense" was found; `c` and `d` or the books Common Sense, Sense and Sensibility. We could perhaps make that last code simpler using the `call` method.

```{r}
engine$call("fuse.search", "sense")
```

## With Npm {-}

We can also use [npm](https://www.npmjs.com/) packages, though not all will work. Npm is Node's Package Manager, or in a sense Node's equivalent of CRAN.

To use npm packages we need [browserify](http://browserify.org/), a node library to bundle all dependencies of an npm package into a single, file which we can subsequently source in V8. Browserify is itself an npm package and there requires node and npm installed.

You can install browserify globally with the following command from the terminal.

```bash
npm install -g browserify
```

We can now browserify an npm package. To demonstrate we will use [ms](https://github.com/zeit/ms) which converts various time formats to milliseconds. First we install the package.

```bash
npm install ms
```

Then we browserify it. The first line creates a file called `in.js` which contains `global.ms = require('ms');` we then call browserify on that file specifying `ms.js` as output file.

```bash
echo "global.ms = require('ms');" > in.js
browserify in.js -o ms.js
```

We can now source `ms.js` with v8.

```{r, results='hide'}
library(V8)

ms <- v8()
ms$source("ms.js")
```

Then use the library.

```{r}
ms$eval("ms('2 days')")
ms$eval("ms('1y')")
```

## Use in Packages {-}

In this section we detail how one should go about using V8 in an R package, if you are not familiar with package development you can skip ahead. 

Create a package however you usually do, using usethis, devtools or the RStudio IDE interface. Below we create a package called "ms" that will hold functionalities we explored in the previous section on npm packages.

```bash
R -e "usethis::create_package('ms')"
cd ./ms
```

The package is going to rely on V8 so you can add it under `Imports` in the `DESCRIPTION`. We are going to need to instantiate the class at some point (`engine <- v8()`). 

One could perhaps require the user to do create such an object but it would not be convenient. Instead we can use `.onLoad`. You can read more about this function Hadley Wickham's [Advanced R book](http://r-pkgs.had.co.nz/r.html). The Python integration of R, [reticulate](https://rstudio.github.io/reticulate) [@R-reticulate] also advises [this method](https://rstudio.github.io/reticulate/articles/package.html) to import modules too. We often see this function placed in a `zzz.R` file.

```r
# zzz.R
ms <- NULL

.onLoad <- function(libname, pkgname){
  ms <<- v8()
}
```

Our package should also include the external library `ms.js` we built from the npm package. We should place it in the `inst` directory. Create it and place the `ms.js` file within the latter.

```bash
mkdir -p inst
```

This should give a directory similar to this, for brevity we exclude `DESCRIPTION`, `NAMESPACE`, and other files that make up a package.

```bash
R/
| zzz.R
inst/
| -- ms.js
```

Now the dependency can be sourced in the `.onLoad` function. We can access the files in the `inst` directory with the `system.file` function. When using the `.onLoad` function it is good practice to clean up with `.onUnload`.

```r
# zzz.R
ms <- NULL

.onLoad <- function(libname, pkgname){
  ms <<- V8::v8()

  dep <- system.file("ms.js", package = "ms")
  ms$source(dep)
}

.onUnload <- function(libpath){
  ms$reset()
}
```

We can then create a `to_ms` function, it will have access the `ms` object we instantiated in `.onLoad`.

```{r}
#' Convert To Millisecond
#' 
#' Convert to milliseconds to various formats.
#' 
#' @param string String to convert.
#' 
#' @export
to_ms <- function(string){
  ms$call("ms", string)
}
```

After running `devtools::document()` and `devtools::load_all()` the call `to_ms("2 days")` will return `172800000`. Finally,, remember to add V8 as dependency.

```r
usethis::use_package("V8")
```
