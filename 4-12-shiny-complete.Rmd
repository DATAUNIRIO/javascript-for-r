# A Complete Integration {#shiny-complete}

Thus far, this part of the book has covered both ways data travels between JavaScript and R in Shiny. However, the alerts displayed in the previous chapter are rather hideous and, though demonstrates how both languages can work together within shiny, comes short of illustrating how to make use of external libraries, how to package such code, and fails to introduces some very nice features. In brief, the previous chapter is an interesting exercise but unlikely to be used in the real world while this chapter makes for a more compelling example.

We shall introduce a rather fascinating JavaScript library that enables machine learning models in web browsers: [ml5.js](https://learn.ml5js.org/). The library is very extensive and includes a multitude of models to deal with sound, image, text, and more. In this chapter one of those models is implemented, an image classifier using [mobileNet](https://arxiv.org/abs/1704.04861) but the method shown can be extended to include any other model.

This is not a gimmick, running a model this way means it runs in the client (web browsers), and not on the shiny server leaving it free to compute anything else and serve other concurrent users. It's blazingly fast, it's unfortunate that JavaScript is often thought to be slow, on the contrary. Finally, it's simple, the JavaScript API provided is dead simple, it's impressive how ml5.js exposes complex models with such a simple API.

We start by exploring ml5.js, then plan the shiny application that will make use of it, and finally we wrap our work in the form of an R package.

## Discover {#shiny-complete-discover}

As for all projects that involve external libraries, the very first thing to do is to scan the documentation to understand how it is used. The documentation of ml5.js is exemplary, filled with examples and crystal clear, [it gives the following example](https://learn.ml5js.org/#/reference/image-classifier) for the image classifier. 

```js
// Initialize the Image Classifier method with MobileNet
const classifier = ml5.imageClassifier('MobileNet', modelLoaded);

// When the model is loaded
function modelLoaded() {
  console.log('Model Loaded!');
}

// Make a prediction with a selected image
classifier.classify(document.getElementById('image'), (err, results) => {
  console.log(results);
});
```

First, the image classifier is initialised from the `ml5` object with the `imageClassifier` method. This method takes two arguments, the name of the pre-trained model to use (`MobileNet`) and a callback function that is run when the model is loaded. The the `classify` method from the `classifier` is used with, again, two arguments: 1) the DOM element that contains the image (`<img />`) and a callback function.

Now we can jump to the next section to think how this can be implemented in Shiny.

## Setup {#shiny-complete-setup}

In shiny, we would provide a dropdown menu to choose from pre-selected images and upon selection the server renders the selected image, the model then runs and then sends the results to the R server which prints them in the UI.

```{r, echo=FALSE}
DiagrammeR::grViz("
digraph {

  graph [rankdir = LR]

  subgraph cluster_0 {
    node [shape=box]
    select [label='selectInput(img)']
    btn [label='actionButton(classify)']
    img [label='<img>']
    res[label='textOutput(results)']
    model[label='classify()']
    color=gold
  }

  subgraph cluster_1 {
    node [shape=box]
    renderImg[label='renderUI()']
    renderResults[label='renderPrint()']
    obs [label='observeEvent(classify)']
    label = 'Server'
    color=royalBlue
  }

  select -> renderImg
  renderImg -> img
  btn -> obs
  obs -> model
  img -> model
  model -> renderResults
  renderResults -> res

}
", width="100%", height=450)
```

This makes for what is probably a signature of shiny: a huge amount of bi-directional communication between the server and client as shiny makes the most of the websocket. Some of the readers with more advanced knowledge in JavaScript will find ways to avoid the use of the server in places to do more in the client, either way works.

## Dependencies {#shiny-complete-dependencies}

The ml5.js framework and all its components are bundled in a single JavaScript file.

```html
<script src="https://unpkg.com/ml5@0.4.3/dist/ml5.min.js"></script>
```

We will create an `html_dependency` object using the `htmlDependency` function from the `htmltools` package. If confused, go back to the first part of the book on shiny prerequisites where it is explained in greater detail. We have two options at our disposal, either used the CDN (as shown in the previous code chunk), or download the file. We will start by making use of the CDN, later when we build a package for this functionality we shall download it to provide the users of the package a choice between using the local file or the CDN.

```{r}
dependency <- htmltools::htmlDependency(
  name = "ml5",
  version = "0.4.3",
  src = "https://unpkg.com/ml5@0.4.3/dist/",
  script = "ml5.min.js"
)
```

## Images



Let's exploit an external library to improve upon the work done so far: [jBox](https://github.com/StephanWagner/jBox) allows displaying "notices," similar to the vanilla JavaScript alerts, but much better looking and with additional functionalities.

The very first thing to do is to import jBox in the project, we could download the files and use them as described in the previous static files section but it comes with very convenient CDNs detailed in the [get-started page](https://stephanwagner.me/jBox/get_started) of the documentation. 

```html
<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/dist/jBox.all.min.js"></script>
<link href="https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/dist/jBox.all.min.css" rel="stylesheet">
```

Note that the "j" in jBox stands for jQuery which is already a dependency of shiny itself, there is therefore no need to import it, on the contrary one should not in order to avoid clashes. We can import the dependencies in a shiny UI, along with a message handler.

```r
ui <- fluidPage(
  tags$head(
    tags$script(
      src = paste0(
        "https://cdn.jsdelivr.net/gh/StephanWagner/",
        "jBox@v1.2.0/dist/jBox.all.min.js"
      )
    ),
    tags$link(
      rel = "stylesheet",
      href = paste0(
        "https://cdn.jsdelivr.net/gh/StephanWagner/",
        "jBox@v1.2.0/dist/jBox.all.min.css"
      )
    ),
    tags$script("Shiny.addCustomMessageHandler(
      type = 'send-alert', function(message) {
      // TO DO: code jBox
    });")
  )
)
```

The jBox library comes with numerous features to display tooltips, modals, notices, and more, which would make for too long a chapter; only notices shall be covered here. Let's first take a look at the code that generates a jBox notice.

```js
new jBox('Notice', {
  content: 'Hurray! A notice!',
  color: 'blue'
});
```

Let's start by copying that in the message handler to observe what it looks like.

```r
library(shiny)

ui <- fluidPage(
  tags$head(
    tags$script(
      src = paste0(
        "https://cdn.jsdelivr.net/gh/StephanWagner/",
        "jBox@v1.2.0/dist/jBox.all.min.js"
      )
    ),
    tags$link(
      rel = "stylesheet",
      href = paste0(
        "https://cdn.jsdelivr.net/gh/StephanWagner/",
        "jBox@v1.2.0/dist/jBox.all.min.css"
      )
    ),
    tags$script("Shiny.addCustomMessageHandler(
      type = 'send-alert', function(message) {
        new jBox('Notice', {
          content: 'Hurray! A notice!',
          color: 'blue'
        });
    });")
  )
)

server <- function(input, output, session){
  session$sendCustomMessage(
    type = "send-alert", message = "This is not used"
  )
}

shinyApp(ui, server)
```

![First jBox Notice](images/notice-1.png)

With some minor changes the application can display the message passed, one only needs to replace 'Hurray! A notice!' with the `message` variable.

```r
tags$script("Shiny.addCustomMessageHandler(
  type = 'send-alert', function(message) {
    new jBox('Notice', {
      content: message,
      color: 'blue'
    });
});")
```

This though only allows passing a single variable, the message, to JavaScript but jBox has many more options.

## Serialisation {#shiny-complete-serialise}

Let's delve deeper into the communication between the server and the front-end to understand how we can further customise the notice displayed, e.g.: change the colour.

```js
{
  content: 'Hurray! A notice!',
  color: 'blue'
}
```

Notice that the jBox notice takes a JSON object containing the options that define said notice to display (example above), including but not limited to the message. The most straightforward way to make all those options accessible to the server is to construct that list of options server-side before sending it to the the front-end. For instance the JSON of options displayed above would look like the R list below.

```{r}
options <- list(
  content = 'Hurray! A notice!',
  color = 'blue'
)

jsonlite::toJSON(options, pretty = TRUE, auto_unbox = TRUE)
```

Therefore one could construct this list server-side and use it in jBox straight away, doing so means the JavaScript code can be simplified to `new jBox('Notice', message);`.

```r
library(shiny)

ui <- fluidPage(
  tags$head(
    tags$script(
      src = paste0(
        "https://cdn.jsdelivr.net/gh/StephanWagner/",
        "jBox@v1.2.0/dist/jBox.all.min.js"
      )
    ),
    tags$link(
      rel = "stylesheet",
      href = paste0(
        "https://cdn.jsdelivr.net/gh/StephanWagner/",
        "jBox@v1.2.0/dist/jBox.all.min.css"
      )
    ),
    tags$script("Shiny.addCustomMessageHandler(
      type = 'send-alert', function(message) {
        // use notice send from the server
        new jBox('Notice', message);
    });")
  )
)

server <- function(input, output, session){

  # define notice options
  notice = list(
    content = 'Hello from the server',
    color = 'black'
  )

  # send the notice
  session$sendCustomMessage(type = "send-alert", message = notice)
}

shinyApp(ui, server)
```

![Customised jBox Notice](images/notice-2.png)

## Events & Callbacks {#shiny-complete-events}

In the example of the vanilla JavaScript alert one could simply place a line of code after the `alert()` function in order to "tell" the server whether the button on the alert had been clicked. This was feasible because `alert` stops code execution, this is, however, rather uncommon in JavaScript. What is far more common are events and callback functions which are triggered upon an action being performed by the user (like the click of a button) or when other interesting things happen in the code. jBox provides numerous such [events](https://stephanwagner.me/jBox/options#events); callback functions can be used when a modal is closed or when a notice is created for instance.

The concept of the callback function is not totally foreign to R albeit rarely used. Shiny comes with such functions, `shiny::onStop` and `shiny::onStart`. These allows having functions run when the application starts or exits.

```r
server <- function(input, output){
  shiny::onStop(
    # callback function fired when app is closed
    function(){
      cat("App has been closed")
    }
  )
}
```

In jBox, these callback functions are included in the JSON of options, below the `onClose` event is fired when the notice is closed.

```js
{
  content: 'Alert!',
  onClose: function(){
    // Fired when closed 
    console.log('Alert is closed');
  }
}
```

This raises one issue, one cannot truly serialise to executable code. The attempt below serialises the function to a string, not a function that will be evaluated in JavaScript.

```{r}
# try to serialise an R function
jsonlite::toJSON("function(x){x + 1}")
```

One solution is to append the callback function to the object of options JavaScript-side.

```r
tags$script("Shiny.addCustomMessageHandler(
  type = 'send-alert', function(message) {
    // append callback
    message.onClose = function(){
      Shiny.setInputValue('alert_close', true);
    }
    new jBox('Notice', message);
});")
```

Placing a function inside a JSON object is common in JavaScript, in contrast with R where though it works is rarely if ever done (reference class/R6 are somewhat similar). The above JavaScript code to append the callback function could look something like the snippet below in R.

```{r}
message <- list(content = "hello")
message$onClose <- function(x){
  x + 1
}

message$onClose(2)
```

That done it can be incorporated into the application built thus far. Something interesting could be done server-side but for the sake of this example we merely print the value of the input to the R console.

```r
library(shiny)

ui <- fluidPage(
  tags$head(
    tags$script(
      src = paste0(
        "https://cdn.jsdelivr.net/gh/StephanWagner/",
        "jBox@v1.2.0/dist/jBox.all.min.js"
      )
    ),
    tags$link(
      rel = "stylesheet",
      href = paste0(
        "https://cdn.jsdelivr.net/gh/StephanWagner/",
        "jBox@v1.2.0/dist/jBox.all.min.css"
      )
    ),
    tags$script("Shiny.addCustomMessageHandler(
      type = 'send-alert', function(message) {
        message.onClose = function(){
          Shiny.setInputValue('alert_close', true);
        }
        new jBox('Notice', message);
    });")
  )
)

server <- function(input, output, session){

  # define notice options
  notice = list(
    content = 'Hello from the server',
    color = 'black'
  )

  # send the notice
  session$sendCustomMessage(
    type = "send-alert", message = notice
  )

  # print the output of the alert_close event (when fired)
  observeEvent(input$alert_close, {
    print(input$alert_close)
  })
}

shinyApp(ui, server)
```

## As a Package {#shiny-complete-pkg}

Packages are a fundamental part of R and allow conveniently sharing and reusing code. The work done so far is probably fitting for a single application but one should not have to reproduce all of that every time one wants to use jBox in a shiny application: we ought to wrap these functionalities into a handy package that can be used, reused and shared with others. Moreover, this will benefit from all the other advantages that R packages bring to code such as documentation, reproducibility, and tests.

Before we delve into building the package let us think through what it should include. The application using jBox gives some indication as to what the package will look like. Users of the package should be able to reproduce what is executed in the application, namely import dependencies (including the message handler) as well as send data to the JavaScript front-end. One difference with the application is the provision of a static directory of dependencies to avoid relying on the CDNs as this ensures reproducibility and more robustness (code hosted online by a third-party might change and break the package). Concretely, the package will export a `useJbox` function to be placed in the shiny ui to import the dependencies and a `send_alert` function to send the alert from the server to the client.

Let's start by creating an R package, here we name it "jbox," after the JavaScript library, partly because the author lacks creativity: feel free to name it however you want.

```r
usethis::create_package("jbox")
```

### Dependencies {#shiny-complete-pkg-deps}

The very first thing that is required are the dependencies without which nothing can work, let's create a directory of static assets, download and place the jBox CSS and JavaScript files within it. We create the directory "inst" as per the R package convention and within it create another to hold the assets. 

```r
# create directories
dir.create("inst/assets", recursive = TRUE)
```

The jBox files can be downloaded from the CDN and placed within the directory that was created above. Moreover, we also create an empty JavaScript file that will eventually contain the custom JavaScript code that "connects" R to JavaScript. 

```r
# URLs of CDNs
js_dep <- paste0(
  "https://cdn.jsdelivr.net/gh/StephanWagner/",
  "jBox@v1.2.0/dist/jBox.all.min.js"
)
css_dep <- paste0(
  "https://cdn.jsdelivr.net/gh/StephanWagner/",
  "jBox@v1.2.0/dist/jBox.all.min.css"
)

# download
download.file(js_dep, destfile="./inst/assets/jBox.all.min.js")
download.file(css_dep, destfile="./inst/assets/jBox.all.min.css")

# create file to eventually hold custom JavaScript
file.create("./inst/assets/custom.js")
```

This done one should obtain a directory that looks similar to the tree below (some files and folders omitted for brevity).

```bash
DESCRIPTION
R/
inst/
├── assets/
│    ├── custom.js
│    ├── jBox.all.min.js
│    └── jBox.all.min.css
```

Next, one needs to have those files served, the user of the package could be asked to use `shiny::addResourcePath` but it's very inelegant, it should instead be built-in the package so the user does not even have to know this happening in the background. Therefore, we ought to ensure the static files are served when the user uses the package. Packages can optionally run functions when they are loaded or attached, Hadley Wickham writes about it extensively in the namespace chapter of his book on [R packages](http://r-pkgs.had.co.nz/namespace.html). By convention, these functions are placed in a `zzz.R` file.

```r
file.create("./R/zzz.R")
```

The difference between loading and attaching a package can be subtle, in this case it's probably best to run the function when the package is loaded using `.onLoad` which the R Packages book describes as:

> Loading will load code, data and any DLLs; register S3 and S4 methods; and run the .onLoad() function. After loading, the package is available in memory, but because it’s not in the search path, you won’t be able to access its components without using ::. Confusingly, :: will also load a package automatically if it isn’t already loaded. It’s rare to load a package explicitly, but you can do so with requireNamespace() or loadNamespace().
>
> --- R Packages Book

The `addResourcePath` function should thus be placed within the `.onLoad` function, this way the files are served by shiny when the package is loaded. Note the few changes below, we refer to the path using `system.file` and change the prefix to `jbox-assets` to avoid the url serving the static files to clash with others.

```r
# R/zzz.R
.onLoad <- function(libname, pkgname) {
  path <- system.file("assets", package = "jbox")
  shiny::addResourcePath("jbox-assets", path)
}
```

This serves the file and allows not having to explicitly use `addResourcePath` but the package nonetheless needs to feature a function to let the user import them into their application.

```r
#' Import Dependencies
#' @export
usejBox <- function(){
  shiny::tags$head(
    shiny::tags$script(
      src = "jbox-assets/jBox.all.min.js"
    ),
    shiny::tags$link(
      rel = "stylesheet", 
      href = "jbox-assets/jBox.all.min.css"
    ),
    shiny::tags$script(
      src = "jbox-assets/custom.js"
    )
  )
}
```

### R Code {#shiny-complete-pkg-r-code}

Not much changes from what was written before, however, it poses interesting questions with regard to the interface we want to provide users. From the user's perspective the core of the package is the function that actually sends an alert to the clients, here created in `R/core.R`.

```r
#' Create an Alert
#' @export
send_alert <- function(content = "alert", color = "blue", session){
  # define notice options
  notice = list(content = content, color = "black")

  # send the notice
  session$sendCustomMessage(type = "send-alert", message = notice)
}
```

One could leave it at the function above, it could be sufficient in providing a functional~ish R package, it could be greatly improved upon though. The function requires the `session` object, which confuses many, most R developers have little understanding of it. This can be mitigated by providing a default using `shiny::getDefaultReactiveDomain` which, notwithstanding its grandiose name, simply returns the shiny `session` object. 

```r
#' Create an Alert
#' @export
send_alert <- function(content = "alert", color = "blue", 
  session = shiny::getDefaultReactiveDomain()){
  
  # define notice options
  notice = list(content = content, color = "black")

  # send the notice
  session$sendCustomMessage(type = "send-alert", message = notice)
}
```

This covers most of the R code that needs to be written, though we will come back to it shortly on as we uncover an interesting caveat.

### JavaScript Code {#shiny-complete-pkg-js-code}

Onto the JavaScript code, the `custom.js` to host said code is already created but remains empty. Simply using the code that was written previously will do the job for now.

```js
// custom.js
Shiny.addCustomMessageHandler(
  type = 'send-alert', function(message) {
    message.onClose = function(){
      Shiny.setInputValue('alert_close', true);
    }
    new jBox('Notice', message);
});
```

At this stage one has a fully functional package: run `devtools::document`, load the functions (`devtools::load_all`), and it is ready to be tested.

```r
devtools::document()
devtools::load_all()

library(shiny)

ui <- fluidPage(
  usejBox(),
  verbatimTextOutput("callback")
)

server <- function(input, output){
  send_alert("Hello from the server!")

  output$callback <- renderPrint({
    paste("Is the alert closed: ", input$alert_close)
  })
}

shinyApp(ui, server)
```

However, while the above will work for a single alert it will run into issues when creating more than one alert as multiple alerts will set a value for a single input (`input$alert_close`). This is can be remedied to.

The package needs to provide the user a way to distinguish between alerts in order to be able to observe the correct inputs server-side. 
A simple solution consists in asking the user to provide an identifier (`id`). This identifier must be passed to the JavaScript client so the function can dynamically set the input value for that identifier, therefore it is included in the `message`, below we do so in such a way that the original JSON of options remains unchanged.

```r
#' Create an Alert
#' @export
send_alert <- function(id, content = "alert", color = "blue", 
  session = shiny::getDefaultReactiveDomain()){
  # define notice options
  notice = list(content = content, color = "black")

  # add id
  message <- list(id = id, notice = notice)

  # send the notice
  session$sendCustomMessage(
    type = "send-alert", message = message
  )
}
```

Now one can adapt the JavaScript code to make use of the identifier. One needs to include said identifier in the name of the input the value of which is set, below we concatenate before the original input name. This is not forced upon the developer but is a convention, packages like DT and plotly approach the issue the same way: `id + name_of_input`. The event is thus now appended to `message.notice`, which is also used when creating the jBox alert.

```js
// custom.js
Shiny.addCustomMessageHandler(
  type = 'send-alert', function(message) {
    message.notice.onClose = function(){
      console.log("close");
      Shiny.setInputValue(message.id + '_alert_close', true);
    }
    new jBox('Notice', message.notice);
});
```

### Input Handler {#shiny-complete-pkg-input}

The input defined in this package simply consists of a boolean value which does not warrant the use of an input handler. However, were one required the place to put it would be in the `.onLoad` function as the handler can only be registered once.

```r
# R/zzz.R

jbox_handler <- function(data, session, inputname){
  list(
    data = data,
    meta = "This is some metadata"
  )
}

.onLoad <- function(libname, pkgname) {
  # serve static files
  shiny::addResourcePath(
    "jbox-assets",
    system.file("assets", package = "jbox")
  )

  # register input handler
  registerInputHandler("jbox.alert.handler", jbox_handler)
}
```

### Wrapping up {#shiny-complete-pkg-conclude}

Building and installing the package will now provide the user an interface demonstrated below.

```r
library(jbox)
library(shiny)

ui <- fluidPage(
  usejBox(),
  verbatimTextOutput("callback")
)

server <- function(input, output){
  send_alert("myid", "Hello from the server!")

  output$callback <- renderPrint({
    paste("Is the alert closed: ", input$myid_alert_close)
  })
}

shinyApp(ui, server)
```

It must be noted that though the package will be fully functional it will not pass any checks as documentation is poor and the DESCRIPTION incomplete. The API provided to the user is probably subpar in places, namely with the use of the id, which, unless the user needs to observe the respective input, is not necessary: forcing the user to provide it is not great design, consider making this optional.
