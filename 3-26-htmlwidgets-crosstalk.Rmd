# Crosstalk

Crosstalk [@R-crosstalk] is fantastic add-on for htmlwidgets that implements cross-widget interactions, namely selection and filtering. This in effect allows the selection or filtering of data points in one widget to be mirrored in another. This is enabled by the creation of "shared datasets" that can be used across widgets.

Crosstalk provides a straightforward interface to the users and instead requires effort from the developers for their widgets to support the shared datasets.

```{r, include = FALSE}
library(crosstalk)
```

## Crosstalk example

Both the plotly and DT packages support crosstalk, we can thus produce a scatter plot with the former and a table with the latter so that selection of data in one widget is reflected in the other.

The shared dataset is created with the `SharedData` R6 class, this dataset is then used as one would use a standard dataframe in plotly and DT. The `bscols` function is just a helper to create columns from html elements (using bootstrap). It's ideal for examples but one should not have to use it in R markdown or Shiny---crosstalk will work without `bscols`.

```r
library(DT)
library(plotly)
library(crosstalk)

shared <- SharedData$new(cars)

bscols(
  plot_ly(shared, x = ~speed, y=~dist),
  datatable(shared, width = "100%")
)
```

![Crosstalk Example](images/crosstalk.png)

With crosstalk comes the concept of "groups," it defines an instance of shared data. The shared datasets created below will be linked because they share the same `group`, even though they are different objects.

```r
shared_cars <- SharedData$new(mtcars, group = "cars")
shared_cars_four_cyl <- SharedData$new(mtcars, group = "cars")
```

We will later explore and demonstrate why and where this is useful.

## Crosstalk requirements

Crosstalk is will not work well with every widget and every dataset, in some cases it might not even be a good idea to support it.

Crosstalk works best on rectangular data: dataframes or objects that resemble dataframes like `tibble` or `SpatialPolygonsDataFrame`. This is important as crosstalk will treat the data rowwise, where each row is an observation that is ultimately selected, or filtered. If the underlying data is not tabular (e.g.: trees) then one might eventually encounter mismatches between widgets.

Other than tabular data, crosstalk will require the widget to have the necessary functions or methods to dispatch the selection and filtering that crosstalk enables, that is, the widget must be able to filter as well as highlight and fade selected data points. 

## How it works

As will be discovered later when we bring crosstalk support to gio, very little changes on the R side. As might be expected, crosstalk enables communication between widgets via JavaScript, hence much of what must be adapted by widgets developers happens in JavaScript too.

```{r, echo=FALSE}
DiagrammeR::grViz("
digraph G {

  graph [compound=true rankdir = LR]
  node [shape=record fontsize=10];

  # r stuff
  subgraph cluster_1 { 
    'Widget 1' 'Widget 2';
    label = 'JavaScript';
    color=gold;
  }

  # js
  subgraph cluster_0 {
    node [width = 0.9]
    Dataset 'Shared Dataset'; 
    label='R';
    color=royalBlue;
  }

  'Dataset' -> 'Shared Dataset';
  'Widget 1' -> 'Widget 2' [dir=both color=dimGray];

  # connect subgraphs
  'Shared Dataset' -> 'Widget 1' [lhead=cluster_1 ltail=cluster_0];
}
", width = "100%", height = 250)
```

Indeed the biderectional communication between widgets works in the RStudio viewer, R markdown, Shiny and elsewhere, clearly indicating that all of it is taking place in the browser. This, internally, works with `key`s that are assigned to every row of the data.frame. These keys can be explicitly set by the user and otherwise default to the row names of the data.frame, and if these are not available will create row numbers.

```{r}
# assign keys
df <- data.frame(x = runif(26))
sd <- SharedData$new(df, key = letters)
```

In a sense, while crosstalk handles the lines of communication between widgets, developers of the respective widgets must handle what messages are sent to others and what to do with messages coming from other widgets. There are two types of such messages: filtering to actually narrow down the selection of data points displayed on a widget, and selection (what crosstalk refers to as "linked brushing") to highlight certain data points.

```{r, echo=FALSE}
DiagrammeR::grViz("
digraph G {
  graph [rankdir = LR, compound=true]

  subgraph cluster_0 {
    node [shape=record fontsize=7];

    node [shape=box color=royalBlue]
    'Crosstalk'; 
    
    node [shape=box color=gold]
    'Widgets';
    label = 'Bidirectional Communication'
    color=white
    fontsize=8
  }

  Crosstalk -> Widgets [label='keys to filter' fontsize=6];
  Widgets -> Crosstalk [label='filtered keys' fontsize=6];
}
", width = "100%")
```

This selection or filtering is communicated with the aforementioned keys. In JavaScript, a widget "receives" the keys of selected and filtered data points and must, when filtering or selection is observed, "send" said selected or filtered keys to other widgets.

Internally crosstalk knows what to share across widgets with the aforementioned `group`, each group is isolated from each other so one can use multiple different shared datasets without them interfering with each other.

## Crosstalk with gio

The application of crosstalk to the gio library is somewhat amiss. As mentioned or hinted at before, in order for crosstalk to be properly implemented a widget must be a able to select, deselect as well as filter and unfilter data points and this is not entirely the case of gio. 

```{block, type='rmdnote'}
The application of crosstalk to the gio package is instructive but limited and somewhat faulty.
```

First, gio's underlying data is somewhat uncommon: it is a network defined only by its edges (the arcs leaving and coming into countries). Second, those edges themselves cannot be selected, as we've observed previously one cannot truly change what edges are drawn on the globe, only change which country is selected and by proxy which edges are shown. Third, while gio supports changing which country is selected it does not allow having not countries selected.

## Adapt the R code

In any event, let us start by making the required changes to the R code first. The only changes that need to be made are in the `gio` function as it is the only that accepts a data object.

```{r}
class(sd)
```

The shared datasets are R6 classes and therefore cannot simply be treated as dataframes. The `gio` function needs to check whether the `data` object it received is a shared dataset with `is.SharedData` and if so use its methods to extract data from it, namely:

- The original dataset with `origData`.
- The group to which the dataset belongs with `groupName`.
- The keys that were assigned to every row of the dataset with `key`

```{r}
# original data
data <- sd$origData()
head(data)
```

Note that the name of the group was randomly generated since none were specified when the shared dataset was created.

```{r}
# groupName
sd$groupName()

# keys
keys <- sd$key()
head(keys)
```

The methods `origData` and `groupName` must be used in every widget, the original dataframe is still needed to produce the visualisation and the group will be needed JavaScript so we can tell crosstalk which group one is working with. The `key` method may not be useful with every widget if the visualisation library also comes with a key/id system so one can use it internally, we won't be using it with gio. Finally notice that we also add the JavaScript dependency with  `crosstalkLibs`.

```r
gio <- function(data, width = NULL, height = NULL, elementId = NULL) {

  # defaults to NULL
  group <- NULL

  # uses crosstalk
  if (crosstalk::is.SharedData(data)) {
    group <- data$groupName()
    data <- data$origData()
  }

  # forward options using x
  x = list(
    data = data,
    style = "default",
    crosstalk = list(group = group) # pass group
  )

  attr(x, 'TOJSON_ARGS') <- list(dataframe = "rows")

  # create widget
  htmlwidgets::createWidget(
    name = 'gio',
    x,
    width = width,
    height = height,
    package = 'gio',
    elementId = elementId,
    sizingPolicy = htmlwidgets::sizingPolicy(
      padding = 0,
      browser.fill = TRUE,
      defaultWidth = "100%"
    ),
    preRenderHook = render_gio,
    # add crosstalk dependency
    dependencies = crosstalk::crosstalkLibs()
  )
}
```

## Change JavaScript code

```js
HTMLWidgets.widget({

  name: 'gio',

  type: 'output',

  factory: function(el, width, height) {

    // TODO: define shared variables for this instance
    var controller;
    var sel_handle = new crosstalk.SelectionHandle();

    sel_handle.on("change", function(e) {
      console.log(e);
      if (e.sender !== sel_handle) {
        // clear selection
      }
      controller.switchCountry(e.value);
    });

    return {

      renderValue: function(x) {

        el.innerHTML = '';
        controller = new GIO.Controller(el);

        // group
        sel_handle.setGroup(x.crosstalk.group);
        
        // add data
        controller.addData(x.data);

        controller.setStyle(x.style);

        // callback
        controller.onCountryPicked(callback);

        function callback (selectedCountry, relatedCountries) {
          sel_handle.set(selectedCountry.name)
          Shiny.setInputValue(el.id + '_selected', selectedCountry);
          Shiny.setInputValue(el.id + '_related:gio.related.countries', relatedCountries);
        }

        // use stats
        if(x.stats)
          controller.enableStats();

        // render
        controller.init();

      },

      resize: function(width, height) {

        // TODO: code to re-render the widget with a new size
        controller.resizeUpdate()

      },

      getGlobe: function(){
        return controller;
      }

    };
  }
});
```

```r
library(DT)
library(gio)
library(crosstalk)

url <- paste0(
  "https://raw.githubusercontent.com/JohnCoene/",
  "javascript-for-r/master/data/countries.json"
)
arcs <- jsonlite::fromJSON(url)

# Wrap data frame in SharedData
# key is importing country
sd <- SharedData$new(arcs, key = arcs$i)

# Use SharedData like a dataframe with Crosstalk-enabled widgets
bscols(
  gio(sd),
  datatable(sd, width="100%", selection = "single")
)
```

```r
library(gio)
library(plotly)
library(crosstalk)

url <- paste0(
  "https://raw.githubusercontent.com/JohnCoene/",
  "javascript-for-r/master/data/countries.json"
)
arcs <- jsonlite::fromJSON(url)

# Wrap data frame in SharedData
edges_sd <- SharedData$new(arcs, key = arcs$i, group = "gio")

# create nodes
iso2c <- unique(arcs$i)
nodes <- data.frame(
  country = iso2c,
  x = 1:length(iso2c),
  y = runif(iso2c)
)
nodes_sd <- SharedData$new(nodes, key = nodes$country, group = "gio")

# Use SharedData like a dataframe with Crosstalk-enabled widgets
bscols(
  plot_ly(data = nodes_sd, mode = "markers") %>% 
    add_markers(x = ~x, y = ~y, text = ~country) %>% 
    config(displayModeBar = FALSE),
  gio(edges_sd)
)
```


## Use it in Shiny

```{block, type='rmdnote'}
Create the shared dataset the server function.
```
