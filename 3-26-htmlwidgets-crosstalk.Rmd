# Crosstalk

Crosstalk [@R-crosstalk] is fantastic add-on for htmlwidgets that implements cross-widget interactions, namely selection and filtering. This in effect allows the selection or filtering of data points in one widget is mirrored in another which is enabled by creating "shared datasets".

Crosstalk provides a straightforward interface to the users and instead requires effort from the developers for their widgets to support the shared datasets.

## Crosstalk example

Both the plotly and DT packages support crosstalk, we can thus produce a scatter plot with the former and a table with the latter so that selection of data in one widget is reflected in the other.

The shared dataset is created with the `SharedData` R6 class, this dataset is then used as one would use a standard dataframe in plotly and DT. The `bscols` function is just a helper to create columns from html elements (using bootstrap). It's ideal for examples but one should not have to use it in R markdown or Shiny---crosstalk will work without `bscols`.

```r
library(DT)
library(plotly)
library(crosstalk)

shared <- SharedData$new(cars)

bscols(
  plot_ly(shared, x = ~speed, y=~dist),
  datatable(shared, width = "100%")
)
```

![Crosstalk Example](images/crosstalk.png)

One dark concept of crosstalk that is probably seldom used but needs to be understood by widgets developers is that of "groups." A group defines an instance of shared data.

```r
shared_cars <- SharedData$new(mtcars, group = "cars")
shared_cars_four_cyl <- SharedData$new(mtcars, group = "cars")
```

The shared dataset above will be linked because they share the same `group`, event though they are different objects.

This hopefully demonstrates the ease with which users can make use of crosstalk.

## Crosstalk requirements

Crosstalk is will not work well with every widget and every dataset, in some cases it might not even be a good idea to support it.

Crosstalk works best on rectangular data: dataframes or objects that resemble dataframes like `tibble` or `SpatialPolygonsDataFrame`. This is important as crosstalk will treat the data rowwise, where each row is an observation that is ultimately selected, or filtered. If the underlying data is not tabular (e.g.: trees) then one might eventually encounter mismatch between widgets.

Other tabular data, crosstalk will require the widget to have the necessary functions or methods to dispatch the selection and filtering that crosstalk enables, without which crosstalk support makes little sense. 

## How it works

As will be discovered later when we bring crosstalk support to gio, very little changes on the R side. As might be expected, crosstalk enables communication between widgets via JavaScript, hence much of what must be adapted by widgets developers happens in JavaScript too.

```{r, echo=FALSE}
DiagrammeR::grViz("
digraph G {

  graph [rankdir = LR, compound=true]
  node [shape=record fontsize=10];

  # r stuff
  subgraph cluster_1 {
    'Widget 1' 'Widget 2';
    label = 'JavaScript';
    color=gold;
  }

  # js
  subgraph cluster_0 {
    node [width = 0.9]
    Dataset 'Shared Dataset'; 
    label='R';
    color=royalBlue;
  }

  'Dataset' -> 'Shared Dataset';
  'Widget 1' -> 'Widget 2' [dir=both, color=dimGray];

  # connect subgraphs
  'Shared Dataset' -> 'Widget 1';
  'Shared Dataset' -> 'Widget 2';
}
")
```

Indeed the biderectional communication between widgets works in the RStudio viewer, R markdown, Shiny and elsewhere, clearly indicating that all of it is taking place in the browser. This, internally, works with a unique `key` that is assigned to every row of the data.frame. These unique keys can be explicitly set by the user and otherwise default to the row names of the data.frame, and if these are not available will create row numbers.

In a sense, while crosstalk handles the lines of communication between widgets, developers of the respective widgets must handle what messages are sent to others and what to do with messages sent by other widgets. There are two types of such messages: filtering to actually narrow down the selection of data points displayed on a widget, and selection (what crosstalk refers to as "linked brushing") to highlight certain data points. So whatever selection is made in another widget is communicated to other widgets where it is captured and reflected, same for the filtering, all of which takes place in JavaScript.

```{r, echo=FALSE}
DiagrammeR::grViz("
digraph G {
  graph [rankdir = LR, compound=true]
  node [shape=record fontsize=10];

  subgraph cluster_0 {
    'Selection'; 
    'Filter';
    label='Another Widget'
    color=royalBlue
  }

  subgraph cluster_1 {
    'Filtered';
    'Selected'
    label='Another Widget'
    color=gold
  }

  subgraph cluster_2 {
    node [shape=none]
    'Your Widget';
  }

  'Selection' -> 'Your Widget';
  'Your Widget' -> 'Selected';
  'Filter' -> 'Your Widget';
  'Your Widget' -> 'Filtered'
}
")
```

This selection or filtering is communicated with the aforementioned keys. In JavaScript, a widget "receives" the keys of selected and filtered data points and must, when filtering or selection is observed, "send" said selected or filtered keys so they can be applied in other widgets that make use of the shared dataset.

## Crosstalk with gio

The application of crosstalk to the gio library is somewhat amiss. As mentioned or hinted at before, in order for crosstalk to be properly implemented a widget must be a able to selected, deselect as well as filter and unfilter data points and this is not entirely the case of gio. 

```{block, type='rmdnote'}
The application of crosstalk to the gio package is instructive but limited and somewhat faulty.
```

First, gio's underlying data is somewhat uncommon: it is a network defined only by its edges (the arcs leaving and coming into countries). Second, those edges themselves cannot be selected, as we've observed previously one cannot truly change what edges are drawn on the globe, only change which country is selected. Third, one can _change which country is selected_ but cannot unselect a country as would be ideal with crosstalk.

In any event, let us start by making the required changes to the R code first.

```r
gio <- function(data, width = NULL, height = NULL, elementId = NULL) {

  # defaults to NULL
  key <- NULL
  group <- NULL

  if (is.SharedData(data)) {
    key <- data$key()
    group <- data$groupName()
    data <- data$origData()
  }

  # forward options using x
  x = list(
    data = data,
    style = "default",
    crosstalk = list(
      key = key,
      group = group
    )
  )

  attr(x, 'TOJSON_ARGS') <- list(dataframe = "rows")

  # create widget
  htmlwidgets::createWidget(
    name = 'gio',
    x,
    width = width,
    height = height,
    package = 'gio',
    elementId = elementId,
    sizingPolicy = htmlwidgets::sizingPolicy(
      padding = 0,
      browser.fill = TRUE,
      defaultWidth = "100%"
    ),
    preRenderHook = render_gio
  )
}
```

```js
HTMLWidgets.widget({

  name: 'gio',

  type: 'output',

  factory: function(el, width, height) {

    // TODO: define shared variables for this instance
    var controller;
    var sel_handle = new crosstalk.SelectionHandle();

    sel_handle.on("change", function(e) {
      console.log(e);
      if (e.sender !== sel_handle) {
        //controller.switchCountry(e.value);
      }
      controller.switchCountry(e.value);
    });

    return {

      renderValue: function(x) {

        el.innerHTML = '';
        controller = new GIO.Controller(el);

        // group
        sel_handle.setGroup(x.crosstalk.group);
        
        // add data
        controller.addData(x.data);

        controller.setStyle(x.style);

        // callback
        controller.onCountryPicked( callback );

        function callback (selectedCountry, relatedCountries) {
          sel_handle.set(selectedCountry.name)
          Shiny.setInputValue(el.id + '_selected', selectedCountry);
          Shiny.setInputValue(el.id + '_related:gio.related.countries', relatedCountries);
        }

        // use stats
        if(x.stats)
          controller.enableStats();

        // render
        controller.init();

      },

      resize: function(width, height) {

        // TODO: code to re-render the widget with a new size
        controller.resizeUpdate()

      },

      getGlobe: function(){
        return controller;
      }

    };
  }
});
```

```r
library(DT)
library(gio)
library(crosstalk)

url <- paste0(
  "https://raw.githubusercontent.com/JohnCoene/",
  "javascript-for-r/master/data/countries.json"
)
arcs <- jsonlite::fromJSON(url)

# Wrap data frame in SharedData
sd <- SharedData$new(arcs, key = arcs$e)

# Use SharedData like a dataframe with Crosstalk-enabled widgets
bscols(
  gio(sd),
  datatable(sd, width="100%", selection = "single")
)
```


## Use it in Shiny

```{block, type='rmdnote'}
Create the shared dataset the server function.
```
