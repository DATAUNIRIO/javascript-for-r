[
["index.html", "R and JavaScript Preface 0.1 Disclaimer", " R and JavaScript John Coene 2020-05-22 Preface The R programming language has seen the integration of many programming languages; C, C++, Python, to name a few, can be seamlessly embedded into R so one can easily call code written in other languages from the R console. Little known to many, R works just as well with JavaScript—this book delves into the various ways both languages can work together. The ultimate aim of this work is to put the reader at ease with inviting JavaScript in their data science workflow. In that respect the book is not teaching one JavaScript but rather we show how little JavaScript can greatly support and enhance our work in R. 0.1 Disclaimer This book is currently a work in progress. "],
["about-the-author.html", "About the Author", " About the Author Frida Gomam is a famous lady. Police will always let her go. "],
["intro.html", "1 Introduction Prerequisites Rationale Methods", " 1 Introduction In this chapter, after briefly going through prerequisites, we provide a rationale for integrating JavaScript with R which we support with examples, namely packages already available on CRAN. Then, we list the various ways in which one might go about making both languages work together. Finally, we end with a review of concepts fundamental to fully understand the more advanced topics residing in the forthcoming chapters. Prerequisites The code contained in the following pages is approachable to readers with basic knowledge of R, although familiarity with package development using devtools (Wickham, Hester, and Chang 2020), as well as the Shiny (Chang et al. 2020) framework is helpful. The reason for the former is that some of the ways one builds integrations with JavaScript naturally take the form of R packages. The following section thus runs over the essentials of building a package to ensure everyone can keep up. As both Shiny and JavaScript run in the browser they make for axiomatic companions; we’ll therefore use Shiny extensively. Only basic knowledge of JavaScript is required to understand and learn from the book as not only is JavaScript rather uncomplicated and its syntax similar to R’s in places, we write surprisingly little of it. Understanding of JSON and HTML, however, is essential. In essence, if one has already used external JavaScript libraries in HTML or R markdown documents then one is well-equipped to tackle this book but in the event that you have not, we will go through a quick review of the basics of both JavaScript and JSON. It is highly recommended to use the freely available RStudio IDE to follow along, particularly if you are beginner in R. Package Development Developing packages used to be notoriously difficult but things have greatly changed, namely thanks to the devtools and more recent usethis (Wickham and Bryan 2020) packages. The first is specifically designed to help creating packages; setting up tests, running checks, building and installing packages, etc. The second, usethis, more broadly helps setting up projects, and automating repetitive tasks. Here, we only skim over the fundamentals, there is an entire book by Hadley Wickham called R Packages solely dedicated to the topic. Start by installing the two packages from CRAN. install.packages(c(&quot;devtools&quot;, &quot;usethis&quot;)) We’ll create an admittedly ridiculous package to explain how it works. Despite being useless, this package will introduce certain concepts of package development that are essential to understand for what is following. The package will be named “test” and will provide a single function that will print a JavaScript file stored inside our package. Useless but bear with it. Let’s create the package, either do so using the RStudio IDE or with usethis. From the RStudio IDE go to File &gt; New Project &gt; New Directory then select “R package” and fill in the small form. But it could be argued that it’s actually easier with usethis; type the code below in your R console to create a package named “test” in your current directory. If you run it from RStudio a new project window should open. usethis::create_package(&quot;test&quot;) This creates an empty package called “test”. Let’s add the JavaScript file that the yet-to-be-written R function will eventually print out. R packages must follow strict rules, this file cannot be placed anywhere we want; it must be stored in a directory called inst which stands for “installation;” these are files that will simply be copied to the users’ machine when they install your package. Create the inst directory in the root of the package (e.g.: next to the already existing R) and place a file called javascript.js within it. Let’s create the following, extremely simple JavaScript file that contains code which declares a variable named x. // inst/javascript.js var x = 3; This can all be done from the R console as shown below. dir.create(&quot;inst&quot;) # create directory writeLines(&quot;var x = 3;&quot;, con = &quot;inst/javascript.js&quot;) # create file This should produce a directory looking something like: DESCRIPTION NAMESPACE R/ inst/ |-- javascript.js Onto creating the R function that will read and print this file. Then again, R is strict, R files must be placed in the R directory. Then again, this can be done from the console or the RStudio IDE. # create the file from the R console file.create(&quot;R/function.R&quot;) In the function.R file we just created we place a function that reads the javascript.js file and prints it to the R console. In order to read the file one needs to locate it, as packages are destined to be shared and installed on different machines one can never use absolute paths, where the javascript.js file is located will depend on where the user has installed the package: as the developer you can never know that for sure. Therefore R comes with a system.file function which will look for a file relative to a package inst directory and return its full path. # R/function.R print_file &lt;- function(){ # look for javascript.js in the inst folder of the test package file &lt;- system.file(&quot;javascript.js&quot;, package = &quot;test&quot;) } With the file path one can read the contents of the file and print it. print_file &lt;- function(){ file &lt;- system.file(&quot;javascript.js&quot;, package = &quot;test&quot;) content &lt;- readLines(file) print(content) } Let’s add a pretty message, using the cli (Csárdi 2020) package, before we print the file as it allows introducing another concept; using external libraries in our package. To use cli we can run: # install.packages(&quot;cli&quot;) usethis::use_package(&quot;cli&quot;) ## ✔ Adding &#39;cli&#39; to Imports field in DESCRIPTION ## ● Refer to functions with `cli::fun()` It does exactly what it printed. The DESCRIPTION file includes information about the package and, very importantly, dependencies. The package we are creating will depend on the cli package; the DESCRIPTION file essentially tells R to check whether it is installed on the machine, if not it installs it (packages are for sharing). You should now see the following entry in the DESCRIPTION file. Imports: cli We can add cli to our function, note that we use the namespace (or package name) followed by a double colon, as was printed by the usethis::use_package function we ran earlier. print_file &lt;- function(){ file &lt;- system.file(&quot;javascript.js&quot;, package = &quot;test&quot;) cli::cli_alert_info(&quot;JavaScript code below.&quot;) content &lt;- readLines(file) print(content) } It’s not done just yet. Let’s demonstrate why: it allows introducing devtools. We can install the “test” package we created with devtools::install(), afterwards we can expect to be able to run the print_file function we wrote but it returns the following error: could not find function \"print_file\". Odd. This is because we have not explicitly “exported” the function, by default functions and objects declared in .R files (in packages) can only be used internally (within the package itself). In order to export it we need another package called roxygen2 (Wickham et al. 2020), it allows writing the documentation in the .R file rather than have to create separate file, a lifesaver. Note that roxygen2 should already be installed on your machine. Using said documentation we can specify which function should be exported with a “tag”. Tags are preceded by #' @, there are plenty of them, we don’t explore any other here. #&#39; @export print_file &lt;- function(){ file &lt;- system.file(&quot;javascript.js&quot;, package = &quot;test&quot;) cli::cli_alert_info(&quot;JavaScript code below.&quot;) content &lt;- readLines(file) print(content) } Now one can run devtools::document() to document the package based on the tag we added: this exports the function. Then we can run devtools::install() to build and install the package. test::print_file() ## ℹ JavaScript code below. ## [1] &quot;var x = 3;&quot; Finally, the cyclical nature of building packages substitute devtools::install() with devtools::load_all(), the latter does not install the package and simply loads all the functions and objects of the package in the environment, this is much faster than installing it. Write some code Run devtools::document() Run devtools::load_all() Repeat Note the package we built is good enough for your own machine but won’t pass CRAN checks as we miss a lot of the documentation (roxygen2 tags). JSON JSON (JavaScript Object Notation) is a very popular data interchange format with which we will work extensively throughout this book, it is thus crucial that we have a good understanding of it before we plunge into the nitty-gritty. As one might foresee, if we want two languages to work together it is essential that we have a data format that can be understood by both—JSON lets us harmoniously pass data from one to the other. While it is natively supported in JavaScript, it can be graciously handled in R with the jsonlite package (Ooms 2020), in fact it is the serialiser used internally by all of the methods detailed in the previous section. JSON is to all intents and purposes the equivalent of lists in R; a flexible data format that can store pretty much anything. Below we create a nested list and convert it to JSON with the help of jsonlite, we set pretty to TRUE to add indentation for clearer printing but this is an argument you should omit when writing production code, it will reduce the file size (fewer spaces = smaller file size). # install.packages(&quot;jsonlite&quot;) library(jsonlite) lst &lt;- list( a = 1, b = list( c = c(&quot;A&quot;, &quot;B&quot;) ), d = 1:5 ) toJSON(lst, pretty = TRUE) ## { ## &quot;a&quot;: [1], ## &quot;b&quot;: { ## &quot;c&quot;: [&quot;A&quot;, &quot;B&quot;] ## }, ## &quot;d&quot;: [1, 2, 3, 4, 5] ## } Looking closely at the list and JSON output above one quickly sees the resemblance. Something seems odd though, the first value in the list (a = 1) was serialised to an array (vector) of length one (\"a\": [1]) where one would probably expect an integer instead, 1 not [1]. This is not a mistake, we often forget that there are no scalar types in R and that a is in fact a vector as we can observe below. x &lt;- 1 length(x) ## [1] 1 is.vector(x) ## [1] TRUE JavaScript, on the other hand, does have scalar types, more often than not we will want to convert our vectors of length one to scalar types rather than arrays of length one. To do so we need use the auto_unbox argument in jsonlite::toJSON, we’ll do this most of the time we have to convert data to JSON. toJSON(lst, pretty = TRUE, auto_unbox = TRUE) ## { ## &quot;a&quot;: 1, ## &quot;b&quot;: { ## &quot;c&quot;: [&quot;A&quot;, &quot;B&quot;] ## }, ## &quot;d&quot;: [1, 2, 3, 4, 5] ## } As demonstrated above the vector of length one was “unboxed” into an integer, with auto_unbox set to TRUE jsonlite will properly convert such vectors into their appropriate type; integer, numeric, boolean, etc. If JSON is more or less the equivalent of lists in R one might wonder how jsonlite handles dataframes. # subset of built-in dataset df &lt;- cars[1:2, ] toJSON(df, pretty = TRUE) ## [ ## { ## &quot;speed&quot;: 4, ## &quot;dist&quot;: 2 ## }, ## { ## &quot;speed&quot;: 4, ## &quot;dist&quot;: 10 ## } ## ] What jsonlite does internally is essentially turn the data.frame into a list rowwise to produce a sub-list for every row then it serialises to JSON. This is generally how rectangular data is represented in lists, for instance, purrr::transpose does the same. We can reproduce this with the snippet below, we remove row names and use apply to turn every row into a list. row.names(df) &lt;- NULL df_list &lt;- apply(df, 1, as.list) toJSON(df_list, pretty = TRUE, auto_unbox = TRUE) ## [ ## { ## &quot;speed&quot;: 4, ## &quot;dist&quot;: 2 ## }, ## { ## &quot;speed&quot;: 4, ## &quot;dist&quot;: 10 ## } ## ] Jsonlite of course also enables reading data from JSON into R with the function fromJSON. json &lt;- toJSON(df) # convert to JSON fromJSON(json) # read from JSON ## speed dist ## 1 4 2 ## 2 4 10 It’s important to note that jsonlite did the conversion back to a data frame. Therefore the code below also returns a data frame even though the object we initially converted to JSON is a list. class(df_list) ## [1] &quot;list&quot; json &lt;- toJSON(df_list) fromJSON(json) ## speed dist ## 1 4 2 ## 2 4 10 Jsonlite provides many more options and functions that will let you tune how JSON data is read and written. Also, the jsonlite package does far more than what we detailed in this section but at this juncture this is an adequate understanding of things. JavaScript The book is not meant to teach one JavaScript, only to show how graciously it can work with R; in that endeavour we aim at writing little JavaScript so the book remains approachable to a wide audience. Let us just go through the very basics to ensure we know enough to get started with the next chapter. In the event that you would want to try what we briefly explore here: the easiest way is to create an HTML file (e.g.: index.html), write your code within a script tag and open the file in your web browser. The output can be observed in the console of the browser which can be opened with a right click and selecting “inspect” then going to the “console” tab. &lt;!–– index.html ––&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=&quot;content&quot;&gt;Trying JavaScript!&lt;/p&gt; &lt;/body&gt; &lt;script&gt; // place your JavaScript code here &lt;/script&gt; &lt;/html&gt; The first difference with R is that the end of every line should be marked with a semi-colon. JavaScript code will often work without but one should always include them to avoid future headaches. Below we use console.log, JavaScript equivalent of R’s print function. console.log(&quot;hello JavaScript&quot;) // bad console.log(&quot;hello JavaScript&quot;); // good Another difference is that variables must be declared with keywords such as var or const to declare a constant. x = 1; // bad var x = 1; // good One can declare a variable without assigning a value to it, to then do so later on. // good var y; y = [1,2,3]; // define it as array y = &#39;string&#39;; // change to character string In R like in JavaScript, variables can be accessed from the parent environment (often referred to as “context” in the latter). One immense difference though is that while it is seen as bad practice in R it is not in JavaScript where it comes very useful. # it works but don&#39;t do this in R x &lt;- 123 foo &lt;- function(){ print(x) } foo() ## [1] 123 The above R code can be re-written in JavaScript. Note the slight variation in the function declaration. // this is perfectly fine var x = 1; function foo(){ console.log(x); } foo() One concept which does not exist in R is that of the “DOM” which stands for Document Object Model. When a web page is loaded, the browser creates a Document Object Model of the web page which can be accessed in JavaScript from the document object. This lets the developer programmatically manipulate the page itself so one can for instance, add an element (e.g.: a button), change the text of another, and plenty more. The JavaScript code below grabs the element where id='content' from the document with getElementById and replaces the text (innerText). Even though our page only contains “Trying JavaScript!” when the page is opened (loaded) in your web browse JavaScript runs our code and changes it: this happen very fast so you likely don’t even see the original text. &lt;!–– index.html ––&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=&quot;content&quot;&gt;Trying JavaScript!&lt;/p&gt; &lt;/body&gt; &lt;script&gt; var cnt = document.getElementById(&quot;content&quot;); cnt.innerText = &quot;The text has changed&quot;; &lt;/script&gt; &lt;/html&gt; This of course only scratches the surface of JavaScript but provides ample understanding of the language to keep up with the next chapters. Rationale Why merge JavaScript and R? They are two fundamentally different languages that each have their strengths and weaknesses, combining the two allows making the most of their consolidated advantages and circumvent their respective limitations to produce software altogether better for it. A fair reason to use JavaScript might simply be that the thing one wants to achieve in R has already been realised in JavaScript. Why reinvent the wheel when the solution already exists and that it can be made accessible from R? The R package lawn (Chamberlain and Hollister 2019) by Ropensci integrates turf.js, a brilliant library for geo-spatial analysis. JavaScript is not required to make those computations, it could be rewritten solely in R but that would be vastly more laborious than wrapping the JavaScript API in R. library(lawn) lawn_count(lawn_data$polygons_count, lawn_data$points_count, &quot;population&quot;) ## &lt;FeatureCollection&gt; ## Bounding box: -112.1 46.6 -112.0 46.6 ## No. features: 2 ## No. points: 20 ## Properties: ## values count ## 1 200, 600 2 ## 2 0 Another great reason is that JavaScript can do things that R cannot, e.g.: run in the browser. Therefore one cannot natively create interactive visualisations with R. Plotly (Sievert et al. 2020) by Carson Sievert packages the plotly JavaScript library to let one create interactive visualisations solely from R code. library(plotly) plot_ly(diamonds, x = ~cut, color = ~clarity) Finally, JavaScript can work together with R to improve how we communicate insights. One of the many ways in which Shiny stands out is that it lets one create web applications solely from R code with no knowledge of HTML, CSS, or JavaScript but that does not mean they can’t extend Shiny, quite the contrary. The waiter package (Coene 2020) integrates a variety of JavaScript libraries to display loading screens in Shiny applications. library(shiny) library(waiter) ui &lt;- fluidPage( use_waiter(), # include dependencies actionButton(&quot;show&quot;, &quot;Show loading for 3 seconds&quot;) ) server &lt;- function(input, output, session){ # create a waiter w &lt;- Waiter$new() # on button click observeEvent(input$show, { w$show() Sys.sleep(3) w$hide() }) } shinyApp(ui, server) Hopefully this makes a couple of great reasons and alluring examples to entice you to persevere with this book. Methods Though perhaps not obvious at first, all of the packages used as examples in the previous section internally interface with JavaScript very differently. As we’ll discover, there many ways in which one can blend JavaScript with R, generally the way to go about it is dictated by the nature of what is to be achieved. Let’s list the methods available to us to blend JavaScript with R before covering them each in-depth in their own respective chapter later in the book. V8 V8 by Jeroen Ooms is an R interface to Google’s JavaScript engine. It will let you run JavaScript code directly from R and get the result back, it even comes with an interactive console. This is the way the lawn package used in a previous example internally calls turf.js. library(V8) ctx &lt;- v8() ctx$eval(&quot;2 + 2&quot;) # this is evaluated in JavaScript! ## [1] &quot;4&quot; htmlwidgets htmlwidgets (Vaidyanathan et al. 2019) specialises in wrapping JavaScript libraries that generate visual outputs. This is what packages such as plotly, DT (Xie, Cheng, and Tan 2020), highcharter (Kunst 2019), and many more use to provide interactive visualisation with R. It is by far the most popular integration out there, at the time of writing this it has been downloaded nearly 10 million times from CRAN. It will therefore be covered extensively in later chapters. Shiny The Shiny framework allows creating applications accessible from web browsers where JavaScript natively runs, it follows that JavaScript can run alongside such applications. Often overlooked though, the two can also work hand-in-hand as one can pass data from the R server to the JavaScript front-end and vice versa. Some form of that tends to be included in htmlwidgets so one can pick up server-side which point on a scatter plot was clicked for instance. reactR ReactR (Inc et al. 2019) is an R package that emulates very well htmlwidgets but specifically for the React framework. Unlike htmlwidgets it is not limited to visual outputs and also provides functions to build inputs, e.g.: a drop-down menu (like shiny::selectInput). The reactable package (Lin 2019) uses reactR to enable building interactive tables solely from R code. reactable::reactable(iris[1:5, ], showPagination = TRUE) Note that custom Shiny inputs can also be built, this is however not covered in this book for it is very well documented. bubble bubble (Fay 2020) by Colin Fay is a more recent R package, still under heady development but very promising: it lets one run node.js code in R, comes with an interactive node REPL, the ability to install npm packages, and even an R markdown engine. It’s similar to V8 in many ways. library(bubble) n &lt;- NodeSession$new() n$eval(&quot;2 + 2&quot;) # this is evaluated in node.js ## 4 r2d3 r2d3 (Luraschi and Allaire 2018) by RStudio is an R package designed specifically to work with d3.js. It is similar to htmlwidgets but works rather differently. # https://rstudio.github.io/r2d3/articles/gallery/chord/ r2d3::r2d3(data = matrix(round(runif(16, 1, 10000)), ncol = 4, nrow = 4), script = &quot;chord.js&quot;) The packages bubble and V8 are intended for use of JavaScript for computations while r2d3, htmlwidgets, and reactR are designed to produce visual outputs (e.g.: graphs and tables), using JavaScript in Shiny can of course be used for the latter but is certainly not limited to that. "],
["the-v8-engine.html", "2 The V8 Engine Installation Basics External Libraries With Npm Use in Packages", " 2 The V8 Engine V8 is an R interface to Google’s open source JavaScript engine of the same name, it powers Google Chrome, node.js and many other things. It is the first integration of JavaScript with R that we cover in this book. Both the V8 package and the engine it wraps are simple yet amazingly powerful. Installation First install the V8 engine itself, instructions to do so are well detailed on V8’s README and below. On Debian or Ubuntu use the code below from the terminal to install libv8. sudo apt-get install -y libv8-dev On Centos install v8-devel, which requires the EPEL tools. sudo yum install epel-release sudo yum install v8-devel On Mac OS use Homebrew. brew install v8 Then install the R package from CRAN. install.packages(&quot;V8&quot;) Basics V8 provides a reference class via R6 (Chang 2019), which pertains to object-oriented programming, hence it might look unconventional to many R users. It’s nonetheless easy to grasp. If one wants to learn more about the R6’s reference class system Hadley Wickham has a very good chapter on it in his Advanced R book. Let’s explore the basic functionalities of the package. First, load the library and use the function v8 to instantiate a class. library(V8) engine &lt;- v8() The eval method allows running JavaScript code from R and retrive the results. engine$eval(&quot;var x = 3 + 4;&quot;) # this is evealuated in R engine$eval(&quot;x&quot;) ## [1] &quot;7&quot; Two observations on the above snippet of code. First, the variable we got back in R is a character vector when it should have been either an integer or a numeric. This is because we used the eval method which merely prints the output, get is more appropriate; it converts it to an appropriate R equivalent. # retrieve our previously created variable (x &lt;- engine$get(&quot;x&quot;)) ## [1] 7 class(x) ## [1] &quot;integer&quot; Second, while creating a scalar with eval(\"var x = 1;\") appears painless, imagine if you will the horror of having to convert a data frame to a JavaScript array via jsonlite then flatten it to character string so it can be used with the eval method. Horrid. Thankfully V8 comes with a method assign, complimentary to get, which declares R objects as JavaScript variables. It takes two arguments, first the name of the variable to create, second the object to assign to it. # assign and retrieve a data.frame engine$assign(&quot;vehicles&quot;, cars[1:3, ]) engine$get(&quot;vehicles&quot;) ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 All of the conversion is handled by V8 internally with jsonlite as demonstrated in the previous chapter. We can confirm that the data frame was converted to a list rowwise; using JSON.stringify to display how the object is store in V8. cat(engine$eval(&quot;JSON.stringify(vehicles, null, 2);&quot;)) ## [ ## { ## &quot;speed&quot;: 4, ## &quot;dist&quot;: 2 ## }, ## { ## &quot;speed&quot;: 4, ## &quot;dist&quot;: 10 ## }, ## { ## &quot;speed&quot;: 7, ## &quot;dist&quot;: 4 ## } ## ] However the cyclical loop of 1) creating a variable in JavaScript to 2) run a function on the aforementioned object 3) get the results back in R, can be tedious. So V8 also allows calling JavaScript functions on R objects directly with the call method and obtain the results back in R. engine$eval(&quot;new Date();&quot;) # using eval ## [1] &quot;Fri May 22 2020 22:25:18 GMT+0200 (CEST)&quot; engine$call(&quot;Date&quot;, Sys.Date()) # using call ## [1] &quot;Fri May 22 2020 22:25:18 GMT+0200 (CEST)&quot; Finally, one can run code interactively rather than as strings by calling the console from the engine with engine$console() you can then exit the console by typing exit or hitting the ESC key. External Libraries V8 is actually quite bare in and of itself, there is for instance no functionalities built-in to read or write files from disk, it thus becomes truly interesting when you can use it JavaScript libraries. We do so with the source method which takes a file argument that will accept a path or URL to a JavaScript file to source. We’ll demonstrate this using fuse.js a fuzzy-search library. engine$source(&quot;https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.4.6/fuse.min.js&quot;) ## [1] &quot;true&quot; You can think of it as using the script tag in HTML to source (src) said file from disk or CDN. &lt;html&gt; &lt;head&gt; &lt;script src=&#39;https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.4.6/fuse.min.js&#39;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Content&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; With the library imported we can use its functionalities. We’ll replicate an example from fuse.js official website where it executes a search on an object that contains books and looks like JSON below. var books = [{ &#39;ISBN&#39;: &#39;A&#39;, &#39;title&#39;: &quot;Old Man&#39;s War&quot;, &#39;author&#39;: &#39;John Scalzi&#39; }, { &#39;ISBN&#39;: &#39;B&#39;, &#39;title&#39;: &#39;The Lock Artist&#39;, &#39;author&#39;: &#39;Steve Hamilton&#39; }] This can be easily created, as we’ve already seen this is just how V8 creates data frames. We define a data.frame of books that looks similar and load it into our engine. books &lt;- data.frame( title = c( &quot;Rights of Man&quot;, &quot;Black Swan&quot;, &quot;Common Sense&quot;, &quot;Sense and Sensibility&quot; ), id = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) ) engine$assign(&quot;books&quot;, books) Then again we can make sure that the data.frame was turned into a rowwise JSON object. cat(engine$eval(&quot;JSON.stringify(books, null, 2);&quot;)) ## [ ## { ## &quot;title&quot;: &quot;Rights of Man&quot;, ## &quot;id&quot;: &quot;a&quot; ## }, ## { ## &quot;title&quot;: &quot;Black Swan&quot;, ## &quot;id&quot;: &quot;b&quot; ## }, ## { ## &quot;title&quot;: &quot;Common Sense&quot;, ## &quot;id&quot;: &quot;c&quot; ## }, ## { ## &quot;title&quot;: &quot;Sense and Sensibility&quot;, ## &quot;id&quot;: &quot;d&quot; ## } ## ] Now we can define options for our search, we don’t get into the details of fuse.js here as this is not the purpose of this book, you can read more about the options in the examples section of the site. We can mimic the format of the JSON options shown on the website with a simple list and assign that to our engine. If this confuses read the JSON section of the introduction. // JavaScript var options = { keys: [&#39;title&#39;], id: &#39;id&#39; } # R options &lt;- list( keys = list(&quot;title&quot;), id = &quot;id&quot; ) engine$assign(&quot;options&quot;, options) Then we can finish the second step of the online examples, instantiate a fuse.js object with our books and options objects then make a simple search, we assign the results of the search to an object which we then retrieve in R with get. engine$eval(&quot;var fuse = new Fuse(books, options)&quot;) engine$eval(&quot;var results = fuse.search(&#39;sense&#39;)&quot;) engine$get(&quot;results&quot;) ## [1] &quot;d&quot; &quot;c&quot; A search for “sense” returns a vector of ids where the term “sense” was found; c and d or the books Common Sense, Sense and Sensibility. We could perhaps make that last code simpler using the call method. engine$call(&quot;fuse.search&quot;, &quot;sense&quot;) ## [1] &quot;d&quot; &quot;c&quot; With Npm We can also use npm packages, though not all will work. Npm is Node’s Package Manager, or in a sense Node’s equivalent of CRAN. To use npm packages we need browserify, a node library to bundle all dependencies of an npm package into a single, file which we can subsequently source in V8. Browserify is itself an npm package and there requires node and npm installed. You can install browserify globally with the following command from the terminal. npm install -g browserify We can now browserify an npm package. To demonstrate we will use ms which converts various time formats to milliseconds. First we install the package. npm install ms Then we browserify it. The first line creates a file called in.js which contains global.ms = require('ms'); we then call browserify on that file specifying ms.js as output file. echo &quot;global.ms = require(&#39;ms&#39;);&quot; &gt; in.js browserify in.js -o ms.js We can now source ms.js with v8. library(V8) ms &lt;- v8() ms$source(&quot;ms.js&quot;) Then use the library. ms$eval(&quot;ms(&#39;2 days&#39;)&quot;) ## [1] &quot;172800000&quot; ms$eval(&quot;ms(&#39;1y&#39;)&quot;) ## [1] &quot;31557600000&quot; Use in Packages In this section we detail how one should go about using V8 in an R package, if you are not familiar with package development you can skip ahead. Create a package however you usually do, using usethis, devtools or the RStudio IDE interface. Below we create a package called “ms” that will hold functionalities we explored in the previous section on npm packages. R -e &quot;usethis::create_package(&#39;ms&#39;)&quot; cd ./ms The package is going to rely on V8 so you can add it under Imports in the DESCRIPTION. We are going to need to instantiate the class at some point (engine &lt;- v8()). One could perhaps require the user to do create such an object but it would not be convenient. Instead we can use .onLoad. You can read more about this function Hadley Wickham’s Advanced R book. The Python integration of R, reticulate (Ushey, Allaire, and Tang 2019) also advises this method to import modules too. We often see this function placed in a zzz.R file. # zzz.R ms &lt;- NULL .onLoad &lt;- function(libname, pkgname){ ms &lt;&lt;- v8() } Our package should also include the external library ms.js we built from the npm package. We should place it in the inst directory. Create it and place the ms.js file within the latter. mkdir -p inst This should give a directory similar to this, for brevity we exclude DESCRIPTION, NAMESPACE, and other files that make up a package. R/ | zzz.R inst/ | -- ms.js Now the dependency can be sourced in the .onLoad function. We can access the files in the inst directory with the system.file function. When using the .onLoad function it is goo practice to clean up with .onUnload. # zzz.R ms &lt;- NULL .onLoad &lt;- function(libname, pkgname){ ms &lt;&lt;- v8() dep &lt;- system.file(&quot;ms.js&quot;, package = &quot;ms&quot;) ms$source(dep) } .onUnload &lt;- function(libpath){ ms$reset() } We can then create a to_ms function, it will have access the ms object we instantiated in .onLoad. #&#39; Convert To Millisecond #&#39; #&#39; Convert to milliseconds to various formats. #&#39; #&#39; @param string String to convert. #&#39; #&#39; @export to_ms &lt;- function(string){ ms$call(&quot;ms&quot;, string) } After running devtools::document() and devtools::load_all() the call to_ms(\"2 days\") will return 172800000. "],
["node.html", "3 Node.js with Bubble Basics R Markdown Engine Npm Use in Packages", " 3 Node.js with Bubble A more recent R package, called bubble which will will let you run node.js code from R, the package comes with an REPL and an R markdown engine. As it is still under heavy development the package is not yet available on CRAN, you can get it from Github using either the devtools or remotes package (Hester et al. 2020). # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;ColinFay/bubble&quot;) Basics bubble is very similar to V8, it’s also a reference class and the name of the methods are identical. library(bubble) n &lt;- NodeSession$new() n$eval(&quot;2 + 2;&quot;) ## 4 You can also assign and get variables, just like with v8. n$assign(vehicles, cars[1:2, ]) n$get(vehicles) ## speed dist ## 1 4 2 ## 2 4 10 Bubble also comes with an REPL terminal (read-eval-print loop), which can be launched with bubble::node_repl(). R Markdown Engine Bubble comes with an R markdown engine so JavaScript code can be evaluated in node from an R markdown document such as this one. To do so we simply need to place bubble::set_node_engine() at the top of the document, subsequent node chunks will be evaluated in a node session. bubble::set_node_engine() Once set we can run node code. console.log(2 + 3); ## 5 ## undefined Npm Npm is to node.js what CRAN is to R; a repository of packages that can be conveniently installed. Such packages can be installed using another Reference class called NPM. While with V8 one needs to “browserify” npm packages in hope that they work, with bubble, since it interacts with node js directly, there is no need for to “browserify” packages and we can be assured that they work. Let us demonstrate with the natural package which provides general natural language facility. # initialise and install npm &lt;- Npm$new()$install(&quot;natural&quot;) ## ❯ Add `node_modules` to .gitignore The above snippet initialises npm, which creates the pacakge.json file and a node_modules directory. The first is a DESCRIPTION file for node projects so to speak, the latter is a directory to hold dependencies installed. The packages can then be imported in the node session and interacted with. n$eval(&quot;const natural = require(&#39;natural&#39;)&quot;) ## undefined n$eval(&quot;var tokenizer = new natural.WordTokenizer();&quot;) ## undefined n$eval(&quot;tokenizer.tokenize(&#39;Using nodejs from R with npm.&#39;)&quot;) ## [ &#39;Using&#39;, &#39;nodejs&#39;, &#39;from&#39;, &#39;R&#39;, &#39;with&#39;, &#39;npm&#39; ] Use in Packages To demonstrate how to use bubble in packages we shall build one to hold the functions we explored in the previous section. Then again, if you are not familiar with package development skip this section. Create a package called “organic” using devtools, usethis, or the RStudio IDE. Then edit the DESCRIPTION file so that it imports the bubble package, since it is not yet on CRAN the Github dependency should be specified under Remotes. Package: organic Title: Natural Language Facilities Imports: bubble Remotes: ColinFay/bubble "],
["shiny-1.html", "4 Shiny Static Files Integration From R to JavaScript JavaScript to R In Packages", " 4 Shiny Shiny is by far most popular, if not the only, web framework for the R programming language. In this chapter, after brushing up on the necessary to include JavaScript in our applications, we explore how to blend the JavaScript language with our R back-end. Then again, the aim is not to write a lot of convoluted JavaScript, on the contrary, it is to write as little as possible and demonstrate to the reader that it is often enough to greatly improve the user experience of shiny applications. Making shiny work with JavaScript can essentially be broken down into two operations: 1) passing data from the R server to the JavaScript client and 2) the other way around, from the client to the R server. Static Files In order to introduce JavaScript to shiny applications one must understand static files and how they work with the framework. Static files are files that are downloaded by the clients (web browsers) as-is and generally include images, CSS (.css), and JavaScript (.js). There are numerous ways to run a shiny application locally; the two most used ones are probably shinyApp and runApp. The RStudio IDE comes with a convenient “Run” button when writing a shiny application, which when clicked know actually uses the function shiny::runApp in the background, this function looks for said static files in the www directory and makes them available at the same path (/www). If you are building your applications outside of RStudio, you should either also use shiny::runApp or specify the directory which then allows simply using shiny::shinyApp. Note that this only applies locally, shiny server (community and pro) as well as shinyapps.io use the same defaults as the RStudio IDE. In order to ensure the code in this book can run regardless of the reader’s machine or editor, the asset directory is always specified. This is probably advised to steer clear of the potential headaches as, unlike the default, it’ll work regardless of the environment. If you are using golem (Guyader et al. 2020) to develop your application then you should not worry about this as it specifies the directory internally. Below we build a basic shiny application, however, before we define the ui and server we use the shiny::addResourcePath function to specify the location of the directory of static files that will be served by the server and thus accessible by the client. This function takes two arguments, first the prefix, which is the path (URL) at which the assets will be available, second the path to the directory of static assets. We thus create the “assets” directory and a JavaScript file called script.js within it. # run from root of app (where app.R is located) dir.create(&quot;assets&quot;) writeLines(&quot;console.log(&#39;Hello JS!&#39;);&quot;, con = &quot;assets/script.js&quot;) We can now use the shiny::addResourcePath to point to this directory. Generally developers use the same name for the directory of static assets and prefix so as to avoid confusion, below we name them differently in order for the reader to clearly distinguish which is which. # app.R library(shiny) # serve the files addResourcePath(prefix = &quot;files&quot;, directoryPath = &quot;assets&quot;) ui &lt;- fluidPage( h1(&quot;R and JavaScript&quot;) ) server &lt;- function(input, output){} shinyApp(ui, server) If you then run the application and open it at the /files/script.js path (e.g.:127.0.0.1:3000/files/script.js) you should see the content of our JavaScript file (console.log('Hello JS!')), commenting the addResourcePath line will have a “Not Found” error displayed on the page instead. All files in your asset directory will be served online and accessible to anyone: do not place sensitive files in it. Though one may create multiple such directory and correspondingly use addResourcePath to specify multiple paths and prefixes, one will generally specify a single one, named “assets” or “static,” which contains multiple subdirectories, one for each type of static asset file to obtain a directory that looks something like the tree below. assets/ ├── js/ │ └── script.js ├── css/ │ └── style.css └── img/ └── pic.png At this stage we have made the JavaScript file we created accessible by the clients but we still have to source this file in our ui. Were one creating a static HTML page one would use the script to src the file in the head of the page. &lt;html&gt; &lt;head&gt; &lt;!–– source the JavaScript file ––&gt; &lt;script src=&quot;path/to/script.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=&quot;content&quot;&gt;Trying JavaScript!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; In shiny we generally write the ui in R and not in HTML. Given the resemblance between the names of HTML tags and shiny UI functions it’s pretty straightforward, the html page above would look something like the shiny ui below. library(shiny) ui &lt;- fluidPage( tags$head( tags$script(src = &quot;path/to/script.js&quot;) ), p(id = &quot;content&quot;, &quot;Trying JavaScript!&quot;) ) Note that we use the tags object which comes with shiny and includes HTML tags that are not exported as standalone functions. For instance, you can create a &lt;div&gt; in shiny with the div function but tags$div will also work. This can now be applied to the shiny application, the path/to/script.js should be changed to files/script.js where files is the prefix we defined in addResourcePath. # app.R library(shiny) # serve the files addResourcePath(prefix = &quot;files&quot;, directoryPath = &quot;assets&quot;) ui &lt;- fluidPage( tags$head( tags$script(src = &quot;files/script.js&quot;) ), h1(&quot;R and JavaScript&quot;) ) server &lt;- function(input, output){} shinyApp(ui, server) From the browser, inspecting page (right click &gt; inspect) one should see “Hello JS!” in the console which means our application correctly ran the code in our JavaScript file. Integration The follow sections will walk you through an example in which one first starts with a basic hello-world-like JavaScript example and ends up with a fully-fledged R package that brings new functionalities to shiny by integrating a third party library. We first build an application that passes a message from the R server to the JavaScript client to display said message as an vanilla JavaScript alert (pop-up), then have a callback function to know whether the user has clicked ‘OK’ server-side. Finally we replicate that but with an external library and wrap the whole project into a fully functional package. First, let’s write a barebone shiny application which includes the JavaScript code which opens an alert. library(shiny) ui &lt;- fluidPage( tags$script( &quot;alert(&#39;Hello from JavaScript&#39;);&quot; ), h1(&quot;Hello&quot;) ) server &lt;- function(input, output, session){} shinyApp(ui, server) JavaScript alert in shiny One thing important to note for later is that the content of our application (h1(\"hello\")) is not actually shown until the user clicks “OK.” Alert will always block the execution of code, it is used less and less but allows making sure some code is only run with user consent or the user being aware of the consequences. alert(&#39;delete everything?&#39;); deleteEverythingOnlyIfUserOK(); From R to JavaScript Now that we have a simple alert displayed in the application we can tie with our R server; the alert should display a message sent by the R server, this would enable us to, for instance, easily have the alert display a message taken from a database or a user input. As might be expected there are two functions required to do so, an R function and its JavaScript complementary: one to send the data from the server and another to catch said data from the client. Let us start by writing the R code to send the data, thankfully very little is required of the developer. One can send data from the R server to the client from the session object using the sendCustomMessage method. The method takes two arguments, first an identifier (where to send the data to), second the actual data to send to JavaScript. library(shiny) ui &lt;- fluidPage( tags$script( &quot;alert(&#39;Hello from JavaScript&#39;);&quot; ), h1(&quot;Hello&quot;) ) server &lt;- function(input, output, session){ # set the identifier to send-alert session$sendCustomMessage(type = &quot;send-alert&quot;, message = &quot;Hi there!&quot;) } shinyApp(ui, server) This effectively sends our message to the JavaScript client but we are yet to use that message JavaScript-side so the application still displays the same alert on load. We can add a “handler” for the identifier we defined (send-alert) which will so something with the message we sent from the server. This is done with the addCustomMessageHandler method from the Shiny object where the first argument is the identifier and the second is the function that handles the message, generally a function that takes a single argument: the data sent from the server. library(shiny) ui &lt;- fluidPage( tags$script( &quot;Shiny.addCustomMessageHandler(type = &#39;send-alert&#39;, function(message) { alert(message); });&quot; ), h1(&quot;Hello&quot;) ) server &lt;- function(input, output, session){ # set the identifier to send-alert session$sendCustomMessage(type = &quot;send-alert&quot;, message = &quot;Hi there!&quot;) } shinyApp(ui, server) Alert sent from shiny server JavaScript to R In Packages "],
["references.html", "References", " References Chamberlain, Scott, and Jeff Hollister. 2019. Lawn: Client for ’Turfjs’ for ’Geospatial’ Analysis. https://CRAN.R-project.org/package=lawn. Chang, Winston. 2019. R6: Encapsulated Classes with Reference Semantics. https://CRAN.R-project.org/package=R6. Chang, Winston, Joe Cheng, JJ Allaire, Yihui Xie, and Jonathan McPherson. 2020. Shiny: Web Application Framework for R. https://CRAN.R-project.org/package=shiny. Coene, John. 2020. Waiter: Loading Screen for ’Shiny’. Csárdi, Gábor. 2020. Cli: Helpers for Developing Command Line Interfaces. https://CRAN.R-project.org/package=cli. Fay, Colin. 2020. Bubble: Launch and Interact with a Nodejs Session. Guyader, Vincent, Colin Fay, Sébastien Rochette, and Cervan Girard. 2020. Golem: A Framework for Robust Shiny Applications. https://CRAN.R-project.org/package=golem. Hester, Jim, Gábor Csárdi, Hadley Wickham, Winston Chang, Martin Morgan, and Dan Tenenbaum. 2020. Remotes: R Package Installation from Remote Repositories, Including ’Github’. https://CRAN.R-project.org/package=remotes. Inc, Facebook, Michel Weststrate, Kent Russell, and Alan Dipert. 2019. ReactR: React Helpers. https://CRAN.R-project.org/package=reactR. Kunst, Joshua. 2019. Highcharter: A Wrapper for the ’Highcharts’ Library. https://CRAN.R-project.org/package=highcharter. Lin, Greg. 2019. Reactable: Interactive Data Tables Based on ’React Table’. https://CRAN.R-project.org/package=reactable. Luraschi, Javier, and JJ Allaire. 2018. R2d3: Interface to ’D3’ Visualizations. https://CRAN.R-project.org/package=r2d3. Ooms, Jeroen. 2020. Jsonlite: A Robust, High Performance Json Parser and Generator for R. https://CRAN.R-project.org/package=jsonlite. Sievert, Carson, Chris Parmer, Toby Hocking, Scott Chamberlain, Karthik Ram, Marianne Corvellec, and Pedro Despouy. 2020. Plotly: Create Interactive Web Graphics via ’Plotly.js’. https://CRAN.R-project.org/package=plotly. Ushey, Kevin, JJ Allaire, and Yuan Tang. 2019. Reticulate: Interface to ’Python’. https://CRAN.R-project.org/package=reticulate. Vaidyanathan, Ramnath, Yihui Xie, JJ Allaire, Joe Cheng, and Kenton Russell. 2019. Htmlwidgets: HTML Widgets for R. https://CRAN.R-project.org/package=htmlwidgets. Wickham, Hadley, and Jennifer Bryan. 2020. Usethis: Automate Package and Project Setup. Wickham, Hadley, Peter Danenberg, Gábor Csárdi, and Manuel Eugster. 2020. Roxygen2: In-Line Documentation for R. https://CRAN.R-project.org/package=roxygen2. Wickham, Hadley, Jim Hester, and Winston Chang. 2020. Devtools: Tools to Make Developing R Packages Easier. https://CRAN.R-project.org/package=devtools. Xie, Yihui, Joe Cheng, and Xianying Tan. 2020. DT: A Wrapper of the Javascript Library ’Datatables’. https://CRAN.R-project.org/package=DT. "]
]
