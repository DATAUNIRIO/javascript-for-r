[
["index.html", "R and JavaScript Preface", " R and JavaScript John Coene 2020-01-22 Preface The R programming language has seen the integration of many programming languages; C, C++, Python, to name a few, can be seamlessly embedded into R code. Little known to many, R works just as well with JavaScript—this book delves into the various ways both languages can work together. The ultimate aim of this work is to put the reader at ease with inviting JavaScript in their data science workflow. "],
["about-the-author.html", "About the Author", " About the Author Frida Gomam is a famous lady. Police will always let her go. "],
["intro.html", "Chapter 1 Introduction Prerequisites Rationale Methods JSON JavaScript", " Chapter 1 Introduction In this chapter, after briefly going through prerequisites, we provide a rationale for integrating JavaScript with R which we support with examples, namely packages available on CRAN. Then, we list the various ways in which one might go about making both languages work together. Finally, we end with a review of concepts fundamental to fully understand the more advanced topics residing in later chapters. Prerequisites The code contained in the following pages is approachable to readers with basic knowledge of R, although being familiar with R6 classes (Chang 2019), package development with devtools (Wickham, Hester, and Chang 2019), and Shiny (Chang et al. 2019) is helpful. Only basic knowledge of JavaScript is required to understand and learn from the book as not only is JavaScript rather uncomplicated and its syntax similar to R’s in places, we write surprisingly little of it. Understanding of JSON and HTML, however, is essential. In essence, if one has already used external JavaScript libraries in HTML or R markdown documents then one is well-equipped to tackle this book but in the event that you have not, we will go through a quick review of the basics of both JavaScript and JSON at the end of the chapter. Rationale Why merge JavaScript and R? They are two fundamentally different languages that each have their strengths and weaknesses, combining the two allows making the most of their consolidated advantages and circumvent their respective limitations to produce software altogether better for it. A fair reason to use JavaScript might simply be that the thing one wants to achieve in R has already been realised in JavaScript. Why reinvent the wheel when the solution already exists and that it can be made accessible from R? The R package lawn (Chamberlain and Hollister 2019) by Ropensci integrates turf.js, a brilliant library for geo-spatial analysis. JavaScript is not required to make those computations, it could be rewritten solely in R but that would be vastly more laborious than wrapping the JavaScript API in R. library(lawn) lawn_count(lawn_data$polygons_count, lawn_data$points_count, &quot;population&quot;) ## &lt;FeatureCollection&gt; ## Bounding box: -112.1 46.6 -112.0 46.6 ## No. features: 2 ## No. points: 20 ## Properties: ## values count ## 1 200, 600 2 ## 2 0 Another great reason is that JavaScript can do things that R cannot, e.g.: run in the browser. Therefore one cannot natively create interactive visualisations with R. Plotly (Sievert et al. 2019) by Carson Sievert packages the plotly JavaScript library to let one create interactive visualisations solely from R code. library(plotly) plot_ly(diamonds, x = ~cut, color = ~clarity) Finally, JavaScript can work together with R to improve how we communicate insights. One of the many ways in which Shiny stands out is that it lets one create web applications solely from R code with no knowledge of HTML, CSS, or JavaScript but that does not mean they can’t extend Shiny, quite the contrary. The waiter package (Coene 2020) integrates a variety of JavaScript libraries to display loading screens in Shiny applications. library(shiny) library(waiter) ui &lt;- fluidPage( use_waiter(), # include dependencies actionButton(&quot;show&quot;, &quot;Show loading for 3 seconds&quot;) ) server &lt;- function(input, output, session){ # create a waiter w &lt;- Waiter$new() # on button click observeEvent(input$show, { w$show() Sys.sleep(3) w$hide() }) } shinyApp(ui, server) Hopefully this makes a couple of great reasons and alluring examples to entice you to persevere with this book. Methods Though perhaps not obvious at first, all of the packages used as examples in the previous section internally interface with JavaScript very differently. As we’ll discover, there many ways in which one can blend JavaScript with R, generally the way to go about it is dictated by the nature of is to be achieved. Let’s list the methods available to us to blend JavaScript with R before covering them each in-depth in their own respective chapter later in the book. V8 V8 by Jeroen Ooms is an R interface to Google’s JavaScript engine. It will let you run JavaScript code directly from R and get the result back, it even comes with an interactive console. This is the way the lawn package used in a previous example has internally calls turf.js. library(V8) ## Using V8 engine 3.14.5.9 ctx &lt;- v8() ctx$eval(&quot;2 + 2&quot;) # this is evaluated in JavaScript! ## [1] &quot;4&quot; htmlwidgets htmlwidgets (Vaidyanathan et al. 2019) specialises in wrapping JavaScript libraries that generate visual outputs. This is what packages such as plotly, DT (Xie, Cheng, and Tan 2019), highcharter (Kunst 2019), and many more use to provide interactive visualisation with R. It is by far the most popular integration out there, at the time of writing this it has been downloaded nearly 10 million times from CRAN. It will therefore be covered extensively in later chapters. Shiny The Shiny framework allows creating applications accessible from web browsers where JavaScript natively runs, it follows that JavaScript can run alongside such applications. Often overlooked though, the two can also work hand-in-hand as one can pass data from the R server to the JavaScript front-end and vice versa. Some form of that tends to be included in htmlwidgets so one can pick up server-side which point on a scatter plot was clicked for instance. reactR ReactR (Inc et al. 2019) is an R package that emulates very well htmlwidgets but specifically for the React framework. Unlike htmlwidgets it is not limited to visual outputs and also provides functions to build inputs, e.g.: a drop-down menu (like shiny::selectInput). The reactable package (Lin 2019) uses reactR to enable building interactive tables solely from R code. reactable::reactable(iris[1:5, ], showPagination = TRUE) Note that custom Shiny inputs can also be built, this is however not covered in this book for it is very well documented. bubble bubble (Fay 2020) by Colin Fay is a more recent R package, still under heady development but very promising: it lets one run node.js code in R, comes with an interactive node REPL, the ability to install npm packages, and even an R markdown engine. It’s similar to V8 in many ways. library(bubble) n &lt;- NodeSession$new() n$eval(&quot;2 + 2&quot;) # this is evaluated in node.js ## 4 r2d3 r2d3 (Luraschi and Allaire 2018) by RStudio is an R package designed specifically to work with d3.js. It is similar to htmlwidgets but works rather differently. # https://rstudio.github.io/r2d3/articles/gallery/chord/ r2d3::r2d3(data = matrix(round(runif(16, 1, 10000)), ncol = 4, nrow = 4), script = &quot;chord.js&quot;) The packages bubble and V8 are intended for use of JavaScript for computations while r2d3, htmlwidgets, and reactR are designed to produce visual outputs (e.g.: graphs and tables), using JavaScript in Shiny can of course be used for the latter but is certainly not limited to that. JSON JSON (JavaScript Object Notation) is a very popular data interchange format with which we will work extensively throughout this book, it is thus crucial that we have a good understanding of it before we plunge into the nitty-gritty. As one might foresee, if we want two languages to work together it is essential that we have a data format that can be understood by both—JSON lets us harmoniously pass data from one to the other. While it is natively supported in JavaScript, it can be graciously handled in R with the jsonlite package (Ooms, Temple Lang, and Hilaiel 2018), in fact it is the serialiser used internally by all of the methods detailed in the previous section. JSON is to all intents and purposes the equivalent of lists in R; a flexible data format that can store pretty much anything. Below we create a nested list and convert it to JSON with the help of jsonlite, we set pretty to TRUE to add indentation for clearer printing. # install.packages(&quot;jsonlite&quot;) library(jsonlite) lst &lt;- list( a = 1, b = list( c = c(&quot;A&quot;, &quot;B&quot;) ), d = 1:5 ) toJSON(lst, pretty = TRUE) ## { ## &quot;a&quot;: [1], ## &quot;b&quot;: { ## &quot;c&quot;: [&quot;A&quot;, &quot;B&quot;] ## }, ## &quot;d&quot;: [1, 2, 3, 4, 5] ## } Looking closely at the list and JSON output above one quickly sees the resemblance. Something seems odd though, the first value in the list (a = 1) was serialised; to an array (vector) of length one (\"a\": [1]) where would probably expect an integer instead. This is not a mistake, we often forget that there are no scalar types in R and that a is in fact a vector as we can observe below. x &lt;- 1 is.vector(x) ## [1] TRUE JavaScript, on the other hand, does have scalar types, more often than not we will want to convert our vectors of length one to scalar types rather than arrays of length one. To do so we need use the auto_unbox argument in jsonlite::toJSON, we’ll do this most of the time we have to convert data to JSON. toJSON(lst, pretty = TRUE, auto_unbox = TRUE) ## { ## &quot;a&quot;: 1, ## &quot;b&quot;: { ## &quot;c&quot;: [&quot;A&quot;, &quot;B&quot;] ## }, ## &quot;d&quot;: [1, 2, 3, 4, 5] ## } As demonstrated above the vector of length one was “unboxed” into an integer, with auto_unbox set to TRUE jsonlite will properly convert such vectors into their appropriate type; integer, numeric, boolean, etc. If JSON is more or less the equivalent of lists in R one might wonder how jsonlite handles data frames. # subset of built-in dataset df &lt;- cars[1:2, ] toJSON(df, pretty = TRUE) ## [ ## { ## &quot;speed&quot;: 4, ## &quot;dist&quot;: 2 ## }, ## { ## &quot;speed&quot;: 4, ## &quot;dist&quot;: 10 ## } ## ] What jsonlite does internally is essentially turn the data.frame into a list rowwise to produce a list for every row. This generally how rectangular data is represented in lists, for instance, purrr::transpose does the same. We can reproduce this with the snippet below, we remove row names and use apply to turn every row into a list. row.names(df) &lt;- NULL df_list &lt;- apply(df, 1, as.list) toJSON(df_list, pretty = TRUE, auto_unbox = TRUE) ## [ ## { ## &quot;speed&quot;: 4, ## &quot;dist&quot;: 2 ## }, ## { ## &quot;speed&quot;: 4, ## &quot;dist&quot;: 10 ## } ## ] Jsonlite of course also enables reading data from JSON into R with the function fromJSON. json &lt;- toJSON(df) # convert to JSON fromJSON(json) # read from JSON ## speed dist ## 1 4 2 ## 2 4 10 It’s important to note that jsonlite did the conversion back to a data frame. Therefore the code below also returns a data frame even though the object we initially converted to JSON is a list. class(df_list) ## [1] &quot;list&quot; json &lt;- toJSON(df_list) fromJSON(json) ## speed dist ## 1 4 2 ## 2 4 10 Jsonlite provides many more options and functions that will let you tune JSON data in read to and written from R. Also, the jsonlite package does far more than what we detailed but at this juncture this is an adequate understanding of things. JavaScript The book is not meant to teach one JavaScript, only to show how graciously it can work with R; in that endeavour we aim at writing little JavaScript so the book remains approachable to a wide audience. Let us just go through the very basics to ensure we know enough to get started with the next chapter. In the event that you would want to try what we briefly explore here: the easiest way is to create an HTML file, write your code within a script tag and open the file in your web browser. The output can be observed in the console of the browser which can be opened with a right click and selecting “inspect” then going to the “console” tab. &lt;!–– index.html ––&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=&quot;content&quot;&gt;Trying JavaScript!&lt;/p&gt; &lt;/body&gt; &lt;script&gt; // place your JavaScript code here &lt;/script&gt; &lt;/html&gt; The first difference with R is that the end of every line should be marked with a semi-colon. JavaScript code will often work without but one should always include them to avoid issues. Below we use console.log, JavaScript equivalent of R’s print function. console.log(&quot;hello JavaScript&quot;) // bad console.log(&quot;hello JavaScript&quot;); // good Another difference is that variables must be declared with keywords such as var or const to declare a constant. x = 1; // bad var x = 1; // good One can declare a variable without assigning a value to it, to then do so later on. // good var y; y = [1,2,3]; In R like in JavaScript, variables can be accessed from the parent environment (often referred to as “context” in the latter). One immense difference though is that while it is seen as bad practice in R it is not in JavaScript where it comes very useful. # it works but don&#39;t do this x &lt;- 123 foo &lt;- function(){ print(x) } foo() ## [1] 123 The above R code can be re-written in JavaScript. Note the slight variation in the function declaration. // this is perfectly fine var x = 1; function foo(){ console.log(x); } foo() One concept which does not exist in R is that of the “DOM” which stands for Document Object Model. When a web page is loaded, the browser creates a Document Object Model of the page which can be accessed in JavaScript from the document object. This lets the developer programmatically manipulate the page itself so one can for instance, remove a button, change the text of an element, and plenty more. The JavaScript code below grabs the element where id=content from the document with getElementById. &lt;!–– index.html ––&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=&quot;content&quot;&gt;Trying JavaScript!&lt;/p&gt; &lt;/body&gt; &lt;script&gt; var cnt = document.getElementById(&quot;content&quot;); cnt.innerText = &quot;The text has changed&quot;; &lt;/script&gt; &lt;/html&gt; This of course only scratched the surface of JavaScript but provides ample understanding of the language to go ahead with the rest of the book. References "],
["the-v8-engine.html", "Chapter 2 The V8 Engine Installation Basics External Libraries With Npm Use in Packages", " Chapter 2 The V8 Engine V8 is an R interface to Google’s open source JavaScript engine of the same name, it powers Google Chrome, node.js and many other things. It is the first integration of JavaScript with R that we cover in this book. Both the V8 package and the engine it wraps are simple yet amazingly powerful. Installation First install the V8 engine itself, instructions to do so are well detailed on V8’s README and below. On Debian or Ubuntu use the code below from the terminal to install libv8. sudo apt-get install -y libv8-dev On Centos install v8-devel, which requires the EPEL tools. sudo yum install epel-release sudo yum install v8-devel On Mac OS use Homebrew. brew install v8 Then install the R package from CRAN. install.packages(&quot;V8&quot;) Basics V8 provides a reference class, which pertains to object-oriented programming, hence it might look unconventional to many R users. It’s nonetheless easy to grasp. If one wants to learn more about the R6’s reference class system Hadley Wickham has a very good chapter on it in his Advanced R book. Let’s explore the basic functionalities of the package. First, load the library and use the function v8 to instantiate a class. library(V8) engine &lt;- v8() The eval method allows running JavaScript code from R and retrive the results. engine$eval(&quot;var x = 3 + 4;&quot;) # this is evealuated in R engine$eval(&quot;x&quot;) ## [1] &quot;7&quot; Two observations on the above snippet of code. First, the variable we got back in R is a character vector when it should have been either an integer or a numeric. This is because we used the eval method which merely prints the output, get is more appropriate; it converts it to an appropriate R equivalent. # retrieve our previously created variable (x &lt;- engine$get(&quot;x&quot;)) ## [1] 7 class(x) ## [1] &quot;integer&quot; Second, while creating a scalar with eval(\"var x = 1;\") appears painless, imagine if you will the horror of having to convert a data frame to a JavaScript array via jsonlite then flatten it to character string so it can be used with the eval method. Horrid. Thankfully V8 comes with a method assign, complimentary to get, which declares R objects as JavaScript variables. It takes two arguments, first the name of the variable to create, second the object to assign to it. # assign and retrieve a data.frame engine$assign(&quot;vehicles&quot;, cars[1:3, ]) engine$get(&quot;vehicles&quot;) ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 All of the conversion is handled by V8 internally with jsonlite as demonstrated in the previous chapter. We can confirm that the data frame was converted to a list rowwise; using JSON.stringify to display how the object is store in V8. cat(engine$eval(&quot;JSON.stringify(vehicles, null, 2);&quot;)) ## [ ## { ## &quot;speed&quot;: 4, ## &quot;dist&quot;: 2 ## }, ## { ## &quot;speed&quot;: 4, ## &quot;dist&quot;: 10 ## }, ## { ## &quot;speed&quot;: 7, ## &quot;dist&quot;: 4 ## } ## ] However the cyclical loop of 1) creating a variable in JavaScript to 2) run a function on the aforementioned object 3) get the results back in R, can be tedious. So V8 also allows calling JavaScript functions on R objects directly with the call method and obtain the results back in R. engine$eval(&quot;new Date();&quot;) # using eval ## [1] &quot;Wed Jan 22 2020 21:56:40 GMT+0100 (CET)&quot; engine$call(&quot;Date&quot;, Sys.Date()) # using call ## [1] &quot;Wed Jan 22 2020 21:56:40 GMT+0100 (CET)&quot; Finally, one can run code interactively rather than as strings by calling the console from the engine with engine$console() you can then exit the console by typing exit or hitting the ESC key. External Libraries V8 is actually quite bare in and of itself, there is for instance no functionalities built-in to read or write files from disk, it thus becomes truly interesting when you can use it JavaScript libraries. We do so with the source method which takes a file argument that will accept a path or URL to a JavaScript file to source. We’ll demonstrate this using fuse.js a fuzzy-search library. engine$source(&quot;https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.4.6/fuse.min.js&quot;) ## [1] &quot;true&quot; You can think of it as using the script tag in HTML to source (src) said file from disk or CDN. &lt;html&gt; &lt;head&gt; &lt;script src=&#39;https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.4.6/fuse.min.js&#39;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Content&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; With the library imported we can use its functionalities. We’ll replicate an example from fuse.js official website where it executes a search on an object that contains books and looks like JSON below. var books = [{ &#39;ISBN&#39;: &#39;A&#39;, &#39;title&#39;: &quot;Old Man&#39;s War&quot;, &#39;author&#39;: &#39;John Scalzi&#39; }, { &#39;ISBN&#39;: &#39;B&#39;, &#39;title&#39;: &#39;The Lock Artist&#39;, &#39;author&#39;: &#39;Steve Hamilton&#39; }] This can be easily created, as we’ve already seen this is just how V8 creates data frames. We define a data.frame of books that looks similar and load it into our engine. books &lt;- data.frame( title = c( &quot;Rights of Man&quot;, &quot;Black Swan&quot;, &quot;Common Sense&quot;, &quot;Sense and Sensibility&quot; ), id = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) ) engine$assign(&quot;books&quot;, books) Then again we can make sure that the data.frame was turned into a rowwise JSON object. cat(engine$eval(&quot;JSON.stringify(books, null, 2);&quot;)) ## [ ## { ## &quot;title&quot;: &quot;Rights of Man&quot;, ## &quot;id&quot;: &quot;a&quot; ## }, ## { ## &quot;title&quot;: &quot;Black Swan&quot;, ## &quot;id&quot;: &quot;b&quot; ## }, ## { ## &quot;title&quot;: &quot;Common Sense&quot;, ## &quot;id&quot;: &quot;c&quot; ## }, ## { ## &quot;title&quot;: &quot;Sense and Sensibility&quot;, ## &quot;id&quot;: &quot;d&quot; ## } ## ] Now we can define options for our search, we don’t get into the details of fuse.js here as this is not the purpose of this book, you can read more about the options in the examples section of the site. We can mimic the format of the JSON options shown on the website with a simple list and assign that to our engine. If this confuses read the JSON section of the introduction. // JavaScript var options = { keys: [&#39;title&#39;], id: &#39;id&#39; } # R options &lt;- list( keys = list(&quot;title&quot;), id = &quot;id&quot; ) engine$assign(&quot;options&quot;, options) Then we can finish the second step of the online examples, instantiate a fuse.js object with our books and options objects then make a simple search, we assign the results of the search to an object which we then retrieve in R with get. engine$eval(&quot;var fuse = new Fuse(books, options)&quot;) engine$eval(&quot;var results = fuse.search(&#39;sense&#39;)&quot;) engine$get(&quot;results&quot;) ## [1] &quot;d&quot; &quot;c&quot; A search for “sense” returns a vector of ids where the term “sense” was found; c and d or the books Common Sense, Sense and Sensibility. We could perhaps make that last code simpler using the call method. engine$call(&quot;fuse.search&quot;, &quot;sense&quot;) ## [1] &quot;d&quot; &quot;c&quot; With Npm We can also use npm packages, though not all will work. Npm is Node’s Package Manager, or in a sense Node’s equivalent of CRAN. To use npm packages we need browserify, a node library to bundle all dependencies of an npm package into a single, file which we can subsequently source in V8. Browserify is itself an npm package and there requires node and npm installed. You can install browserify globally with the following command from the terminal. npm install -g browserify We can now browserify an npm package. To demonstrate we will use ms which converts various time formats to milliseconds. First we install the package. npm install ms Then we browserify it. The first line creates a file called in.js which contains global.ms = require('ms'); we then call browserify on that file specifying ms.js as output file. echo &quot;global.ms = require(&#39;ms&#39;);&quot; &gt; in.js browserify in.js -o ms.js We can now source ms.js with v8. library(V8) ms &lt;- v8() ms$source(&quot;ms.js&quot;) Then use the library. ms$eval(&quot;ms(&#39;2 days&#39;)&quot;) ## [1] &quot;172800000&quot; ms$eval(&quot;ms(&#39;1y&#39;)&quot;) ## [1] &quot;31557600000&quot; Use in Packages In this section we detail how one should go about using V8 in an R package, if you are not familiar with package development you can skip ahead. Create a package however you usually do, using usethis (Wickham and Bryan 2019), devtools or the RStudio IDE interface. Below we create a package called “ms” that will hold functionalities we explored in the previous section on npm packages. R -e &quot;usethis::create_package(&#39;ms&#39;)&quot; cd ./ms The package is going to rely on V8 so you can add it under Imports in the DESCRIPTION. We are going to need to instantiate the class at some point (engine &lt;- v8()). One could perhaps require the user to do create such an object but it would not be convenient. Instead we can use .onLoad. You can read more about this function Hadley Wickham’s Advanced R book. The Python integration of R, reticulate (Ushey, Allaire, and Tang 2019) also advises this method to import modules too. We often see this function placed in a zzz.R file. # zzz.R ms &lt;- NULL .onLoad &lt;- function(libname, pkgname){ ms &lt;&lt;- v8() } Our package should also include the external library ms.js we built from the npm package. We should place it in the inst directory. Create it and place the ms.js file within the latter. mkdir -p inst This should give a directory similar to this, for brevity we exclude DESCRIPTION, NAMESPACE, and other files that make up a package. R/ | zzz.R inst/ | -- ms.js Now the dependency can be sourced in the .onLoad function. We can access the files in the inst directory with the system.file function. When using the .onLoad function it is goo practice to clean up with .onUnload. # zzz.R ms &lt;- NULL .onLoad &lt;- function(libname, pkgname){ ms &lt;&lt;- v8() dep &lt;- system.file(&quot;ms.js&quot;, package = &quot;ms&quot;) ms$source(dep) } .onUnload &lt;- function(libpath){ ms$reset() } We can then create a to_ms function, it will have access the ms object we instantiated in .onLoad. #&#39; Convert To Millisecond #&#39; #&#39; Convert to milliseconds to various formats. #&#39; #&#39; @param string String to convert. #&#39; #&#39; @export to_ms &lt;- function(string){ ms$call(&quot;ms&quot;, string) } After running devtools::document() and devtools::load_all() the call to_ms(\"2 days\") will return 172800000. References "],
["node.html", "Chapter 3 Node.js with Bubble Basics R Markdown Engine Npm Use in Packages", " Chapter 3 Node.js with Bubble A more recent R package, called bubble which will will let you run node.js code from R, the package comes with an REPL and an R markdown engine. As it is still under heavy development the package is not yet available on CRAN, you can get it from Github using either the devtools or remotes package (Hester et al. 2019). # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;ColinFay/bubble&quot;) Basics bubble is very similar to V8, it’s also a reference class and the name of the methods are identical. library(bubble) n &lt;- NodeSession$new() n$eval(&quot;2 + 2;&quot;) ## 4 You can also assign and get variables, just like with v8. n$assign(vehicles, cars[1:2, ]) n$get(vehicles) ## speed dist ## 1 4 2 ## 2 4 10 Bubble also comes with an REPL terminal (read-eval-print loop), which can be launched with bubble::node_repl(). R Markdown Engine Bubble comes with an R markdown engine so JavaScript code can be evaluated in node from an R markdown document such as this one. To do so we simply need to place bubble::set_node_engine() at the top of the document, subsequent node chunks will be evaluated in a node session. bubble::set_node_engine() Once set we can run node code. console.log(2 + 3); ## 5 ## undefined Npm Npm is to node.js what CRAN is to R; a repository of packages that can be conveniently installed. Such packages can be installed using another Reference class called NPM. While with V8 one needs to “browserify” npm packages in hope that they work, with bubble, since it interacts with node js directly, there is no need for to “browserify” packages and we can be assured that they work. Let us demonstrate with the natural package which provides general natural language facility. # initialise and install npm &lt;- Npm$new()$install(&quot;natural&quot;) ## &gt; Add `node_modules` to .gitignore The above snippet initialises npm, which creates the pacakge.json file and a node_modules directory. The first is a DESCRIPTION file for node projects so to speak, the latter is a directory to hold dependencies installed. The packages can then be imported in the node session and interacted with. n$eval(&quot;const natural = require(&#39;natural&#39;)&quot;) ## undefined n$eval(&quot;var tokenizer = new natural.WordTokenizer();&quot;) ## undefined n$eval(&quot;tokenizer.tokenize(&#39;Using nodejs from R with npm.&#39;)&quot;) ## [ &#39;Using&#39;, &#39;nodejs&#39;, &#39;from&#39;, &#39;R&#39;, &#39;with&#39;, &#39;npm&#39; ] Use in Packages To demonstrate how to use bubble in packages we shall build one to hold the functions we explored in the previous section. Then again, if you are not familiar with package development skip this section. Create a package called “organic” using devtools, usethis, or the RStudio IDE. Then edit the DESCRIPTION file so that it imports the bubble package, since it is not yet on CRAN the Github dependency should be specified under Remotes. Package: organic Title: Natural Language Facilities Imports: bubble Remotes: ColinFay/bubble References "],
["references.html", "References", " References "]
]
