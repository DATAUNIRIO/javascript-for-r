\mainmatter

# (PART) Basics & Roadmap {-}

# Introduction

This book starts with a rationale for integrating JavaScript with R and supports it with examples, namely packages that use JavaScript and are available on CRAN. Then, we go through prerequisites and a review of concepts fundamental to fully understand the more advanced topics residing in the forthcoming chapters. Finally, we list the various ways in which one might go about making both languages work together.

## Rationale {-}

Why blend two languages seemingly so far removed from each other? Precisely because they are fundamentally different languages that each have their strengths and weaknesses, combining the two allows making the most of their consolidated advantages and circumvent their respective limitations to produce software altogether better for it. Though we also uncover other reasons.

Nevertheless, a fair reason to use JavaScript might simply be that the thing one wants to achieve in R has already been realised in JavaScript. Why reinvent the wheel when the solution already exists and that it can be made accessible from R? The R package [lawn](https://github.com/ropensci/lawn) [@R-lawn] by Ropensci integrates [turf.js](http://turfjs.org/), a brilliant library for geo-spatial analysis. JavaScript is by no means required to make those computations, they could be rewritten solely in R but that would be vastly more laborious than wrapping the JavaScript API in R as done by the package lawn.

```{r, warning=FALSE}
library(lawn)

lawn_count(lawn_data$polygons_count, lawn_data$points_count, "population")
```

Another great reason is that JavaScript can do things that R cannot, e.g.: run in the browser. Therefore one cannot natively create interactive visualisations with R. [Plotly](https://plotly-r.com/) [@R-plotly] by Carson Sievert packages the [plotly JavaScript library](https://plot.ly/) to let one create interactive visualisations solely from R code.

```{r, warning=FALSE, message=FALSE, error=FALSE}
library(plotly)

plot_ly(diamonds, x = ~cut, color = ~clarity)
```

Finally, JavaScript can work together with R to improve how we communicate insights. One of the many ways in which Shiny stands out is that it lets one create web applications solely from R code with no knowledge of HTML, CSS, or JavaScript but that does not mean they can't extend Shiny, quite the contrary. The [waiter package](http://waiter.john-coene.com/) [@R-waiter] integrates a variety of JavaScript libraries to display loading screens in Shiny applications.

```r
library(shiny)
library(waiter)

ui <- fluidPage(
  use_waiter(), # include dependencies
  actionButton("show", "Show loading for 3 seconds")
)

server <- function(input, output, session){
  # create a waiter
  w <- Waiter$new()

  # on button click
  observeEvent(input$show, {
    w$show()
    Sys.sleep(3)
    w$hide()
  })
}

shinyApp(ui, server)
```

```{r intro-waiter-output, echo = FALSE, out.width = NULL, fig.align = "left"}
knitr::include_graphics("images/waiter.png", dpi = 300)
```

Hopefully this makes a couple of great reasons and alluring examples to entice the reader to persevere with this book.

## Basics {-}

The code contained in the following pages is approachable to readers with basic knowledge of R, although familiarity with package development using [devtools](https://devtools.r-lib.org/) [@R-devtools], the [Shiny](https://shiny.rstudio.com/) framework [@R-shiny], as well as the JSON data format is helpful. The reason for the former is that some of the ways one builds integrations with JavaScript naturally take the form of R packages. The following section thus runs over the essentials of building a package to ensure everyone can keep up. Then briefly goes through the JSON data format as it will be used to a great extent to communicate between R and JavaScript. Finally, as both Shiny and JavaScript run in the browser they make for axiomatic companions; we'll therefore use Shiny extensively.

Only basic knowledge of JavaScript is required to understand and learn from the book as not only is JavaScript rather uncomplicated and its syntax similar to R's in places, we write surprisingly little of it. Understanding of JSON and HTML, however, is essential. In essence, if one has already used external JavaScript libraries in HTML or R markdown documents then one is well-equipped to tackle this book but in the event that you have not, we will go through a quick review of the basics of both JavaScript and JSON.

It is highly recommended to use the freely available [RStudio IDE](https://rstudio.com/products/rstudio/) to follow along, particularly if you are beginner in R, it makes a lot of things easier down the line.

### Package Development {-}

Developing packages used to be notoriously difficult but things have greatly changed, namely thanks to the devtools, roxygen2 [@R-roxygen2] and more recent [usethis](https://usethis.r-lib.org/) [@R-usethis] packages. The first is specifically designed to help creating packages; setting up tests, running checks, building and installing packages, etc. The second provides an all too convenient way to generate the documentation of packages, and usethis, more broadly helps setting up projects, and automating repetitive tasks. Here, we only skim over the fundamentals, there is an entire book by Hadley Wickham called [R Packages](http://r-pkgs.had.co.nz/) solely dedicated to the topic.

Start by installing those packages from CRAN.

```r
install.packages(c("devtools", "usethis"))
```

We'll create an admittedly ridiculous package to explain how it works. Despite being useless, this package will introduce certain concepts of package development that are essential to understand for what is following. The package will be named "test" and will provide a single function that will print a JavaScript file stored inside our package. Useless but bear with it.

Let's create the package, either do so using the RStudio IDE or with usethis. From the RStudio IDE go to `File > New Project > New Directory` then select "R package" and fill in the small form. But it could be argued that it's actually easier with usethis; type the code below in your R console to create a package named "test" in your current directory. If you run it from RStudio a new project window should open.

```r
usethis::create_package("test")
```

This creates an empty package called "test". Let's add the JavaScript file that the yet-to-be-written R function will eventually print out. R packages must follow strict rules, this file cannot be placed anywhere we want; it must be stored in a directory called `inst` which stands for "installation;" these are files that will simply be copied to the users' machine when they install your package. Create the `inst` directory in the root of the package (e.g.: where the `R` folder is located) and place a file called `javascript.js` within it.

Let's create the following, extremely simple JavaScript file that contains code which declares a variable named `x`. 

```js
// inst/javascript.js
var x = 3;
```

This can all be done from the R console as shown below.

```r
dir.create("inst") # create directory
writeLines("var x = 3;", con = "inst/javascript.js") # create file
```

At this point the package should look something like this.

```
.
├── DESCRIPTION
├── NAMESPACE
├── R
└── inst
    └── javascript.js
```

Onto creating the R function that will read and print this file. Then again, R is strict, R files must be placed in the `R` directory. This can also be done from the console or the RStudio IDE.

```r
# create the file from the R console
file.create("R/function.R")
```

In the `function.R` file we just created we place a function that reads the `javascript.js` file and prints it to the R console. In order to read the file one needs to locate it, as packages are destined to be shared and installed on different machines one can never use absolute paths, where the `javascript.js` file is located will depend on where the user has installed the package: as the developer you can never know that for sure. Therefore R comes with a `system.file` function which will look for a file _relative to a package `inst` directory_ and return its full path.

```r
# R/function.R
print_file <- function(){
  # look for javascript.js in the inst folder of the test package
  file <- system.file("javascript.js", package = "test")
}
```

With the file path one can read the contents  of the `file` and print it.

```r
print_file <- function(){
  file <- system.file("javascript.js", package = "test")
  content <- readLines(file)
  print(content)
}
```

Let's add a pretty message, using the [cli](https://cli.r-lib.org/) [@R-cli] package, before we print the file as it allows introducing another concept; importing external libraries in a package. To use cli we can run:

```r
# install.packages("cli")
usethis::use_package("cli")
## ✔ Adding 'cli' to Imports field in DESCRIPTION
## ● Refer to functions with `cli::fun()`
```

It does exactly what it printed in the console. The `DESCRIPTION` file includes information about the package and, very importantly, dependencies. The package we are creating will depend on the cli package; the `DESCRIPTION` file essentially tells R to check whether it is installed on the machine, if not it installs it (packages are for sharing). You should now see the following entry in the `DESCRIPTION` file.

```r
Imports: 
    cli
```

We can add cli to our function, note that we use the namespace (or package name) followed by a double colon, as was printed by the `usethis::use_package` function we ran earlier.

```r
print_file <- function(){
  file <- system.file("javascript.js", package = "test")
  cli::cli_alert_info("JavaScript code below.")
  content <- readLines(file)
  print(content)
}
```

It's not done just yet. Let's demonstrate why: it allows introducing devtools. We can install the "test" package we created with `devtools::install()`, afterwards we would expect to be able to run the `print_file` function from the package test but doing so returns the following error: `could not find function "print_file"`. This is because we have not explicitly "exported" the function, by default functions and objects declared in `.R` files (in packages) can only be used internally (within the package itself). In order to export it we need another package called roxygen2, it allows writing the documentation in the `.R` file rather than have to create a separate `.Rd` file, a lifesaver. Note that roxygen2 should already be installed as it is a dependency of devtools. Using said documentation we can specify which function should be exported with a "tag".

Tags are preceded by `#' @`, there are plenty of them, we don't explore any other here.

```r
#' @export
print_file <- function(){
  file <- system.file("javascript.js", package = "test")
  cli::cli_alert_info("JavaScript code below.")
  content <- readLines(file)
  print(content)
}
```

Now one can run `devtools::document()` to generate the documentation of the package (the `.Rd` files) using the export tag we added: this exports the function. Then we can run `devtools::install()` to build and install the package.

```r
test::print_file()
## ℹ JavaScript code below.
## [1] "var x = 3;"
```

Finally, the cyclical nature of building packages substitute `devtools::install()` with `devtools::load_all()`, the latter does not install the package and simply loads all the functions and objects of the package in the environment, this is much faster than installing it.

1. Write some code
2. Run `devtools::document()` (not necessary if documentation tags have not changed)
3. Run `devtools::load_all()`
4. Repeat

Note the package we built is good enough for your own machine but won't pass CRAN checks as we miss a lot of the documentation (roxygen2 tags).

### JSON {-}

JSON (JavaScript Object Notation) is a very popular data _interchange_ format with which we will work extensively throughout this book, it is thus crucial that we have a good understanding of it before we plunge into the nitty-gritty. As one might foresee, if we want two languages to work together it is essential that we have a data format that can be understood by both---JSON lets us harmoniously pass data from one to the other. While it is natively supported in JavaScript, it can be graciously handled in R with the [jsonlite package](https://CRAN.R-project.org/package=jsonlite) [@R-jsonlite], in fact it is the serialiser used internally by all of the methods detailed in the previous section.

JSON is to all intents and purposes the equivalent of lists in R; a flexible data format that can store pretty much anything. Below we create a nested list and convert it to JSON with the help of jsonlite, we set `pretty` to `TRUE` to add indentation for clearer printing but this is an argument you should omit when writing production code, it will reduce the file size (fewer spaces = smaller file size). 

```{r}
# install.packages("jsonlite")
library(jsonlite)

lst <- list(
  a = 1,
  b = list(
    c = c("A", "B")
  ),
  d = 1:5
)

toJSON(lst, pretty = TRUE)
```

Looking closely at the list and JSON output above one quickly sees the resemblance. Something seems odd though, the first value in the list (`a = 1`) was serialised to an array (vector) of length one (`"a": [1]`) where one would probably expect an integer instead, `1` not `[1]`. This is not a mistake, we often forget that there are no scalar types in R and that `a` is in fact a vector as we can observe below.

```{r}
x <- 1
length(x)
is.vector(x)
```

JavaScript, on the other hand, does have scalar types, more often than not we will want to convert our vectors of length one to scalar types rather than arrays of length one. To do so we need use the `auto_unbox` argument in `jsonlite::toJSON`, we'll do this most of the time we have to convert data to JSON.

```{r}
toJSON(lst, pretty = TRUE, auto_unbox = TRUE)
```

As demonstrated above the vector of length one was "unboxed" into an integer, with `auto_unbox` set to `TRUE` jsonlite will properly convert such vectors into their appropriate type; integer, numeric, boolean, etc. If JSON is more or less the equivalent of lists in R one might wonder how jsonlite handles dataframes.

```{r}
# subset of built-in dataset
df <- cars[1:2, ]

toJSON(df, pretty = TRUE)
```

What jsonlite does internally is essentially turn the data.frame into a list _rowwise_ to produce a sub-list for every row then it serialises to JSON. This is generally how rectangular data is represented in lists, for instance, `purrr::transpose` does the same. We can reproduce this with the snippet below, we remove row names and use apply to turn every row into a list.

```{r}
row.names(df) <- NULL
df_list <- apply(df, 1, as.list)

toJSON(df_list, pretty = TRUE, auto_unbox = TRUE)
```

Jsonlite of course also enables reading data from JSON into R with the function `fromJSON`.

```{r}
json <- toJSON(df) # convert to JSON
fromJSON(json) # read from JSON
```

It's important to note that jsonlite did the conversion back to a data frame. Therefore the code below also returns a data frame even though the object we initially converted to JSON is a list.

```{r}
class(df_list)
json <- toJSON(df_list)
fromJSON(json)
```

Jsonlite provides many more options and functions that will let you tune how JSON data is read and written. Also, the jsonlite package does far more than what we detailed in this section but at this juncture this is an adequate understanding of things.

### JavaScript {-}

The book is not meant to teach one JavaScript, only to show how graciously it can work with R; in that endeavour we aim at writing little JavaScript so the book remains approachable to a wide audience. Let us just go through the very basics to ensure we know enough to get started with the next chapter.

In the event that you would want to try what we briefly explore here: the easiest way is to create an HTML file (e.g.: `index.html`), write your code within a script tag and open the file in your web browser. The output can be observed in the console of the browser which can be opened with a right click and selecting "inspect" then going to the "console" tab.

```html
 <!–– index.html ––>
<html>
  <head>
  </head>
  <body>
    <p id="content">Trying JavaScript!</p>
  </body>
  <script>
    // place your JavaScript code here
  </script>
</html>
```

The first difference with R is that the end of every line should be marked with a semi-colon. JavaScript code will often work without but one should always include them to avoid future headaches. Below we use `console.log`, JavaScript equivalent of R's `print` function.

```js
console.log("hello JavaScript") // bad
console.log("hello JavaScript"); // good
```

Another difference is that variables must be declared with keywords such as `var` or `const` to declare a constant.

```js
x = 1; // bad
var x = 1; // good
```

One can declare a variable without assigning a value to it, to then do so later on. 

```js
// good
var y; 
y = [1,2,3]; // define it as array
y = 'string'; // change to character string
```

In R like in JavaScript, variables can be accessed from the parent environment (often referred to as "context" in the latter). One immense difference though is that while it is seen as bad practice in R it is not in JavaScript where it is extremely useful.

```{r}
# it works but don't do this in R
x <- 123
foo <- function(){
  print(x)
}
foo()
```

The above R code can be re-written in JavaScript. Note the slight variation in the function declaration.

```js
// this is perfectly fine
var x = 1;

function foo(){
  console.log(x); 
}

foo();
```

One concept which does not exist in R is that of the "DOM" which stands for Document Object Model. When a web page is loaded, the browser creates a Document Object Model of the web page which can be accessed in JavaScript from the `document` object. This lets the developer programmatically manipulate the page itself so one can for instance, add an element (e.g.: a button), change the text of another, and plenty more.

The JavaScript code below grabs the element where `id='content'` from the `document` with `getElementById` and replaces the text (`innerText`). Even though our page only contains "Trying JavaScript!" when the page is opened (loaded) in the web browser JavaScript runs the code and changes it: this happens very fast so the original text cannot be seen.

```html
 <!–– index.html ––>
<html>
  <head>
  </head>
  <body>
    <p id="content">Trying JavaScript!</p>
  </body>
  <script>
    var cnt = document.getElementById("content");
    cnt.innerText = "The text has changed";
  </script>
</html>
```

This of course only scratches the surface of JavaScript thus this provides ample understanding of the language to keep up with the next chapters. Also, a somewhat interesting fact that will prove useful later in the book: the RStudio IDE is actually a browser, therefore, in the IDE, one can right-click and "inspect element" to view the rendered source code.

## Methods {-}

Though perhaps not obvious at first, all of the packages used as examples in the first section of this chapter interfaced with R very differently. As we'll discover, there many ways in which one can blend JavaScript with R, generally the way to go about it is dictated by the nature of what is to be achieved.

Let's list the methods available to us to blend JavaScript with R before covering them each in-depth in their own respective chapter later in the book.

### V8 {-}

[V8](https://github.com/jeroen/v8) by Jeroen Ooms is an R interface to Google's JavaScript engine. It will let you run JavaScript code directly from R and get the result back, it even comes with an interactive console. This is the way the lawn package used in a previous example internally calls turf.js.

```{r}
library(V8)

ctx <- v8()

ctx$eval("2 + 2") # this is evaluated in JavaScript!
```

### htmlwidgets {-}

[htmlwidgets](http://www.htmlwidgets.org/) [@R-htmlwidgets] specialises in wrapping JavaScript libraries that generate visual outputs. This is what packages such as plotly, [DT](https://rstudio.github.io/DT/) [@R-DT], [highcharter](http://jkunst.com/highcharter/) [@R-highcharter], and many more use to provide interactive visualisation with R.

It is by far the most popular integration out there, at the time of writing this it has been downloaded nearly 10 million times from CRAN. It will therefore be covered extensively in later chapters.

### Shiny {-}

The Shiny framework allows creating applications accessible from web browsers where JavaScript natively runs, it follows that JavaScript can run _alongside_ such applications. Often overlooked though, the two can also work _hand-in-hand_ as one can pass data from the R server to the JavaScript front-end and vice versa. Some form of that tends to be included in htmlwidgets so one can pick up server-side which point on a scatter plot was clicked for instance.

### bubble {-}

[bubble](https://github.com/ColinFay/bubble) [@R-bubble] by Colin Fay is a more recent R package, still under heady development but very promising: it lets one run [node.js](https://nodejs.org/en/) code in R, comes with an interactive node REPL, the ability to install npm packages, and even an R markdown engine. It's similar to V8 in many ways.

```{r}
library(bubble)

n <- NodeSession$new() 

n$eval("2 + 2") # this is evaluated in node.js
```

## Methods Amiss {-}

Note that there are also two other prominent ways one can use JavaScript with R that are not covered in this book. The reason they are not covered is that they require great knowledge of specific JavaScript libraries (React and d3.js). However, comes the end of the book, the reader should find the two methods below much more approachable.  

### reactR {-}

[ReactR](https://react-r.github.io/reactR/) [@R-reactR] is an R package that emulates very well htmlwidgets but specifically for the [React framework](https://reactjs.org/). Unlike htmlwidgets it is not limited to visual outputs and also provides functions to build inputs, e.g.: a drop-down menu (like `shiny::selectInput`). The [reactable package](https://glin.github.io/reactable/) [@R-reactable] uses reactR to enable building interactive tables solely from R code.

```{r}
reactable::reactable(iris[1:5, ], showPagination = TRUE)
```

Note that custom Shiny inputs can also be built, this is however not covered in this book for it is very well [documented](https://shiny.rstudio.com/articles/building-inputs.html).

### r2d3 {-}

[r2d3](https://rstudio.github.io/r2d3/) [@R-r2d3] by RStudio is an R package designed specifically to work with [d3.js](https://d3js.org/). It is similar to htmlwidgets but works rather differently.

```{r}
# https://rstudio.github.io/r2d3/articles/gallery/chord/
r2d3::r2d3(data = matrix(round(runif(16, 1, 10000)), ncol = 4, nrow = 4), script = "chord.js")
```
