\mainmatter

# Introduction {#intro}

In this chapter, after briefly going through prerequisites, we provide a rationale for integrating JavaScript with R which we support with examples, namely packages available on CRAN. Then, we list the various ways in which one might go about making both languages work together. Finally, we end with a review of concepts fundamental to fully understand the more advanced topics residing in later chapters.

## Prerequisites {-}

The code contained in the following pages is approachable to readers with basic knowledge of R, although being familiar with [R6 classes](https://r6.r-lib.org/) [@R-R6], package development with [devtools](https://devtools.r-lib.org/) [@R-devtools], and [Shiny](https://shiny.rstudio.com/) [@R-shiny] is helpful. 

Only basic knowledge of JavaScript is required to understand and learn from the book as not only is JavaScript rather uncomplicated and its syntax similar to R's in places, we write surprisingly little of it. Understanding of JSON and HTML, however, is essential. In essence, if one has already used external JavaScript libraries in HTML or R markdown documents then one is well-equipped to tackle this book but in the event that you have not, we will go through a quick review of the basics of both JavaScript and JSON at the end of the chapter.

## Rationale {-}

Why merge JavaScript and R? They are two fundamentally different languages that each have their strengths and weaknesses, combining the two allows making the most of their consolidated advantages and circumvent their respective limitations to produce software altogether better for it.

A fair reason to use JavaScript might simply be that the thing one wants to achieve in R has already been realised in JavaScript. Why reinvent the wheel when the solution already exists and that it can be made accessible from R? The R package [lawn](https://github.com/ropensci/lawn) [@R-lawn] by Ropensci integrates [turf.js](http://turfjs.org/), a brilliant library for geo-spatial analysis. JavaScript is not required to make those computations, it could be rewritten solely in R but that would be vastly more laborious than wrapping the JavaScript API in R.

```{r, warning=FALSE}
library(lawn)

lawn_count(lawn_data$polygons_count, lawn_data$points_count, "population")
```

Another great reason is that JavaScript can do things that R cannot, e.g.: run in the browser. Therefore one cannot natively create interactive visualisations with R. [Plotly](https://plotly-r.com/) [@R-plotly] by Carson Sievert packages the [plotly JavaScript library](https://plot.ly/) to let one create interactive visualisations solely from R code.

```{r, warning=FALSE, message=FALSE, error=FALSE}
library(plotly)

plot_ly(diamonds, x = ~cut, color = ~clarity)
```

Finally, JavaScript can work together with R to improve how we communicate insights. One of the many ways in which Shiny stands out is that it lets one create web applications solely from R code with no knowledge of HTML, CSS, or JavaScript but that does not mean they can't extend Shiny, quite the contrary. The [waiter package](http://waiter.john-coene.com/) [@R-waiter] integrates a variety of JavaScript libraries to display loading screens in Shiny applications.

```r
library(shiny)
library(waiter)

ui <- fluidPage(
  use_waiter(), # include dependencies
  actionButton("show", "Show loading for 3 seconds")
)

server <- function(input, output, session){
  # create a waiter
  w <- Waiter$new()

  # on button click
  observeEvent(input$show, {
    w$show()
    Sys.sleep(3)
    w$hide()
  })
}

shinyApp(ui, server)
```

```{r intro-waiter-output, echo = FALSE, out.width = NULL, fig.align = "left"}
knitr::include_graphics("images/waiter.png", dpi = 300)
```

Hopefully this makes a couple of great reasons and alluring examples to entice you to persevere with this book.

## Methods {-}

Though perhaps not obvious at first, all of the packages used as examples in the previous section internally interface with JavaScript very differently. As we'll discover, there many ways in which one can blend JavaScript with R, generally the way to go about it is dictated by the nature of is to be achieved.

Let's list the methods available to us to blend JavaScript with R before covering them each in-depth in their own respective chapter later in the book.

### V8 {-}

[V8](https://github.com/jeroen/v8) by Jeroen Ooms is an R interface to Google's JavaScript engine. It will let you run JavaScript code directly from R and get the result back, it even comes with an interactive console. This is the way the lawn package used in a previous example has internally calls turf.js.

```{r}
library(V8)

ctx <- v8()

ctx$eval("2 + 2") # this is evaluated in JavaScript!
```

### htmlwidgets {-}

[htmlwidgets](http://www.htmlwidgets.org/) [@R-htmlwidgets] specialises in wrapping JavaScript libraries that generate visual outputs. This is what packages such as plotly, [DT](https://rstudio.github.io/DT/) [@R-DT], [highcharter](http://jkunst.com/highcharter/) [@R-highcharter], and many more use to provide interactive visualisation with R.

It is by far the most popular integration out there, at the time of writing this it has been downloaded nearly 10 million times from CRAN. It will therefore be covered extensively in later chapters.

### Shiny {-}

The Shiny framework allows creating applications accessible from web browsers where JavaScript natively runs, it follows that JavaScript can run _alongside_ such applications. Often overlooked though, the two can also work _hand-in-hand_ as one can pass data from the R server to the JavaScript front-end and vice versa. Some form of that tends to be included in htmlwidgets so one can pick up server-side which point on a scatter plot was clicked for instance.

### reactR {-}

[ReactR](https://react-r.github.io/reactR/) [@R-reactR] is an R package that emulates very well htmlwidgets but specifically for the [React framework](https://reactjs.org/). Unlike htmlwidgets it is not limited to visual outputs and also provides functions to build inputs, e.g.: a drop-down menu (like `shiny::selectInput`). The [reactable package](https://glin.github.io/reactable/) [@R-reactable] uses reactR to enable building interactive tables solely from R code.

```{r}
reactable::reactable(iris[1:5, ], showPagination = TRUE)
```

Note that custom Shiny inputs can also be built, this is however not covered in this book for it is very well [documented](https://shiny.rstudio.com/articles/building-inputs.html).

### bubble {-}

[bubble](https://github.com/ColinFay/bubble) [@R-bubble] by Colin Fay is a more recent R package, still under heady development but very promising: it lets one run [node.js](https://nodejs.org/en/) code in R, comes with an interactive node REPL, the ability to install npm packages, and even an R markdown engine. It's similar to V8 in many ways.

```{r}
library(bubble)

n <- NodeSession$new() 

n$eval("2 + 2") # this is evaluated in node.js
```

### r2d3 {-}

[r2d3](https://rstudio.github.io/r2d3/) [@R-r2d3] by RStudio is an R package designed specifically to work with [d3.js](https://d3js.org/). It is similar to htmlwidgets but works rather differently.

```{r}
# https://rstudio.github.io/r2d3/articles/gallery/chord/
r2d3::r2d3(data = matrix(round(runif(16, 1, 10000)), ncol = 4, nrow = 4), script = "chord.js")
```

The packages bubble and V8 are intended for use of JavaScript for computations while r2d3, htmlwidgets, and reactR are designed to produce visual outputs (e.g.: graphs and tables), using JavaScript in Shiny can of course be used for the latter but is certainly not limited to that.

## JSON {-}

JSON (JavaScript Object Notation) is a very popular data _interchange_ format with which we will work extensively throughout this book, it is thus crucial that we have a good understanding of it before we plunge into the nitty-gritty. As one might foresee, if we want two languages to work together it is essential that we have a data format that can be understood by both---JSON lets us harmoniously pass data from one to the other. While it is natively supported in JavaScript, it can be graciously handled in R with the [jsonlite package](https://CRAN.R-project.org/package=jsonlite) [@R-jsonlite], in fact it is the serialiser used internally by all of the methods detailed in the previous section.

JSON is to all intents and purposes the equivalent of lists in R; a flexible data format that can store pretty much anything. Below we create a nested list and convert it to JSON with the help of jsonlite, we set `pretty` to `TRUE` to add indentation for clearer printing. 

```{r}
# install.packages("jsonlite")
library(jsonlite)

lst <- list(
  a = 1,
  b = list(
    c = c("A", "B")
  ),
  d = 1:5
)

toJSON(lst, pretty = TRUE)
```

Looking closely at the list and JSON output above one quickly sees the resemblance. Something seems odd though, the first value in the list (`a = 1`) was serialised; to an array (vector) of length one (`"a": [1]`) where would probably expect an integer instead. This is not a mistake, we often forget that there are no scalar types in R and that `a` is in fact a vector as we can observe below.

```{r}
x <- 1
is.vector(x)
```

JavaScript, on the other hand, does have scalar types, more often than not we will want to convert our vectors of length one to scalar types rather than arrays of length one. To do so we need use the `auto_unbox` argument in `jsonlite::toJSON`, we'll do this most of the time we have to convert data to JSON.

```{r}
toJSON(lst, pretty = TRUE, auto_unbox = TRUE)
```

As demonstrated above the vector of length one was "unboxed" into an integer, with `auto_unbox` set to `TRUE` jsonlite will properly convert such vectors into their appropriate type; integer, numeric, boolean, etc. If JSON is more or less the equivalent of lists in R one might wonder how jsonlite handles data frames.

```{r}
# subset of built-in dataset
df <- cars[1:2, ]

toJSON(df, pretty = TRUE)
```

What jsonlite does internally is essentially turn the data.frame into a list _rowwise_ to produce a list for every row. This generally how rectangular data is represented in lists, for instance, `purrr::transpose` does the same. We can reproduce this with the snippet below, we remove row names and use apply to turn every row into a list.

```{r}
row.names(df) <- NULL
df_list <- apply(df, 1, as.list)

toJSON(df_list, pretty = TRUE, auto_unbox = TRUE)
```

Jsonlite of course also enables reading data from JSON into R with the function `fromJSON`.

```{r}
json <- toJSON(df) # convert to JSON
fromJSON(json) # read from JSON
```

It's important to note that jsonlite did the conversion back to a data frame. Therefore the code below also returns a data frame even though the object we initially converted to JSON is a list.

```{r}
class(df_list)
json <- toJSON(df_list)
fromJSON(json)
```

Jsonlite provides many more options and functions that will let you tune JSON data in read to and written from R. Also, the jsonlite package does far more than what we detailed but at this juncture this is an adequate understanding of things.

## JavaScript {-}

The book is not meant to teach one JavaScript, only to show how graciously it can work with R; in that endeavour we aim at writing little JavaScript so the book remains approachable to a wide audience. Let us just go through the very basics to ensure we know enough to get started with the next chapter.

In the event that you would want to try what we briefly explore here: the easiest way is to create an HTML file, write your code within a script tag and open the file in your web browser. The output can be observed in the console of the browser which can be opened with a right click and selecting "inspect" then going to the "console" tab.

```html
 <!–– index.html ––>
<html>
  <head>
  </head>
  <body>
    <p id="content">Trying JavaScript!</p>
  </body>
  <script>
    // place your JavaScript code here
  </script>
</html>
```

The first difference with R is that the end of every line should be marked with a semi-colon. JavaScript code will often work without but one should always include them to avoid issues. Below we use `console.log`, JavaScript equivalent of R's `print` function.

```js
console.log("hello JavaScript") // bad
console.log("hello JavaScript"); // good
```

Another difference is that variables must be declared with keywords such as `var` or `const` to declare a constant.

```js
x = 1; // bad
var x = 1; // good
```

One can declare a variable without assigning a value to it, to then do so later on. 

```js
// good
var y; 
y = [1,2,3];
```

In R like in JavaScript, variables can be accessed from the parent environment (often referred to as "context" in the latter). One immense difference though is that while it is seen as bad practice in R it is not in JavaScript where it comes very useful.

```{r}
# it works but don't do this
x <- 123
foo <- function(){
  print(x)
}
foo()
```

The above R code can be re-written in JavaScript. Note the slight variation in the function declaration.

```js
// this is perfectly fine
var x = 1;

function foo(){
  console.log(x); 
}

foo()
```

One concept which does not exist in R is that of the "DOM" which stands for Document Object Model. When a web page is loaded, the browser creates a Document Object Model of the page which can be accessed in JavaScript from the `document` object. This lets the developer programmatically manipulate the page itself so one can for instance, remove a button, change the text of an element, and plenty more.

The JavaScript code below grabs the element where `id=content` from the `document` with `getElementById`. 

```html
 <!–– index.html ––>
<html>
  <head>
  </head>
  <body>
    <p id="content">Trying JavaScript!</p>
  </body>
  <script>
    var cnt = document.getElementById("content");
    cnt.innerText = "The text has changed";
  </script>
</html>
```

This of course only scratched the surface of JavaScript but provides ample understanding of the language to go ahead with the rest of the book.
