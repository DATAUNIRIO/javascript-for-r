# Custom Outputs

In this chapter we create a custom shiny output, in practical terms this creates custom `render*` and `*Output` functions to use in Shiny. This will be demonstrated by creating something akin to the `valueBox` available in the shinydashboard [@R-shinydashboard] package. While similar to what shinydashboard provides this box will 1) be fully customisable and 2) available in any shiny application. 

The `valueBox` equivalent we shall build in this chapter is named "boxxy," and allows creating simple but colourful value boxes with animated numbers (by counting up to it) using [countUp.js](https://github.com/inorganik/countUp.js).

```r
library(shiny)

ui <- fluidPage(
  boxxyOutput("countries")
)

server <- function(input, output){
  output$countries <- renderBoxxy({
    boxxy("Countries", 95)
  })
}

shinyApp(ui, server)
```

![Boxxy - custom output](images/custom-output-boxxy.png)

## Custom outputs inner-workings 

At the core, this consists in creating three functions; `boxxy`, `renderBoxxy` and `boxxyOutput` (analogous to `plot`, `renderPlot`, `plotOutput`) which are linked by an "output binding" in JavaScript. 

The first function, `boxxy` will accept arguments that help define what is in the box. This function is generally useful to preprocess any of the arguments that are meant to produce the custom output. The `boxxyOutput` function essentially creates the scaffold of the HTML output (e.g.: `<div>`) as well as the dependencies. The `render*` function is perhaps more peculiar it should accept an expression and return a function.

Previous work with shiny and JavaScript covered in this book had no dedicated "output" element that were placed in the shiny UI, therefore one had to use a function solely dedicated to importing the dependencies (e.g.: `usejBox`). However, since this is not the case here the dependencies can be attached together with the output.

Finally, the two R functions are "bound" JavaScript-side with an "output binding" that renders the data from the `render*` function with its `*output`.

## Setup

The custom output will be part of a shiny application, let us thus create the basic skeleton of an application and download the dependencies. Create a project in RStudio or an empty directory, then:

1. Create an `app.R` file that will hold the code for the application and `boxxy`, `boxxyOutput`, and `renderBoxxy` functions
2. Create an `assets` directory that will contain the CSS and JavaScript files.
3. Download the countUp.js dependency.
4. Create a `binding.js` JavaScript file for the JavaScript binding within the previously created `assets` directory.
5. Create a `styles.css` file in the `assets` directory.

```r
# application file
file.create("app.R")

# static file directory
dir.create("assets")

# countup dependency
url <- paste0(
  "https://cdn.jsdelivr.net/npm/",
  "countup@1.8.2/countUp.js"
)

download.file(url, "assets/countup.js")

# create binding file
file.create("assets/binding.js")

# CSS file
file.create("assets/styles.css")
```

This should produce the following directory structure.

```
.
├── app.R
└── assets
    ├── binding.js
    ├── countup.js
    └── styles.css
```

## R function

The `boxxy` function takes three arguments, a `title`, a `value` that will be animated and the background `color` to use for the box. The function, at this stage at least, does not preprocess the arguments and simply returns them as a named `list`.

```r
# app.R
library(shiny)

boxxy <- function(title, value, color = "black"){
  list(title = title, value = value, color = color)
}
```

## Output

The `boxxyOutput` function, like all such functions (`plotOutput`, `uiOutput`, etc.) takes an `id`. This function should return an HTML tag which bears an `id`, or a `data-input-id` attribute (more on that later) and a `class`. The `id` is to be defined by the user of the function in Shiny just like any other such outputs. For instance, `plotOutput` creates a `<div>` the `id` of which is actually the `id` used in the `plotOutput` function.

```r
# the id is used as id to the element
shiny::plotOutput(id = "myPlotId")
```

```{r, echo=FALSE}
cat(as.character(shiny::plotOutput("myPlotId")))
```

The `class` is used JavaScript-side to "find" the outputs in the DOM (document object model) and generate the output. The function `boxxyOutput` could thus be as shown below, the `id` is passed along to the `<div>` which is created with a `boxxy` class that will be used in the output binding to find that element and generate the output within that very `<div>` using data that will be passed from the server.

```r
boxxyOutput <- function(id){
  # the HTML output
  shiny::tags$div(
    id = id, class = "boxxy"
  )
}
```

```{block, type='rmdnote'}
Make sure you use unique class names so they are not accidentally overridden by the user.
```

As shown previously the box should include a title and an animated value. These could be generated entirely in JavaScript but it's actually easier to create placeholders with htmltools tags, we generate dynamic ids for those so they can easily be referenced later on in JavaScript: `id-boxxy-value` for the value and `id-boxxy-title` for the title.

```r
boxxyOutput <- function(id){
  # the HTML output
  shiny::tags$div(
    id = id, class = "boxxy",
    h1(
      id = sprintf("%s-boxxy-value", id), 
      class = "boxxy-value"
    ),
    p(
      id = sprintf("%s-boxxy-title", id), 
      class = "boxxy-title"
    )
  )
}
```

Finally, we also used classes in the output so every element it comprises can be styled with ease.

```css
.boxxy{
  text-align: center;
  border-left: 6px solid #073b4c;
  padding: 1em;
}

.boxxy-title{
  text-transform: uppercase;
}

.boxxy-value{
  font-size: 3em;
}
```

The dependencies should be added to the above, since this function must be placed in the UI for anything to work the dependencies can piggyback on the output element. This works using the htmltools package. The function `htmltools::htmlDependency` is used to create a dependency that is then attached with `htmltools::attachDependencies`. While the former creates an object that shiny can understand and translate into `<script>` or `<style>` tags, the former attaches them to the output object and ensures dependencies are not imported multiple times (e.g.: when `boxxyOutput` is used more than once).

```r
boxxyOutput <- function(id){
  el <- shiny::tags$div(
    id = id, class = "boxxy",
    h1(
      id = sprintf("%s-boxxy-counter", id), 
      class = "boxxy-value"
    ),
    p(
      id = sprintf("%s-boxxy-title", id), 
      class = "boxxy-title"
    )
  )

  path <- normalizePath("assets")

  deps <- list(
    htmltools::htmlDependency(
      name = "boxxy",
      version = "1.0.0",
      src = c(file = path),
      script = c("countup.js", "binding.js"),
      stylesheet = "styles.css"
    )
  )

  htmltools::attachDependencies(el, deps)
}
```

Note the use of `normalizePath` to retrieve the full path to the `assets` directory as this will not work with a relative path (e.g.: `./assets`). The dependencies consist of the three files previously created and necessary to generate the output: `countup.js` the dependency that was downloaded as well as `binding.js` and `styles.css`. 

## Render

The function `renderBoxxy` should accept an expression, like other such `render*` function. For instance in the example below the `renderPlot` function does accept an expression which uses, amongst other functions, `plot`.

```r
output$myPlot <- renderPlot({
  # this is an expression
  cars %>% 
    head() %>% 
    plot()
})
```

The function `renderBoxxy` takes an expression and other arguments that are passed to `shiny::exprToFunction` this does pretty much what it says on the tin: it returns a function from an expression (unless that expression is a function, in which case it returns the expression). This function must be further wrapped in another as render functions must return functions.

```r
renderBoxxy <- function(expr, env = parent.frame(), quoted = FALSE) {
  # Convert the expression + environment into a function
  func <- shiny::exprToFunction(expr, env, quoted)

  function(){
    func()
  }
}
```

## JavaScript output binding

Here we create an "output binding," it tells Shiny how to find the component and how to interact with it. An output binding is initialised from `Shiny.OutputBinding`. Below we initialise a new binding.

```js
// custom.js
var boxxyBinding = new Shiny.OutputBinding();
```

Then, this must be "extended" by specifying a number of methods, a very necessary one being `find`. It is used to look for the output HTML element in the document (`scope`), and return them as an array (`HTMLcollection`). Other methods all take an `el` argument; that value will always be an element that was returned from `find`. A very straightforward way to accomplish this is to use jQuery’s find method to identify elements with the `boxxy` class used in `boxxyOutput`. You are by no means forced to use a CSS class to identify the elements but there is no reason not to.

```js
// custom.js
var boxxyBinding = new Shiny.OutputBinding();

$.extend(boxxyBinding, {
  find: function(scope) {
    return $(scope).find(".boxxy");
  }
});
```

One might then want to use the `getId` method which returns the `id` of the element, by default, as can be seen in the [source code](https://github.com/rstudio/shiny/blob/master/srcjs/output_binding.js) (below), the binding returns the id as the `data-input-id` attribute and if that is falsy it returns the element's `id`.

```js
// getId default
this.getId = function(el) {
  return el['data-input-id'] || el.id;
}
```

Since boxxy uses the element id the default will work and this can be skipped entirely. 

Next, one needs to implement the `renderValue` function which is the very function that generates the output based on data used in `boxxy` and sent to the front-end with `renderBoxxy`. The `renderValue` method accepts two arguments, first `el` the element where the output should be generated, this is effectively the output of `boxxyOutput` which the binding found using `find`, the second argument is `data` which is the data passed to `boxxy` and serialised via `renderBoxxy`. 

```{block, type='rmdnote'}
The `renderValue` is in effect very similar if not identical to the JavaScript function of the same name involved in creating htmlwidgets.
```

Let's now tackle the first of the three core aspect of the boxxy output: the title. The `title` should be placed in the previously created placeholder which bears the `id-boxxy-title`.

```js
var boxxyBinding = new Shiny.OutputBinding();

$.extend(boxxyBinding, {
  find: function(scope) {
    return $(scope).find(".boxxy");
  },
  renderValue: function(el, data) {

    // insert the title
    document.getElementById(el.id + '-boxxy-title').innerText = data.title
  }
});
```



```js
var boxxyBinding = new Shiny.OutputBinding();

$.extend(boxxyBinding, {
  find: function(scope) {
    return $(scope).find(".boxxy");
  },
  renderValue: function(el, data) {

    // insert the title
    document.getElementById(el.id + '-boxxy-title').innerText = data.title;

    // counter start at 0
    var counter = new CountUp(el.id + '-boxxy-value', 0, data.value);
    counter.start();
  }
});
```

```js
var boxxyBinding = new Shiny.OutputBinding();

$.extend(boxxyBinding, {
  find: function(scope) {
    return $(scope).find(".boxxy");
  },
  renderValue: function(el, data) {

    el.style.backgroundColor = data.color;

    var counter = new CountUp(el.id + '-boxxy-value', 0, data.value);
    counter.start();
    document.getElementById(el.id + '-boxxy-title').innerText = data.title;
  }
});

Shiny.outputBindings.register(boxxyBinding, "john.boxxy");
```
